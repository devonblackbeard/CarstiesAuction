"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@floating-ui";
exports.ids = ["vendor-chunks/@floating-ui"];
exports.modules = {

/***/ "(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@floating-ui/core/dist/floating-ui.core.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),\n/* harmony export */   computePosition: () => (/* binding */ computePosition),\n/* harmony export */   detectOverflow: () => (/* binding */ detectOverflow),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   hide: () => (/* binding */ hide),\n/* harmony export */   inline: () => (/* binding */ inline),\n/* harmony export */   limitShift: () => (/* binding */ limitShift),\n/* harmony export */   offset: () => (/* binding */ offset),\n/* harmony export */   rectToClientRect: () => (/* reexport safe */ _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect),\n/* harmony export */   shift: () => (/* binding */ shift),\n/* harmony export */   size: () => (/* binding */ size)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/utils */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n    let { reference, floating } = _ref;\n    const sideAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement);\n    const alignmentAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentAxis)(placement);\n    const alignLength = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAxisLength)(alignmentAxis);\n    const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n    const isVertical = sideAxis === \"y\";\n    const commonX = reference.x + reference.width / 2 - floating.width / 2;\n    const commonY = reference.y + reference.height / 2 - floating.height / 2;\n    const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n    let coords;\n    switch(side){\n        case \"top\":\n            coords = {\n                x: commonX,\n                y: reference.y - floating.height\n            };\n            break;\n        case \"bottom\":\n            coords = {\n                x: commonX,\n                y: reference.y + reference.height\n            };\n            break;\n        case \"right\":\n            coords = {\n                x: reference.x + reference.width,\n                y: commonY\n            };\n            break;\n        case \"left\":\n            coords = {\n                x: reference.x - floating.width,\n                y: commonY\n            };\n            break;\n        default:\n            coords = {\n                x: reference.x,\n                y: reference.y\n            };\n    }\n    switch((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement)){\n        case \"start\":\n            coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n            break;\n        case \"end\":\n            coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n            break;\n    }\n    return coords;\n}\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */ const computePosition = async (reference, floating, config)=>{\n    const { placement = \"bottom\", strategy = \"absolute\", middleware = [], platform } = config;\n    const validMiddleware = middleware.filter(Boolean);\n    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n    let rects = await platform.getElementRects({\n        reference,\n        floating,\n        strategy\n    });\n    let { x, y } = computeCoordsFromPlacement(rects, placement, rtl);\n    let statefulPlacement = placement;\n    let middlewareData = {};\n    let resetCount = 0;\n    for(let i = 0; i < validMiddleware.length; i++){\n        const { name, fn } = validMiddleware[i];\n        const { x: nextX, y: nextY, data, reset } = await fn({\n            x,\n            y,\n            initialPlacement: placement,\n            placement: statefulPlacement,\n            strategy,\n            middlewareData,\n            rects,\n            platform,\n            elements: {\n                reference,\n                floating\n            }\n        });\n        x = nextX != null ? nextX : x;\n        y = nextY != null ? nextY : y;\n        middlewareData = {\n            ...middlewareData,\n            [name]: {\n                ...middlewareData[name],\n                ...data\n            }\n        };\n        if (reset && resetCount <= 50) {\n            resetCount++;\n            if (typeof reset === \"object\") {\n                if (reset.placement) {\n                    statefulPlacement = reset.placement;\n                }\n                if (reset.rects) {\n                    rects = reset.rects === true ? await platform.getElementRects({\n                        reference,\n                        floating,\n                        strategy\n                    }) : reset.rects;\n                }\n                ({ x, y } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n            }\n            i = -1;\n            continue;\n        }\n    }\n    return {\n        x,\n        y,\n        placement: statefulPlacement,\n        strategy,\n        middlewareData\n    };\n};\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */ async function detectOverflow(state, options) {\n    var _await$platform$isEle;\n    if (options === void 0) {\n        options = {};\n    }\n    const { x, y, platform, rects, elements, strategy } = state;\n    const { boundary = \"clippingAncestors\", rootBoundary = \"viewport\", elementContext = \"floating\", altBoundary = false, padding = 0 } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n    const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n    const altContext = elementContext === \"floating\" ? \"reference\" : \"floating\";\n    const element = elements[altBoundary ? altContext : elementContext];\n    const clippingClientRect = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(await platform.getClippingRect({\n        element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating)),\n        boundary,\n        rootBoundary,\n        strategy\n    }));\n    const rect = elementContext === \"floating\" ? {\n        ...rects.floating,\n        x,\n        y\n    } : rects.reference;\n    const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n    const offsetScale = await (platform.isElement == null ? void 0 : platform.isElement(offsetParent)) ? await (platform.getScale == null ? void 0 : platform.getScale(offsetParent)) || {\n        x: 1,\n        y: 1\n    } : {\n        x: 1,\n        y: 1\n    };\n    const elementClientRect = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n        rect,\n        offsetParent,\n        strategy\n    }) : rect);\n    return {\n        top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n        bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n        left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n        right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n    };\n}\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */ const arrow = (options)=>({\n        name: \"arrow\",\n        options,\n        async fn (state) {\n            const { x, y, placement, rects, platform, elements, middlewareData } = state;\n            // Since `element` is required, we don't Partial<> the type.\n            const { element, padding = 0 } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state) || {};\n            if (element == null) {\n                return {};\n            }\n            const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n            const coords = {\n                x,\n                y\n            };\n            const axis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentAxis)(placement);\n            const length = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAxisLength)(axis);\n            const arrowDimensions = await platform.getDimensions(element);\n            const isYAxis = axis === \"y\";\n            const minProp = isYAxis ? \"top\" : \"left\";\n            const maxProp = isYAxis ? \"bottom\" : \"right\";\n            const clientProp = isYAxis ? \"clientHeight\" : \"clientWidth\";\n            const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n            const startDiff = coords[axis] - rects.reference[axis];\n            const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n            let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n            // DOM platform can return `window` as the `offsetParent`.\n            if (!clientSize || !await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent))) {\n                clientSize = elements.floating[clientProp] || rects.floating[length];\n            }\n            const centerToReference = endDiff / 2 - startDiff / 2;\n            // If the padding is large enough that it causes the arrow to no longer be\n            // centered, modify the padding so that it is centered.\n            const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n            const minPadding = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(paddingObject[minProp], largestPossiblePadding);\n            const maxPadding = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(paddingObject[maxProp], largestPossiblePadding);\n            // Make sure the arrow doesn't overflow the floating element if the center\n            // point is outside the floating element's bounds.\n            const min$1 = minPadding;\n            const max = clientSize - arrowDimensions[length] - maxPadding;\n            const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n            const offset = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min$1, center, max);\n            // If the reference is small enough that the arrow's padding causes it to\n            // to point to nothing for an aligned placement, adjust the offset of the\n            // floating element itself. To ensure `shift()` continues to take action,\n            // a single reset is performed when this is true.\n            const shouldAddOffset = !middlewareData.arrow && (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) != null && center != offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n            const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n            return {\n                [axis]: coords[axis] + alignmentOffset,\n                data: {\n                    [axis]: offset,\n                    centerOffset: center - offset - alignmentOffset,\n                    ...shouldAddOffset && {\n                        alignmentOffset\n                    }\n                },\n                reset: shouldAddOffset\n            };\n        }\n    });\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n    const allowedPlacementsSortedByAlignment = alignment ? [\n        ...allowedPlacements.filter((placement)=>(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) === alignment),\n        ...allowedPlacements.filter((placement)=>(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) !== alignment)\n    ] : allowedPlacements.filter((placement)=>(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === placement);\n    return allowedPlacementsSortedByAlignment.filter((placement)=>{\n        if (alignment) {\n            return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) === alignment || (autoAlignment ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAlignmentPlacement)(placement) !== placement : false);\n        }\n        return true;\n    });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */ const autoPlacement = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"autoPlacement\",\n        options,\n        async fn (state) {\n            var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n            const { rects, middlewareData, placement, platform, elements } = state;\n            const { crossAxis = false, alignment, allowedPlacements = _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.placements, autoAlignment = true, ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const placements$1 = alignment !== undefined || allowedPlacements === _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n            const overflow = await detectOverflow(state, detectOverflowOptions);\n            const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n            const currentPlacement = placements$1[currentIndex];\n            if (currentPlacement == null) {\n                return {};\n            }\n            const alignmentSides = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentSides)(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n            // Make `computeCoords` start from the right place.\n            if (placement !== currentPlacement) {\n                return {\n                    reset: {\n                        placement: placements$1[0]\n                    }\n                };\n            }\n            const currentOverflows = [\n                overflow[(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(currentPlacement)],\n                overflow[alignmentSides[0]],\n                overflow[alignmentSides[1]]\n            ];\n            const allOverflows = [\n                ...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [],\n                {\n                    placement: currentPlacement,\n                    overflows: currentOverflows\n                }\n            ];\n            const nextPlacement = placements$1[currentIndex + 1];\n            // There are more placements to check.\n            if (nextPlacement) {\n                return {\n                    data: {\n                        index: currentIndex + 1,\n                        overflows: allOverflows\n                    },\n                    reset: {\n                        placement: nextPlacement\n                    }\n                };\n            }\n            const placementsSortedByMostSpace = allOverflows.map((d)=>{\n                const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(d.placement);\n                return [\n                    d.placement,\n                    alignment && crossAxis ? // Check along the mainAxis and main crossAxis side.\n                    d.overflows.slice(0, 2).reduce((acc, v)=>acc + v, 0) : // Check only the mainAxis.\n                    d.overflows[0],\n                    d.overflows\n                ];\n            }).sort((a, b)=>a[1] - b[1]);\n            const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d)=>d[2].slice(0, // Aligned placements should not check their opposite crossAxis\n                // side.\n                (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(d[0]) ? 2 : 3).every((v)=>v <= 0));\n            const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n            if (resetPlacement !== placement) {\n                return {\n                    data: {\n                        index: currentIndex + 1,\n                        overflows: allOverflows\n                    },\n                    reset: {\n                        placement: resetPlacement\n                    }\n                };\n            }\n            return {};\n        }\n    };\n};\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */ const flip = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"flip\",\n        options,\n        async fn (state) {\n            var _middlewareData$arrow, _middlewareData$flip;\n            const { placement, middlewareData, rects, initialPlacement, platform, elements } = state;\n            const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true, fallbackPlacements: specifiedFallbackPlacements, fallbackStrategy = \"bestFit\", fallbackAxisSideDirection = \"none\", flipAlignment = true, ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            // If a reset by the arrow was caused due to an alignment offset being\n            // added, we should skip any logic now since `flip()` has already done its\n            // work.\n            // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n            if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n                return {};\n            }\n            const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n            const isBasePlacement = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(initialPlacement) === initialPlacement;\n            const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n            const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [\n                (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositePlacement)(initialPlacement)\n            ] : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getExpandedPlacements)(initialPlacement));\n            if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== \"none\") {\n                fallbackPlacements.push(...(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxisPlacements)(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n            }\n            const placements = [\n                initialPlacement,\n                ...fallbackPlacements\n            ];\n            const overflow = await detectOverflow(state, detectOverflowOptions);\n            const overflows = [];\n            let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n            if (checkMainAxis) {\n                overflows.push(overflow[side]);\n            }\n            if (checkCrossAxis) {\n                const sides = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentSides)(placement, rects, rtl);\n                overflows.push(overflow[sides[0]], overflow[sides[1]]);\n            }\n            overflowsData = [\n                ...overflowsData,\n                {\n                    placement,\n                    overflows\n                }\n            ];\n            // One or more sides is overflowing.\n            if (!overflows.every((side)=>side <= 0)) {\n                var _middlewareData$flip2, _overflowsData$filter;\n                const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n                const nextPlacement = placements[nextIndex];\n                if (nextPlacement) {\n                    // Try next placement and re-run the lifecycle.\n                    return {\n                        data: {\n                            index: nextIndex,\n                            overflows: overflowsData\n                        },\n                        reset: {\n                            placement: nextPlacement\n                        }\n                    };\n                }\n                // First, find the candidates that fit on the mainAxis side of overflow,\n                // then find the placement that fits the best on the main crossAxis side.\n                let resetPlacement = (_overflowsData$filter = overflowsData.filter((d)=>d.overflows[0] <= 0).sort((a, b)=>a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n                // Otherwise fallback.\n                if (!resetPlacement) {\n                    switch(fallbackStrategy){\n                        case \"bestFit\":\n                            {\n                                var _overflowsData$map$so;\n                                const placement = (_overflowsData$map$so = overflowsData.map((d)=>[\n                                        d.placement,\n                                        d.overflows.filter((overflow)=>overflow > 0).reduce((acc, overflow)=>acc + overflow, 0)\n                                    ]).sort((a, b)=>a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                                if (placement) {\n                                    resetPlacement = placement;\n                                }\n                                break;\n                            }\n                        case \"initialPlacement\":\n                            resetPlacement = initialPlacement;\n                            break;\n                    }\n                }\n                if (placement !== resetPlacement) {\n                    return {\n                        reset: {\n                            placement: resetPlacement\n                        }\n                    };\n                }\n            }\n            return {};\n        }\n    };\n};\nfunction getSideOffsets(overflow, rect) {\n    return {\n        top: overflow.top - rect.height,\n        right: overflow.right - rect.width,\n        bottom: overflow.bottom - rect.height,\n        left: overflow.left - rect.width\n    };\n}\nfunction isAnySideFullyClipped(overflow) {\n    return _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.sides.some((side)=>overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */ const hide = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"hide\",\n        options,\n        async fn (state) {\n            const { rects } = state;\n            const { strategy = \"referenceHidden\", ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            switch(strategy){\n                case \"referenceHidden\":\n                    {\n                        const overflow = await detectOverflow(state, {\n                            ...detectOverflowOptions,\n                            elementContext: \"reference\"\n                        });\n                        const offsets = getSideOffsets(overflow, rects.reference);\n                        return {\n                            data: {\n                                referenceHiddenOffsets: offsets,\n                                referenceHidden: isAnySideFullyClipped(offsets)\n                            }\n                        };\n                    }\n                case \"escaped\":\n                    {\n                        const overflow = await detectOverflow(state, {\n                            ...detectOverflowOptions,\n                            altBoundary: true\n                        });\n                        const offsets = getSideOffsets(overflow, rects.floating);\n                        return {\n                            data: {\n                                escapedOffsets: offsets,\n                                escaped: isAnySideFullyClipped(offsets)\n                            }\n                        };\n                    }\n                default:\n                    {\n                        return {};\n                    }\n            }\n        }\n    };\n};\nfunction getBoundingRect(rects) {\n    const minX = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...rects.map((rect)=>rect.left));\n    const minY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...rects.map((rect)=>rect.top));\n    const maxX = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...rects.map((rect)=>rect.right));\n    const maxY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...rects.map((rect)=>rect.bottom));\n    return {\n        x: minX,\n        y: minY,\n        width: maxX - minX,\n        height: maxY - minY\n    };\n}\nfunction getRectsByLine(rects) {\n    const sortedRects = rects.slice().sort((a, b)=>a.y - b.y);\n    const groups = [];\n    let prevRect = null;\n    for(let i = 0; i < sortedRects.length; i++){\n        const rect = sortedRects[i];\n        if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n            groups.push([\n                rect\n            ]);\n        } else {\n            groups[groups.length - 1].push(rect);\n        }\n        prevRect = rect;\n    }\n    return groups.map((rect)=>(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */ const inline = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"inline\",\n        options,\n        async fn (state) {\n            const { placement, elements, rects, platform, strategy } = state;\n            // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n            // ClientRect's bounds, despite the event listener being triggered. A\n            // padding of 2 seems to handle this issue.\n            const { padding = 2, x, y } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const nativeClientRects = Array.from(await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference)) || []);\n            const clientRects = getRectsByLine(nativeClientRects);\n            const fallback = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getBoundingRect(nativeClientRects));\n            const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n            function getBoundingClientRect() {\n                // There are two rects and they are disjoined.\n                if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n                    // Find the first rect in which the point is fully inside.\n                    return clientRects.find((rect)=>x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n                }\n                // There are 2 or more connected rects.\n                if (clientRects.length >= 2) {\n                    if ((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === \"y\") {\n                        const firstRect = clientRects[0];\n                        const lastRect = clientRects[clientRects.length - 1];\n                        const isTop = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === \"top\";\n                        const top = firstRect.top;\n                        const bottom = lastRect.bottom;\n                        const left = isTop ? firstRect.left : lastRect.left;\n                        const right = isTop ? firstRect.right : lastRect.right;\n                        const width = right - left;\n                        const height = bottom - top;\n                        return {\n                            top,\n                            bottom,\n                            left,\n                            right,\n                            width,\n                            height,\n                            x: left,\n                            y: top\n                        };\n                    }\n                    const isLeftSide = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === \"left\";\n                    const maxRight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...clientRects.map((rect)=>rect.right));\n                    const minLeft = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...clientRects.map((rect)=>rect.left));\n                    const measureRects = clientRects.filter((rect)=>isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n                    const top = measureRects[0].top;\n                    const bottom = measureRects[measureRects.length - 1].bottom;\n                    const left = minLeft;\n                    const right = maxRight;\n                    const width = right - left;\n                    const height = bottom - top;\n                    return {\n                        top,\n                        bottom,\n                        left,\n                        right,\n                        width,\n                        height,\n                        x: left,\n                        y: top\n                    };\n                }\n                return fallback;\n            }\n            const resetRects = await platform.getElementRects({\n                reference: {\n                    getBoundingClientRect\n                },\n                floating: elements.floating,\n                strategy\n            });\n            if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n                return {\n                    reset: {\n                        rects: resetRects\n                    }\n                };\n            }\n            return {};\n        }\n    };\n};\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\nasync function convertValueToCoords(state, options) {\n    const { placement, platform, elements } = state;\n    const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n    const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n    const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement);\n    const isVertical = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === \"y\";\n    const mainAxisMulti = [\n        \"left\",\n        \"top\"\n    ].includes(side) ? -1 : 1;\n    const crossAxisMulti = rtl && isVertical ? -1 : 1;\n    const rawValue = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n    // eslint-disable-next-line prefer-const\n    let { mainAxis, crossAxis, alignmentAxis } = typeof rawValue === \"number\" ? {\n        mainAxis: rawValue,\n        crossAxis: 0,\n        alignmentAxis: null\n    } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        alignmentAxis: null,\n        ...rawValue\n    };\n    if (alignment && typeof alignmentAxis === \"number\") {\n        crossAxis = alignment === \"end\" ? alignmentAxis * -1 : alignmentAxis;\n    }\n    return isVertical ? {\n        x: crossAxis * crossAxisMulti,\n        y: mainAxis * mainAxisMulti\n    } : {\n        x: mainAxis * mainAxisMulti,\n        y: crossAxis * crossAxisMulti\n    };\n}\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */ const offset = function(options) {\n    if (options === void 0) {\n        options = 0;\n    }\n    return {\n        name: \"offset\",\n        options,\n        async fn (state) {\n            var _middlewareData$offse, _middlewareData$arrow;\n            const { x, y, placement, middlewareData } = state;\n            const diffCoords = await convertValueToCoords(state, options);\n            // If the placement is the same and the arrow caused an alignment offset\n            // then we don't need to change the positioning coordinates.\n            if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n                return {};\n            }\n            return {\n                x: x + diffCoords.x,\n                y: y + diffCoords.y,\n                data: {\n                    ...diffCoords,\n                    placement\n                }\n            };\n        }\n    };\n};\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */ const shift = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"shift\",\n        options,\n        async fn (state) {\n            const { x, y, placement } = state;\n            const { mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = false, limiter = {\n                fn: (_ref)=>{\n                    let { x, y } = _ref;\n                    return {\n                        x,\n                        y\n                    };\n                }\n            }, ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const coords = {\n                x,\n                y\n            };\n            const overflow = await detectOverflow(state, detectOverflowOptions);\n            const crossAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement));\n            const mainAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxis)(crossAxis);\n            let mainAxisCoord = coords[mainAxis];\n            let crossAxisCoord = coords[crossAxis];\n            if (checkMainAxis) {\n                const minSide = mainAxis === \"y\" ? \"top\" : \"left\";\n                const maxSide = mainAxis === \"y\" ? \"bottom\" : \"right\";\n                const min = mainAxisCoord + overflow[minSide];\n                const max = mainAxisCoord - overflow[maxSide];\n                mainAxisCoord = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min, mainAxisCoord, max);\n            }\n            if (checkCrossAxis) {\n                const minSide = crossAxis === \"y\" ? \"top\" : \"left\";\n                const maxSide = crossAxis === \"y\" ? \"bottom\" : \"right\";\n                const min = crossAxisCoord + overflow[minSide];\n                const max = crossAxisCoord - overflow[maxSide];\n                crossAxisCoord = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min, crossAxisCoord, max);\n            }\n            const limitedCoords = limiter.fn({\n                ...state,\n                [mainAxis]: mainAxisCoord,\n                [crossAxis]: crossAxisCoord\n            });\n            return {\n                ...limitedCoords,\n                data: {\n                    x: limitedCoords.x - x,\n                    y: limitedCoords.y - y\n                }\n            };\n        }\n    };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */ const limitShift = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        options,\n        fn (state) {\n            const { x, y, placement, rects, middlewareData } = state;\n            const { offset = 0, mainAxis: checkMainAxis = true, crossAxis: checkCrossAxis = true } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const coords = {\n                x,\n                y\n            };\n            const crossAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement);\n            const mainAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxis)(crossAxis);\n            let mainAxisCoord = coords[mainAxis];\n            let crossAxisCoord = coords[crossAxis];\n            const rawOffset = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(offset, state);\n            const computedOffset = typeof rawOffset === \"number\" ? {\n                mainAxis: rawOffset,\n                crossAxis: 0\n            } : {\n                mainAxis: 0,\n                crossAxis: 0,\n                ...rawOffset\n            };\n            if (checkMainAxis) {\n                const len = mainAxis === \"y\" ? \"height\" : \"width\";\n                const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n                const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n                if (mainAxisCoord < limitMin) {\n                    mainAxisCoord = limitMin;\n                } else if (mainAxisCoord > limitMax) {\n                    mainAxisCoord = limitMax;\n                }\n            }\n            if (checkCrossAxis) {\n                var _middlewareData$offse, _middlewareData$offse2;\n                const len = mainAxis === \"y\" ? \"width\" : \"height\";\n                const isOriginSide = [\n                    \"top\",\n                    \"left\"\n                ].includes((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement));\n                const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n                const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n                if (crossAxisCoord < limitMin) {\n                    crossAxisCoord = limitMin;\n                } else if (crossAxisCoord > limitMax) {\n                    crossAxisCoord = limitMax;\n                }\n            }\n            return {\n                [mainAxis]: mainAxisCoord,\n                [crossAxis]: crossAxisCoord\n            };\n        }\n    };\n};\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */ const size = function(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"size\",\n        options,\n        async fn (state) {\n            const { placement, rects, platform, elements } = state;\n            const { apply = ()=>{}, ...detectOverflowOptions } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n            const overflow = await detectOverflow(state, detectOverflowOptions);\n            const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n            const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement);\n            const isYAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === \"y\";\n            const { width, height } = rects.floating;\n            let heightSide;\n            let widthSide;\n            if (side === \"top\" || side === \"bottom\") {\n                heightSide = side;\n                widthSide = alignment === (await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)) ? \"start\" : \"end\") ? \"left\" : \"right\";\n            } else {\n                widthSide = side;\n                heightSide = alignment === \"end\" ? \"top\" : \"bottom\";\n            }\n            const overflowAvailableHeight = height - overflow[heightSide];\n            const overflowAvailableWidth = width - overflow[widthSide];\n            const noShift = !state.middlewareData.shift;\n            let availableHeight = overflowAvailableHeight;\n            let availableWidth = overflowAvailableWidth;\n            if (isYAxis) {\n                const maximumClippingWidth = width - overflow.left - overflow.right;\n                availableWidth = alignment || noShift ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n            } else {\n                const maximumClippingHeight = height - overflow.top - overflow.bottom;\n                availableHeight = alignment || noShift ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n            }\n            if (noShift && !alignment) {\n                const xMin = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.left, 0);\n                const xMax = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.right, 0);\n                const yMin = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.top, 0);\n                const yMax = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.bottom, 0);\n                if (isYAxis) {\n                    availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.left, overflow.right));\n                } else {\n                    availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.top, overflow.bottom));\n                }\n            }\n            await apply({\n                ...state,\n                availableWidth,\n                availableHeight\n            });\n            const nextDimensions = await platform.getDimensions(elements.floating);\n            if (width !== nextDimensions.width || height !== nextDimensions.height) {\n                return {\n                    reset: {\n                        rects: true\n                    }\n                };\n            }\n            return {};\n        }\n    };\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2NvcmUvZGlzdC9mbG9hdGluZy11aS5jb3JlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQXNVO0FBQ2hSO0FBRXRELFNBQVNtQiwyQkFBMkJDLElBQUksRUFBRUMsU0FBUyxFQUFFQyxHQUFHO0lBQ3RELElBQUksRUFDRkMsU0FBUyxFQUNUQyxRQUFRLEVBQ1QsR0FBR0o7SUFDSixNQUFNSyxXQUFXekIsK0RBQVdBLENBQUNxQjtJQUM3QixNQUFNSyxnQkFBZ0J6QixvRUFBZ0JBLENBQUNvQjtJQUN2QyxNQUFNTSxjQUFjekIsaUVBQWFBLENBQUN3QjtJQUNsQyxNQUFNRSxPQUFPekIsMkRBQU9BLENBQUNrQjtJQUNyQixNQUFNUSxhQUFhSixhQUFhO0lBQ2hDLE1BQU1LLFVBQVVQLFVBQVVRLENBQUMsR0FBR1IsVUFBVVMsS0FBSyxHQUFHLElBQUlSLFNBQVNRLEtBQUssR0FBRztJQUNyRSxNQUFNQyxVQUFVVixVQUFVVyxDQUFDLEdBQUdYLFVBQVVZLE1BQU0sR0FBRyxJQUFJWCxTQUFTVyxNQUFNLEdBQUc7SUFDdkUsTUFBTUMsY0FBY2IsU0FBUyxDQUFDSSxZQUFZLEdBQUcsSUFBSUgsUUFBUSxDQUFDRyxZQUFZLEdBQUc7SUFDekUsSUFBSVU7SUFDSixPQUFRVDtRQUNOLEtBQUs7WUFDSFMsU0FBUztnQkFDUE4sR0FBR0Q7Z0JBQ0hJLEdBQUdYLFVBQVVXLENBQUMsR0FBR1YsU0FBU1csTUFBTTtZQUNsQztZQUNBO1FBQ0YsS0FBSztZQUNIRSxTQUFTO2dCQUNQTixHQUFHRDtnQkFDSEksR0FBR1gsVUFBVVcsQ0FBQyxHQUFHWCxVQUFVWSxNQUFNO1lBQ25DO1lBQ0E7UUFDRixLQUFLO1lBQ0hFLFNBQVM7Z0JBQ1BOLEdBQUdSLFVBQVVRLENBQUMsR0FBR1IsVUFBVVMsS0FBSztnQkFDaENFLEdBQUdEO1lBQ0w7WUFDQTtRQUNGLEtBQUs7WUFDSEksU0FBUztnQkFDUE4sR0FB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RyxPQUFPO29CQUNMNEksa0JBQWtCbE0sU0FBUyxJQUFLd00sQ0FBQUEsU0FBUyxLQUFLQyxTQUFTLElBQUlELE9BQU9DLE9BQU8zTix1REFBR0EsQ0FBQzRHLFNBQVN2QyxHQUFHLEVBQUV1QyxTQUFTdEMsTUFBTTtnQkFDNUc7WUFDRjtZQUNBLE1BQU13SSxNQUFNO2dCQUNWLEdBQUdoSyxLQUFLO2dCQUNSdUs7Z0JBQ0FEO1lBQ0Y7WUFDQSxNQUFNUSxpQkFBaUIsTUFBTW5NLFNBQVNtRCxhQUFhLENBQUNoQyxTQUFTckMsUUFBUTtZQUNyRSxJQUFJUSxVQUFVNk0sZUFBZTdNLEtBQUssSUFBSUcsV0FBVzBNLGVBQWUxTSxNQUFNLEVBQUU7Z0JBQ3RFLE9BQU87b0JBQ0x3QixPQUFPO3dCQUNMWixPQUFPO29CQUNUO2dCQUNGO1lBQ0Y7WUFDQSxPQUFPLENBQUM7UUFDVjtJQUNGO0FBQ0Y7QUFFc0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWItYXBwLy4vbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS9jb3JlL2Rpc3QvZmxvYXRpbmctdWkuY29yZS5tanM/NTZiZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRTaWRlQXhpcywgZ2V0QWxpZ25tZW50QXhpcywgZ2V0QXhpc0xlbmd0aCwgZ2V0U2lkZSwgZ2V0QWxpZ25tZW50LCBldmFsdWF0ZSwgZ2V0UGFkZGluZ09iamVjdCwgcmVjdFRvQ2xpZW50UmVjdCwgbWluLCBjbGFtcCwgcGxhY2VtZW50cywgZ2V0QWxpZ25tZW50U2lkZXMsIGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50LCBnZXRPcHBvc2l0ZVBsYWNlbWVudCwgZ2V0RXhwYW5kZWRQbGFjZW1lbnRzLCBnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzLCBzaWRlcywgbWF4LCBnZXRPcHBvc2l0ZUF4aXMgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMnO1xuZXhwb3J0IHsgcmVjdFRvQ2xpZW50UmVjdCB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscyc7XG5cbmZ1bmN0aW9uIGNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50KF9yZWYsIHBsYWNlbWVudCwgcnRsKSB7XG4gIGxldCB7XG4gICAgcmVmZXJlbmNlLFxuICAgIGZsb2F0aW5nXG4gIH0gPSBfcmVmO1xuICBjb25zdCBzaWRlQXhpcyA9IGdldFNpZGVBeGlzKHBsYWNlbWVudCk7XG4gIGNvbnN0IGFsaWdubWVudEF4aXMgPSBnZXRBbGlnbm1lbnRBeGlzKHBsYWNlbWVudCk7XG4gIGNvbnN0IGFsaWduTGVuZ3RoID0gZ2V0QXhpc0xlbmd0aChhbGlnbm1lbnRBeGlzKTtcbiAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgY29uc3QgaXNWZXJ0aWNhbCA9IHNpZGVBeGlzID09PSAneSc7XG4gIGNvbnN0IGNvbW1vblggPSByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCAvIDIgLSBmbG9hdGluZy53aWR0aCAvIDI7XG4gIGNvbnN0IGNvbW1vblkgPSByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHQgLyAyIC0gZmxvYXRpbmcuaGVpZ2h0IC8gMjtcbiAgY29uc3QgY29tbW9uQWxpZ24gPSByZWZlcmVuY2VbYWxpZ25MZW5ndGhdIC8gMiAtIGZsb2F0aW5nW2FsaWduTGVuZ3RoXSAvIDI7XG4gIGxldCBjb29yZHM7XG4gIHN3aXRjaCAoc2lkZSkge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55IC0gZmxvYXRpbmcuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCAtIGZsb2F0aW5nLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLngsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55XG4gICAgICB9O1xuICB9XG4gIHN3aXRjaCAoZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkpIHtcbiAgICBjYXNlICdzdGFydCc6XG4gICAgICBjb29yZHNbYWxpZ25tZW50QXhpc10gLT0gY29tbW9uQWxpZ24gKiAocnRsICYmIGlzVmVydGljYWwgPyAtMSA6IDEpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZW5kJzpcbiAgICAgIGNvb3Jkc1thbGlnbm1lbnRBeGlzXSArPSBjb21tb25BbGlnbiAqIChydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMSk7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gY29vcmRzO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyB0aGF0IHdpbGwgcGxhY2UgdGhlIGZsb2F0aW5nIGVsZW1lbnRcbiAqIG5leHQgdG8gYSByZWZlcmVuY2UgZWxlbWVudCB3aGVuIGl0IGlzIGdpdmVuIGEgY2VydGFpbiBwb3NpdGlvbmluZyBzdHJhdGVneS5cbiAqXG4gKiBUaGlzIGV4cG9ydCBkb2VzIG5vdCBoYXZlIGFueSBgcGxhdGZvcm1gIGludGVyZmFjZSBsb2dpYy4gWW91IHdpbGwgbmVlZCB0b1xuICogd3JpdGUgb25lIGZvciB0aGUgcGxhdGZvcm0geW91IGFyZSB1c2luZyBGbG9hdGluZyBVSSB3aXRoLlxuICovXG5jb25zdCBjb21wdXRlUG9zaXRpb24gPSBhc3luYyAocmVmZXJlbmNlLCBmbG9hdGluZywgY29uZmlnKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBwbGFjZW1lbnQgPSAnYm90dG9tJyxcbiAgICBzdHJhdGVneSA9ICdhYnNvbHV0ZScsXG4gICAgbWlkZGxld2FyZSA9IFtdLFxuICAgIHBsYXRmb3JtXG4gIH0gPSBjb25maWc7XG4gIGNvbnN0IHZhbGlkTWlkZGxld2FyZSA9IG1pZGRsZXdhcmUuZmlsdGVyKEJvb2xlYW4pO1xuICBjb25zdCBydGwgPSBhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGZsb2F0aW5nKSk7XG4gIGxldCByZWN0cyA9IGF3YWl0IHBsYXRmb3JtLmdldEVsZW1lbnRSZWN0cyh7XG4gICAgcmVmZXJlbmNlLFxuICAgIGZsb2F0aW5nLFxuICAgIHN0cmF0ZWd5XG4gIH0pO1xuICBsZXQge1xuICAgIHgsXG4gICAgeVxuICB9ID0gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQocmVjdHMsIHBsYWNlbWVudCwgcnRsKTtcbiAgbGV0IHN0YXRlZnVsUGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICBsZXQgbWlkZGxld2FyZURhdGEgPSB7fTtcbiAgbGV0IHJlc2V0Q291bnQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbGlkTWlkZGxld2FyZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICBmblxuICAgIH0gPSB2YWxpZE1pZGRsZXdhcmVbaV07XG4gICAgY29uc3Qge1xuICAgICAgeDogbmV4dFgsXG4gICAgICB5OiBuZXh0WSxcbiAgICAgIGRhdGEsXG4gICAgICByZXNldFxuICAgIH0gPSBhd2FpdCBmbih7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGluaXRpYWxQbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIHBsYWNlbWVudDogc3RhdGVmdWxQbGFjZW1lbnQsXG4gICAgICBzdHJhdGVneSxcbiAgICAgIG1pZGRsZXdhcmVEYXRhLFxuICAgICAgcmVjdHMsXG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHJlZmVyZW5jZSxcbiAgICAgICAgZmxvYXRpbmdcbiAgICAgIH1cbiAgICB9KTtcbiAgICB4ID0gbmV4dFggIT0gbnVsbCA/IG5leHRYIDogeDtcbiAgICB5ID0gbmV4dFkgIT0gbnVsbCA/IG5leHRZIDogeTtcbiAgICBtaWRkbGV3YXJlRGF0YSA9IHtcbiAgICAgIC4uLm1pZGRsZXdhcmVEYXRhLFxuICAgICAgW25hbWVdOiB7XG4gICAgICAgIC4uLm1pZGRsZXdhcmVEYXRhW25hbWVdLFxuICAgICAgICAuLi5kYXRhXG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAocmVzZXQgJiYgcmVzZXRDb3VudCA8PSA1MCkge1xuICAgICAgcmVzZXRDb3VudCsrO1xuICAgICAgaWYgKHR5cGVvZiByZXNldCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHJlc2V0LnBsYWNlbWVudCkge1xuICAgICAgICAgIHN0YXRlZnVsUGxhY2VtZW50ID0gcmVzZXQucGxhY2VtZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNldC5yZWN0cykge1xuICAgICAgICAgIHJlY3RzID0gcmVzZXQucmVjdHMgPT09IHRydWUgPyBhd2FpdCBwbGF0Zm9ybS5nZXRFbGVtZW50UmVjdHMoe1xuICAgICAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICAgICAgZmxvYXRpbmcsXG4gICAgICAgICAgICBzdHJhdGVneVxuICAgICAgICAgIH0pIDogcmVzZXQucmVjdHM7XG4gICAgICAgIH1cbiAgICAgICAgKHtcbiAgICAgICAgICB4LFxuICAgICAgICAgIHlcbiAgICAgICAgfSA9IGNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50KHJlY3RzLCBzdGF0ZWZ1bFBsYWNlbWVudCwgcnRsKSk7XG4gICAgICB9XG4gICAgICBpID0gLTE7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHksXG4gICAgcGxhY2VtZW50OiBzdGF0ZWZ1bFBsYWNlbWVudCxcbiAgICBzdHJhdGVneSxcbiAgICBtaWRkbGV3YXJlRGF0YVxuICB9O1xufTtcblxuLyoqXG4gKiBSZXNvbHZlcyB3aXRoIGFuIG9iamVjdCBvZiBvdmVyZmxvdyBzaWRlIG9mZnNldHMgdGhhdCBkZXRlcm1pbmUgaG93IG11Y2ggdGhlXG4gKiBlbGVtZW50IGlzIG92ZXJmbG93aW5nIGEgZ2l2ZW4gY2xpcHBpbmcgYm91bmRhcnkgb24gZWFjaCBzaWRlLlxuICogLSBwb3NpdGl2ZSA9IG92ZXJmbG93aW5nIHRoZSBib3VuZGFyeSBieSB0aGF0IG51bWJlciBvZiBwaXhlbHNcbiAqIC0gbmVnYXRpdmUgPSBob3cgbWFueSBwaXhlbHMgbGVmdCBiZWZvcmUgaXQgd2lsbCBvdmVyZmxvd1xuICogLSAwID0gbGllcyBmbHVzaCB3aXRoIHRoZSBib3VuZGFyeVxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2RldGVjdE92ZXJmbG93XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRldGVjdE92ZXJmbG93KHN0YXRlLCBvcHRpb25zKSB7XG4gIHZhciBfYXdhaXQkcGxhdGZvcm0kaXNFbGU7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIHgsXG4gICAgeSxcbiAgICBwbGF0Zm9ybSxcbiAgICByZWN0cyxcbiAgICBlbGVtZW50cyxcbiAgICBzdHJhdGVneVxuICB9ID0gc3RhdGU7XG4gIGNvbnN0IHtcbiAgICBib3VuZGFyeSA9ICdjbGlwcGluZ0FuY2VzdG9ycycsXG4gICAgcm9vdEJvdW5kYXJ5ID0gJ3ZpZXdwb3J0JyxcbiAgICBlbGVtZW50Q29udGV4dCA9ICdmbG9hdGluZycsXG4gICAgYWx0Qm91bmRhcnkgPSBmYWxzZSxcbiAgICBwYWRkaW5nID0gMFxuICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICBjb25zdCBwYWRkaW5nT2JqZWN0ID0gZ2V0UGFkZGluZ09iamVjdChwYWRkaW5nKTtcbiAgY29uc3QgYWx0Q29udGV4dCA9IGVsZW1lbnRDb250ZXh0ID09PSAnZmxvYXRpbmcnID8gJ3JlZmVyZW5jZScgOiAnZmxvYXRpbmcnO1xuICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbYWx0Qm91bmRhcnkgPyBhbHRDb250ZXh0IDogZWxlbWVudENvbnRleHRdO1xuICBjb25zdCBjbGlwcGluZ0NsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KGF3YWl0IHBsYXRmb3JtLmdldENsaXBwaW5nUmVjdCh7XG4gICAgZWxlbWVudDogKChfYXdhaXQkcGxhdGZvcm0kaXNFbGUgPSBhd2FpdCAocGxhdGZvcm0uaXNFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc0VsZW1lbnQoZWxlbWVudCkpKSAhPSBudWxsID8gX2F3YWl0JHBsYXRmb3JtJGlzRWxlIDogdHJ1ZSkgPyBlbGVtZW50IDogZWxlbWVudC5jb250ZXh0RWxlbWVudCB8fCAoYXdhaXQgKHBsYXRmb3JtLmdldERvY3VtZW50RWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnRzLmZsb2F0aW5nKSkpLFxuICAgIGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeSxcbiAgICBzdHJhdGVneVxuICB9KSk7XG4gIGNvbnN0IHJlY3QgPSBlbGVtZW50Q29udGV4dCA9PT0gJ2Zsb2F0aW5nJyA/IHtcbiAgICAuLi5yZWN0cy5mbG9hdGluZyxcbiAgICB4LFxuICAgIHlcbiAgfSA6IHJlY3RzLnJlZmVyZW5jZTtcbiAgY29uc3Qgb2Zmc2V0UGFyZW50ID0gYXdhaXQgKHBsYXRmb3JtLmdldE9mZnNldFBhcmVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnRzLmZsb2F0aW5nKSk7XG4gIGNvbnN0IG9mZnNldFNjYWxlID0gKGF3YWl0IChwbGF0Zm9ybS5pc0VsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzRWxlbWVudChvZmZzZXRQYXJlbnQpKSkgPyAoYXdhaXQgKHBsYXRmb3JtLmdldFNjYWxlID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRTY2FsZShvZmZzZXRQYXJlbnQpKSkgfHwge1xuICAgIHg6IDEsXG4gICAgeTogMVxuICB9IDoge1xuICAgIHg6IDEsXG4gICAgeTogMVxuICB9O1xuICBjb25zdCBlbGVtZW50Q2xpZW50UmVjdCA9IHJlY3RUb0NsaWVudFJlY3QocGxhdGZvcm0uY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3QgPyBhd2FpdCBwbGF0Zm9ybS5jb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCh7XG4gICAgcmVjdCxcbiAgICBvZmZzZXRQYXJlbnQsXG4gICAgc3RyYXRlZ3lcbiAgfSkgOiByZWN0KTtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IChjbGlwcGluZ0NsaWVudFJlY3QudG9wIC0gZWxlbWVudENsaWVudFJlY3QudG9wICsgcGFkZGluZ09iamVjdC50b3ApIC8gb2Zmc2V0U2NhbGUueSxcbiAgICBib3R0b206IChlbGVtZW50Q2xpZW50UmVjdC5ib3R0b20gLSBjbGlwcGluZ0NsaWVudFJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20pIC8gb2Zmc2V0U2NhbGUueSxcbiAgICBsZWZ0OiAoY2xpcHBpbmdDbGllbnRSZWN0LmxlZnQgLSBlbGVtZW50Q2xpZW50UmVjdC5sZWZ0ICsgcGFkZGluZ09iamVjdC5sZWZ0KSAvIG9mZnNldFNjYWxlLngsXG4gICAgcmlnaHQ6IChlbGVtZW50Q2xpZW50UmVjdC5yaWdodCAtIGNsaXBwaW5nQ2xpZW50UmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHQpIC8gb2Zmc2V0U2NhbGUueFxuICB9O1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gcG9zaXRpb24gYW4gaW5uZXIgZWxlbWVudCBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBzbyB0aGF0IGl0XG4gKiBhcHBlYXJzIGNlbnRlcmVkIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hcnJvd1xuICovXG5jb25zdCBhcnJvdyA9IG9wdGlvbnMgPT4gKHtcbiAgbmFtZTogJ2Fycm93JyxcbiAgb3B0aW9ucyxcbiAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHBsYWNlbWVudCxcbiAgICAgIHJlY3RzLFxuICAgICAgcGxhdGZvcm0sXG4gICAgICBlbGVtZW50cyxcbiAgICAgIG1pZGRsZXdhcmVEYXRhXG4gICAgfSA9IHN0YXRlO1xuICAgIC8vIFNpbmNlIGBlbGVtZW50YCBpcyByZXF1aXJlZCwgd2UgZG9uJ3QgUGFydGlhbDw+IHRoZSB0eXBlLlxuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnQsXG4gICAgICBwYWRkaW5nID0gMFxuICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSkgfHwge307XG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjb25zdCBwYWRkaW5nT2JqZWN0ID0gZ2V0UGFkZGluZ09iamVjdChwYWRkaW5nKTtcbiAgICBjb25zdCBjb29yZHMgPSB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH07XG4gICAgY29uc3QgYXhpcyA9IGdldEFsaWdubWVudEF4aXMocGxhY2VtZW50KTtcbiAgICBjb25zdCBsZW5ndGggPSBnZXRBeGlzTGVuZ3RoKGF4aXMpO1xuICAgIGNvbnN0IGFycm93RGltZW5zaW9ucyA9IGF3YWl0IHBsYXRmb3JtLmdldERpbWVuc2lvbnMoZWxlbWVudCk7XG4gICAgY29uc3QgaXNZQXhpcyA9IGF4aXMgPT09ICd5JztcbiAgICBjb25zdCBtaW5Qcm9wID0gaXNZQXhpcyA/ICd0b3AnIDogJ2xlZnQnO1xuICAgIGNvbnN0IG1heFByb3AgPSBpc1lBeGlzID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICAgIGNvbnN0IGNsaWVudFByb3AgPSBpc1lBeGlzID8gJ2NsaWVudEhlaWdodCcgOiAnY2xpZW50V2lkdGgnO1xuICAgIGNvbnN0IGVuZERpZmYgPSByZWN0cy5yZWZlcmVuY2VbbGVuZ3RoXSArIHJlY3RzLnJlZmVyZW5jZVtheGlzXSAtIGNvb3Jkc1theGlzXSAtIHJlY3RzLmZsb2F0aW5nW2xlbmd0aF07XG4gICAgY29uc3Qgc3RhcnREaWZmID0gY29vcmRzW2F4aXNdIC0gcmVjdHMucmVmZXJlbmNlW2F4aXNdO1xuICAgIGNvbnN0IGFycm93T2Zmc2V0UGFyZW50ID0gYXdhaXQgKHBsYXRmb3JtLmdldE9mZnNldFBhcmVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpKTtcbiAgICBsZXQgY2xpZW50U2l6ZSA9IGFycm93T2Zmc2V0UGFyZW50ID8gYXJyb3dPZmZzZXRQYXJlbnRbY2xpZW50UHJvcF0gOiAwO1xuXG4gICAgLy8gRE9NIHBsYXRmb3JtIGNhbiByZXR1cm4gYHdpbmRvd2AgYXMgdGhlIGBvZmZzZXRQYXJlbnRgLlxuICAgIGlmICghY2xpZW50U2l6ZSB8fCAhKGF3YWl0IChwbGF0Zm9ybS5pc0VsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzRWxlbWVudChhcnJvd09mZnNldFBhcmVudCkpKSkge1xuICAgICAgY2xpZW50U2l6ZSA9IGVsZW1lbnRzLmZsb2F0aW5nW2NsaWVudFByb3BdIHx8IHJlY3RzLmZsb2F0aW5nW2xlbmd0aF07XG4gICAgfVxuICAgIGNvbnN0IGNlbnRlclRvUmVmZXJlbmNlID0gZW5kRGlmZiAvIDIgLSBzdGFydERpZmYgLyAyO1xuXG4gICAgLy8gSWYgdGhlIHBhZGRpbmcgaXMgbGFyZ2UgZW5vdWdoIHRoYXQgaXQgY2F1c2VzIHRoZSBhcnJvdyB0byBubyBsb25nZXIgYmVcbiAgICAvLyBjZW50ZXJlZCwgbW9kaWZ5IHRoZSBwYWRkaW5nIHNvIHRoYXQgaXQgaXMgY2VudGVyZWQuXG4gICAgY29uc3QgbGFyZ2VzdFBvc3NpYmxlUGFkZGluZyA9IGNsaWVudFNpemUgLyAyIC0gYXJyb3dEaW1lbnNpb25zW2xlbmd0aF0gLyAyIC0gMTtcbiAgICBjb25zdCBtaW5QYWRkaW5nID0gbWluKHBhZGRpbmdPYmplY3RbbWluUHJvcF0sIGxhcmdlc3RQb3NzaWJsZVBhZGRpbmcpO1xuICAgIGNvbnN0IG1heFBhZGRpbmcgPSBtaW4ocGFkZGluZ09iamVjdFttYXhQcm9wXSwgbGFyZ2VzdFBvc3NpYmxlUGFkZGluZyk7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlIGFycm93IGRvZXNuJ3Qgb3ZlcmZsb3cgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaWYgdGhlIGNlbnRlclxuICAgIC8vIHBvaW50IGlzIG91dHNpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQncyBib3VuZHMuXG4gICAgY29uc3QgbWluJDEgPSBtaW5QYWRkaW5nO1xuICAgIGNvbnN0IG1heCA9IGNsaWVudFNpemUgLSBhcnJvd0RpbWVuc2lvbnNbbGVuZ3RoXSAtIG1heFBhZGRpbmc7XG4gICAgY29uc3QgY2VudGVyID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd0RpbWVuc2lvbnNbbGVuZ3RoXSAvIDIgKyBjZW50ZXJUb1JlZmVyZW5jZTtcbiAgICBjb25zdCBvZmZzZXQgPSBjbGFtcChtaW4kMSwgY2VudGVyLCBtYXgpO1xuXG4gICAgLy8gSWYgdGhlIHJlZmVyZW5jZSBpcyBzbWFsbCBlbm91Z2ggdGhhdCB0aGUgYXJyb3cncyBwYWRkaW5nIGNhdXNlcyBpdCB0b1xuICAgIC8vIHRvIHBvaW50IHRvIG5vdGhpbmcgZm9yIGFuIGFsaWduZWQgcGxhY2VtZW50LCBhZGp1c3QgdGhlIG9mZnNldCBvZiB0aGVcbiAgICAvLyBmbG9hdGluZyBlbGVtZW50IGl0c2VsZi4gVG8gZW5zdXJlIGBzaGlmdCgpYCBjb250aW51ZXMgdG8gdGFrZSBhY3Rpb24sXG4gICAgLy8gYSBzaW5nbGUgcmVzZXQgaXMgcGVyZm9ybWVkIHdoZW4gdGhpcyBpcyB0cnVlLlxuICAgIGNvbnN0IHNob3VsZEFkZE9mZnNldCA9ICFtaWRkbGV3YXJlRGF0YS5hcnJvdyAmJiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSAhPSBudWxsICYmIGNlbnRlciAhPSBvZmZzZXQgJiYgcmVjdHMucmVmZXJlbmNlW2xlbmd0aF0gLyAyIC0gKGNlbnRlciA8IG1pbiQxID8gbWluUGFkZGluZyA6IG1heFBhZGRpbmcpIC0gYXJyb3dEaW1lbnNpb25zW2xlbmd0aF0gLyAyIDwgMDtcbiAgICBjb25zdCBhbGlnbm1lbnRPZmZzZXQgPSBzaG91bGRBZGRPZmZzZXQgPyBjZW50ZXIgPCBtaW4kMSA/IGNlbnRlciAtIG1pbiQxIDogY2VudGVyIC0gbWF4IDogMDtcbiAgICByZXR1cm4ge1xuICAgICAgW2F4aXNdOiBjb29yZHNbYXhpc10gKyBhbGlnbm1lbnRPZmZzZXQsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIFtheGlzXTogb2Zmc2V0LFxuICAgICAgICBjZW50ZXJPZmZzZXQ6IGNlbnRlciAtIG9mZnNldCAtIGFsaWdubWVudE9mZnNldCxcbiAgICAgICAgLi4uKHNob3VsZEFkZE9mZnNldCAmJiB7XG4gICAgICAgICAgYWxpZ25tZW50T2Zmc2V0XG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgcmVzZXQ6IHNob3VsZEFkZE9mZnNldFxuICAgIH07XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBnZXRQbGFjZW1lbnRMaXN0KGFsaWdubWVudCwgYXV0b0FsaWdubWVudCwgYWxsb3dlZFBsYWNlbWVudHMpIHtcbiAgY29uc3QgYWxsb3dlZFBsYWNlbWVudHNTb3J0ZWRCeUFsaWdubWVudCA9IGFsaWdubWVudCA/IFsuLi5hbGxvd2VkUGxhY2VtZW50cy5maWx0ZXIocGxhY2VtZW50ID0+IGdldEFsaWdubWVudChwbGFjZW1lbnQpID09PSBhbGlnbm1lbnQpLCAuLi5hbGxvd2VkUGxhY2VtZW50cy5maWx0ZXIocGxhY2VtZW50ID0+IGdldEFsaWdubWVudChwbGFjZW1lbnQpICE9PSBhbGlnbm1lbnQpXSA6IGFsbG93ZWRQbGFjZW1lbnRzLmZpbHRlcihwbGFjZW1lbnQgPT4gZ2V0U2lkZShwbGFjZW1lbnQpID09PSBwbGFjZW1lbnQpO1xuICByZXR1cm4gYWxsb3dlZFBsYWNlbWVudHNTb3J0ZWRCeUFsaWdubWVudC5maWx0ZXIocGxhY2VtZW50ID0+IHtcbiAgICBpZiAoYWxpZ25tZW50KSB7XG4gICAgICByZXR1cm4gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgPT09IGFsaWdubWVudCB8fCAoYXV0b0FsaWdubWVudCA/IGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KHBsYWNlbWVudCkgIT09IHBsYWNlbWVudCA6IGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufVxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgY2hvb3NpbmcgdGhlIHBsYWNlbWVudFxuICogdGhhdCBoYXMgdGhlIG1vc3Qgc3BhY2UgYXZhaWxhYmxlIGF1dG9tYXRpY2FsbHksIHdpdGhvdXQgbmVlZGluZyB0byBzcGVjaWZ5IGFcbiAqIHByZWZlcnJlZCBwbGFjZW1lbnQuIEFsdGVybmF0aXZlIHRvIGBmbGlwYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hdXRvUGxhY2VtZW50XG4gKi9cbmNvbnN0IGF1dG9QbGFjZW1lbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2F1dG9QbGFjZW1lbnQnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkYXV0b1AsIF9taWRkbGV3YXJlRGF0YSRhdXRvUDIsIF9wbGFjZW1lbnRzVGhhdEZpdE9uRTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhLFxuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBlbGVtZW50c1xuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjcm9zc0F4aXMgPSBmYWxzZSxcbiAgICAgICAgYWxpZ25tZW50LFxuICAgICAgICBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMsXG4gICAgICAgIGF1dG9BbGlnbm1lbnQgPSB0cnVlLFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBwbGFjZW1lbnRzJDEgPSBhbGlnbm1lbnQgIT09IHVuZGVmaW5lZCB8fCBhbGxvd2VkUGxhY2VtZW50cyA9PT0gcGxhY2VtZW50cyA/IGdldFBsYWNlbWVudExpc3QoYWxpZ25tZW50IHx8IG51bGwsIGF1dG9BbGlnbm1lbnQsIGFsbG93ZWRQbGFjZW1lbnRzKSA6IGFsbG93ZWRQbGFjZW1lbnRzO1xuICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9ICgoX21pZGRsZXdhcmVEYXRhJGF1dG9QID0gbWlkZGxld2FyZURhdGEuYXV0b1BsYWNlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRhdXRvUC5pbmRleCkgfHwgMDtcbiAgICAgIGNvbnN0IGN1cnJlbnRQbGFjZW1lbnQgPSBwbGFjZW1lbnRzJDFbY3VycmVudEluZGV4XTtcbiAgICAgIGlmIChjdXJyZW50UGxhY2VtZW50ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgY29uc3QgYWxpZ25tZW50U2lkZXMgPSBnZXRBbGlnbm1lbnRTaWRlcyhjdXJyZW50UGxhY2VtZW50LCByZWN0cywgYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpKTtcblxuICAgICAgLy8gTWFrZSBgY29tcHV0ZUNvb3Jkc2Agc3RhcnQgZnJvbSB0aGUgcmlnaHQgcGxhY2UuXG4gICAgICBpZiAocGxhY2VtZW50ICE9PSBjdXJyZW50UGxhY2VtZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50cyQxWzBdXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVudE92ZXJmbG93cyA9IFtvdmVyZmxvd1tnZXRTaWRlKGN1cnJlbnRQbGFjZW1lbnQpXSwgb3ZlcmZsb3dbYWxpZ25tZW50U2lkZXNbMF1dLCBvdmVyZmxvd1thbGlnbm1lbnRTaWRlc1sxXV1dO1xuICAgICAgY29uc3QgYWxsT3ZlcmZsb3dzID0gWy4uLigoKF9taWRkbGV3YXJlRGF0YSRhdXRvUDIgPSBtaWRkbGV3YXJlRGF0YS5hdXRvUGxhY2VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGF1dG9QMi5vdmVyZmxvd3MpIHx8IFtdKSwge1xuICAgICAgICBwbGFjZW1lbnQ6IGN1cnJlbnRQbGFjZW1lbnQsXG4gICAgICAgIG92ZXJmbG93czogY3VycmVudE92ZXJmbG93c1xuICAgICAgfV07XG4gICAgICBjb25zdCBuZXh0UGxhY2VtZW50ID0gcGxhY2VtZW50cyQxW2N1cnJlbnRJbmRleCArIDFdO1xuXG4gICAgICAvLyBUaGVyZSBhcmUgbW9yZSBwbGFjZW1lbnRzIHRvIGNoZWNrLlxuICAgICAgaWYgKG5leHRQbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBpbmRleDogY3VycmVudEluZGV4ICsgMSxcbiAgICAgICAgICAgIG92ZXJmbG93czogYWxsT3ZlcmZsb3dzXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcGxhY2VtZW50OiBuZXh0UGxhY2VtZW50XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcGxhY2VtZW50c1NvcnRlZEJ5TW9zdFNwYWNlID0gYWxsT3ZlcmZsb3dzLm1hcChkID0+IHtcbiAgICAgICAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KGQucGxhY2VtZW50KTtcbiAgICAgICAgcmV0dXJuIFtkLnBsYWNlbWVudCwgYWxpZ25tZW50ICYmIGNyb3NzQXhpcyA/XG4gICAgICAgIC8vIENoZWNrIGFsb25nIHRoZSBtYWluQXhpcyBhbmQgbWFpbiBjcm9zc0F4aXMgc2lkZS5cbiAgICAgICAgZC5vdmVyZmxvd3Muc2xpY2UoMCwgMikucmVkdWNlKChhY2MsIHYpID0+IGFjYyArIHYsIDApIDpcbiAgICAgICAgLy8gQ2hlY2sgb25seSB0aGUgbWFpbkF4aXMuXG4gICAgICAgIGQub3ZlcmZsb3dzWzBdLCBkLm92ZXJmbG93c107XG4gICAgICB9KS5zb3J0KChhLCBiKSA9PiBhWzFdIC0gYlsxXSk7XG4gICAgICBjb25zdCBwbGFjZW1lbnRzVGhhdEZpdE9uRWFjaFNpZGUgPSBwbGFjZW1lbnRzU29ydGVkQnlNb3N0U3BhY2UuZmlsdGVyKGQgPT4gZFsyXS5zbGljZSgwLFxuICAgICAgLy8gQWxpZ25lZCBwbGFjZW1lbnRzIHNob3VsZCBub3QgY2hlY2sgdGhlaXIgb3Bwb3NpdGUgY3Jvc3NBeGlzXG4gICAgICAvLyBzaWRlLlxuICAgICAgZ2V0QWxpZ25tZW50KGRbMF0pID8gMiA6IDMpLmV2ZXJ5KHYgPT4gdiA8PSAwKSk7XG4gICAgICBjb25zdCByZXNldFBsYWNlbWVudCA9ICgoX3BsYWNlbWVudHNUaGF0Rml0T25FID0gcGxhY2VtZW50c1RoYXRGaXRPbkVhY2hTaWRlWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3BsYWNlbWVudHNUaGF0Rml0T25FWzBdKSB8fCBwbGFjZW1lbnRzU29ydGVkQnlNb3N0U3BhY2VbMF1bMF07XG4gICAgICBpZiAocmVzZXRQbGFjZW1lbnQgIT09IHBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGluZGV4OiBjdXJyZW50SW5kZXggKyAxLFxuICAgICAgICAgICAgb3ZlcmZsb3dzOiBhbGxPdmVyZmxvd3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IHJlc2V0UGxhY2VtZW50XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IGZsaXBwaW5nIHRoZSBgcGxhY2VtZW50YFxuICogaW4gb3JkZXIgdG8ga2VlcCBpdCBpbiB2aWV3IHdoZW4gdGhlIHByZWZlcnJlZCBwbGFjZW1lbnQocykgd2lsbCBvdmVyZmxvdyB0aGVcbiAqIGNsaXBwaW5nIGJvdW5kYXJ5LiBBbHRlcm5hdGl2ZSB0byBgYXV0b1BsYWNlbWVudGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvZmxpcFxuICovXG5jb25zdCBmbGlwID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdmbGlwJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJGFycm93LCBfbWlkZGxld2FyZURhdGEkZmxpcDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBtaWRkbGV3YXJlRGF0YSxcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIGluaXRpYWxQbGFjZW1lbnQsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBlbGVtZW50c1xuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9IHRydWUsXG4gICAgICAgIGNyb3NzQXhpczogY2hlY2tDcm9zc0F4aXMgPSB0cnVlLFxuICAgICAgICBmYWxsYmFja1BsYWNlbWVudHM6IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyxcbiAgICAgICAgZmFsbGJhY2tTdHJhdGVneSA9ICdiZXN0Rml0JyxcbiAgICAgICAgZmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiA9ICdub25lJyxcbiAgICAgICAgZmxpcEFsaWdubWVudCA9IHRydWUsXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcblxuICAgICAgLy8gSWYgYSByZXNldCBieSB0aGUgYXJyb3cgd2FzIGNhdXNlZCBkdWUgdG8gYW4gYWxpZ25tZW50IG9mZnNldCBiZWluZ1xuICAgICAgLy8gYWRkZWQsIHdlIHNob3VsZCBza2lwIGFueSBsb2dpYyBub3cgc2luY2UgYGZsaXAoKWAgaGFzIGFscmVhZHkgZG9uZSBpdHNcbiAgICAgIC8vIHdvcmsuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzI1NDkjaXNzdWVjb21tZW50LTE3MTk2MDE2NDNcbiAgICAgIGlmICgoX21pZGRsZXdhcmVEYXRhJGFycm93ID0gbWlkZGxld2FyZURhdGEuYXJyb3cpICE9IG51bGwgJiYgX21pZGRsZXdhcmVEYXRhJGFycm93LmFsaWdubWVudE9mZnNldCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICAgICAgY29uc3QgaXNCYXNlUGxhY2VtZW50ID0gZ2V0U2lkZShpbml0aWFsUGxhY2VtZW50KSA9PT0gaW5pdGlhbFBsYWNlbWVudDtcbiAgICAgIGNvbnN0IHJ0bCA9IGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrUGxhY2VtZW50cyA9IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyB8fCAoaXNCYXNlUGxhY2VtZW50IHx8ICFmbGlwQWxpZ25tZW50ID8gW2dldE9wcG9zaXRlUGxhY2VtZW50KGluaXRpYWxQbGFjZW1lbnQpXSA6IGdldEV4cGFuZGVkUGxhY2VtZW50cyhpbml0aWFsUGxhY2VtZW50KSk7XG4gICAgICBpZiAoIXNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyAmJiBmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uICE9PSAnbm9uZScpIHtcbiAgICAgICAgZmFsbGJhY2tQbGFjZW1lbnRzLnB1c2goLi4uZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cyhpbml0aWFsUGxhY2VtZW50LCBmbGlwQWxpZ25tZW50LCBmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uLCBydGwpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBsYWNlbWVudHMgPSBbaW5pdGlhbFBsYWNlbWVudCwgLi4uZmFsbGJhY2tQbGFjZW1lbnRzXTtcbiAgICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgICBjb25zdCBvdmVyZmxvd3MgPSBbXTtcbiAgICAgIGxldCBvdmVyZmxvd3NEYXRhID0gKChfbWlkZGxld2FyZURhdGEkZmxpcCA9IG1pZGRsZXdhcmVEYXRhLmZsaXApID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkZmxpcC5vdmVyZmxvd3MpIHx8IFtdO1xuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgb3ZlcmZsb3dzLnB1c2gob3ZlcmZsb3dbc2lkZV0pO1xuICAgICAgfVxuICAgICAgaWYgKGNoZWNrQ3Jvc3NBeGlzKSB7XG4gICAgICAgIGNvbnN0IHNpZGVzID0gZ2V0QWxpZ25tZW50U2lkZXMocGxhY2VtZW50LCByZWN0cywgcnRsKTtcbiAgICAgICAgb3ZlcmZsb3dzLnB1c2gob3ZlcmZsb3dbc2lkZXNbMF1dLCBvdmVyZmxvd1tzaWRlc1sxXV0pO1xuICAgICAgfVxuICAgICAgb3ZlcmZsb3dzRGF0YSA9IFsuLi5vdmVyZmxvd3NEYXRhLCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgb3ZlcmZsb3dzXG4gICAgICB9XTtcblxuICAgICAgLy8gT25lIG9yIG1vcmUgc2lkZXMgaXMgb3ZlcmZsb3dpbmcuXG4gICAgICBpZiAoIW92ZXJmbG93cy5ldmVyeShzaWRlID0+IHNpZGUgPD0gMCkpIHtcbiAgICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRmbGlwMiwgX292ZXJmbG93c0RhdGEkZmlsdGVyO1xuICAgICAgICBjb25zdCBuZXh0SW5kZXggPSAoKChfbWlkZGxld2FyZURhdGEkZmxpcDIgPSBtaWRkbGV3YXJlRGF0YS5mbGlwKSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGZsaXAyLmluZGV4KSB8fCAwKSArIDE7XG4gICAgICAgIGNvbnN0IG5leHRQbGFjZW1lbnQgPSBwbGFjZW1lbnRzW25leHRJbmRleF07XG4gICAgICAgIGlmIChuZXh0UGxhY2VtZW50KSB7XG4gICAgICAgICAgLy8gVHJ5IG5leHQgcGxhY2VtZW50IGFuZCByZS1ydW4gdGhlIGxpZmVjeWNsZS5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBpbmRleDogbmV4dEluZGV4LFxuICAgICAgICAgICAgICBvdmVyZmxvd3M6IG92ZXJmbG93c0RhdGFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgICBwbGFjZW1lbnQ6IG5leHRQbGFjZW1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyc3QsIGZpbmQgdGhlIGNhbmRpZGF0ZXMgdGhhdCBmaXQgb24gdGhlIG1haW5BeGlzIHNpZGUgb2Ygb3ZlcmZsb3csXG4gICAgICAgIC8vIHRoZW4gZmluZCB0aGUgcGxhY2VtZW50IHRoYXQgZml0cyB0aGUgYmVzdCBvbiB0aGUgbWFpbiBjcm9zc0F4aXMgc2lkZS5cbiAgICAgICAgbGV0IHJlc2V0UGxhY2VtZW50ID0gKF9vdmVyZmxvd3NEYXRhJGZpbHRlciA9IG92ZXJmbG93c0RhdGEuZmlsdGVyKGQgPT4gZC5vdmVyZmxvd3NbMF0gPD0gMCkuc29ydCgoYSwgYikgPT4gYS5vdmVyZmxvd3NbMV0gLSBiLm92ZXJmbG93c1sxXSlbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIucGxhY2VtZW50O1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSBmYWxsYmFjay5cbiAgICAgICAgaWYgKCFyZXNldFBsYWNlbWVudCkge1xuICAgICAgICAgIHN3aXRjaCAoZmFsbGJhY2tTdHJhdGVneSkge1xuICAgICAgICAgICAgY2FzZSAnYmVzdEZpdCc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgX292ZXJmbG93c0RhdGEkbWFwJHNvO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlbWVudCA9IChfb3ZlcmZsb3dzRGF0YSRtYXAkc28gPSBvdmVyZmxvd3NEYXRhLm1hcChkID0+IFtkLnBsYWNlbWVudCwgZC5vdmVyZmxvd3MuZmlsdGVyKG92ZXJmbG93ID0+IG92ZXJmbG93ID4gMCkucmVkdWNlKChhY2MsIG92ZXJmbG93KSA9PiBhY2MgKyBvdmVyZmxvdywgMCldKS5zb3J0KChhLCBiKSA9PiBhWzFdIC0gYlsxXSlbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfb3ZlcmZsb3dzRGF0YSRtYXAkc29bMF07XG4gICAgICAgICAgICAgICAgaWYgKHBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgICAgcmVzZXRQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdpbml0aWFsUGxhY2VtZW50JzpcbiAgICAgICAgICAgICAgcmVzZXRQbGFjZW1lbnQgPSBpbml0aWFsUGxhY2VtZW50O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBsYWNlbWVudCAhPT0gcmVzZXRQbGFjZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgICAgcGxhY2VtZW50OiByZXNldFBsYWNlbWVudFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogb3ZlcmZsb3cudG9wIC0gcmVjdC5oZWlnaHQsXG4gICAgcmlnaHQ6IG92ZXJmbG93LnJpZ2h0IC0gcmVjdC53aWR0aCxcbiAgICBib3R0b206IG92ZXJmbG93LmJvdHRvbSAtIHJlY3QuaGVpZ2h0LFxuICAgIGxlZnQ6IG92ZXJmbG93LmxlZnQgLSByZWN0LndpZHRoXG4gIH07XG59XG5mdW5jdGlvbiBpc0FueVNpZGVGdWxseUNsaXBwZWQob3ZlcmZsb3cpIHtcbiAgcmV0dXJuIHNpZGVzLnNvbWUoc2lkZSA9PiBvdmVyZmxvd1tzaWRlXSA+PSAwKTtcbn1cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBoaWRlIHRoZSBmbG9hdGluZyBlbGVtZW50IGluIGFwcGxpY2FibGUgc2l0dWF0aW9ucywgc3VjaCBhc1xuICogd2hlbiBpdCBpcyBub3QgaW4gdGhlIHNhbWUgY2xpcHBpbmcgY29udGV4dCBhcyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaGlkZVxuICovXG5jb25zdCBoaWRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdoaWRlJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlY3RzXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0cmF0ZWd5ID0gJ3JlZmVyZW5jZUhpZGRlbicsXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIHN3aXRjaCAoc3RyYXRlZ3kpIHtcbiAgICAgICAgY2FzZSAncmVmZXJlbmNlSGlkZGVuJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICAgICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9ucyxcbiAgICAgICAgICAgICAgZWxlbWVudENvbnRleHQ6ICdyZWZlcmVuY2UnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdHMucmVmZXJlbmNlKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VIaWRkZW5PZmZzZXRzOiBvZmZzZXRzLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUhpZGRlbjogaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG9mZnNldHMpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdlc2NhcGVkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICAgICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9ucyxcbiAgICAgICAgICAgICAgYWx0Qm91bmRhcnk6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0cy5mbG9hdGluZyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgZXNjYXBlZE9mZnNldHM6IG9mZnNldHMsXG4gICAgICAgICAgICAgICAgZXNjYXBlZDogaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG9mZnNldHMpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufTtcblxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdSZWN0KHJlY3RzKSB7XG4gIGNvbnN0IG1pblggPSBtaW4oLi4ucmVjdHMubWFwKHJlY3QgPT4gcmVjdC5sZWZ0KSk7XG4gIGNvbnN0IG1pblkgPSBtaW4oLi4ucmVjdHMubWFwKHJlY3QgPT4gcmVjdC50b3ApKTtcbiAgY29uc3QgbWF4WCA9IG1heCguLi5yZWN0cy5tYXAocmVjdCA9PiByZWN0LnJpZ2h0KSk7XG4gIGNvbnN0IG1heFkgPSBtYXgoLi4ucmVjdHMubWFwKHJlY3QgPT4gcmVjdC5ib3R0b20pKTtcbiAgcmV0dXJuIHtcbiAgICB4OiBtaW5YLFxuICAgIHk6IG1pblksXG4gICAgd2lkdGg6IG1heFggLSBtaW5YLFxuICAgIGhlaWdodDogbWF4WSAtIG1pbllcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFJlY3RzQnlMaW5lKHJlY3RzKSB7XG4gIGNvbnN0IHNvcnRlZFJlY3RzID0gcmVjdHMuc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBhLnkgLSBiLnkpO1xuICBjb25zdCBncm91cHMgPSBbXTtcbiAgbGV0IHByZXZSZWN0ID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3J0ZWRSZWN0cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHJlY3QgPSBzb3J0ZWRSZWN0c1tpXTtcbiAgICBpZiAoIXByZXZSZWN0IHx8IHJlY3QueSAtIHByZXZSZWN0LnkgPiBwcmV2UmVjdC5oZWlnaHQgLyAyKSB7XG4gICAgICBncm91cHMucHVzaChbcmVjdF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cHNbZ3JvdXBzLmxlbmd0aCAtIDFdLnB1c2gocmVjdCk7XG4gICAgfVxuICAgIHByZXZSZWN0ID0gcmVjdDtcbiAgfVxuICByZXR1cm4gZ3JvdXBzLm1hcChyZWN0ID0+IHJlY3RUb0NsaWVudFJlY3QoZ2V0Qm91bmRpbmdSZWN0KHJlY3QpKSk7XG59XG4vKipcbiAqIFByb3ZpZGVzIGltcHJvdmVkIHBvc2l0aW9uaW5nIGZvciBpbmxpbmUgcmVmZXJlbmNlIGVsZW1lbnRzIHRoYXQgY2FuIHNwYW5cbiAqIG92ZXIgbXVsdGlwbGUgbGluZXMsIHN1Y2ggYXMgaHlwZXJsaW5rcyBvciByYW5nZSBzZWxlY3Rpb25zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2lubGluZVxuICovXG5jb25zdCBpbmxpbmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2lubGluZScsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIGVsZW1lbnRzLFxuICAgICAgICByZWN0cyxcbiAgICAgICAgcGxhdGZvcm0sXG4gICAgICAgIHN0cmF0ZWd5XG4gICAgICB9ID0gc3RhdGU7XG4gICAgICAvLyBBIE1vdXNlRXZlbnQncyBjbGllbnR7WCxZfSBjb29yZHMgY2FuIGJlIHVwIHRvIDIgcGl4ZWxzIG9mZiBhXG4gICAgICAvLyBDbGllbnRSZWN0J3MgYm91bmRzLCBkZXNwaXRlIHRoZSBldmVudCBsaXN0ZW5lciBiZWluZyB0cmlnZ2VyZWQuIEFcbiAgICAgIC8vIHBhZGRpbmcgb2YgMiBzZWVtcyB0byBoYW5kbGUgdGhpcyBpc3N1ZS5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFkZGluZyA9IDIsXG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBuYXRpdmVDbGllbnRSZWN0cyA9IEFycmF5LmZyb20oKGF3YWl0IChwbGF0Zm9ybS5nZXRDbGllbnRSZWN0cyA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uZ2V0Q2xpZW50UmVjdHMoZWxlbWVudHMucmVmZXJlbmNlKSkpIHx8IFtdKTtcbiAgICAgIGNvbnN0IGNsaWVudFJlY3RzID0gZ2V0UmVjdHNCeUxpbmUobmF0aXZlQ2xpZW50UmVjdHMpO1xuICAgICAgY29uc3QgZmFsbGJhY2sgPSByZWN0VG9DbGllbnRSZWN0KGdldEJvdW5kaW5nUmVjdChuYXRpdmVDbGllbnRSZWN0cykpO1xuICAgICAgY29uc3QgcGFkZGluZ09iamVjdCA9IGdldFBhZGRpbmdPYmplY3QocGFkZGluZyk7XG4gICAgICBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB7XG4gICAgICAgIC8vIFRoZXJlIGFyZSB0d28gcmVjdHMgYW5kIHRoZXkgYXJlIGRpc2pvaW5lZC5cbiAgICAgICAgaWYgKGNsaWVudFJlY3RzLmxlbmd0aCA9PT0gMiAmJiBjbGllbnRSZWN0c1swXS5sZWZ0ID4gY2xpZW50UmVjdHNbMV0ucmlnaHQgJiYgeCAhPSBudWxsICYmIHkgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IHJlY3QgaW4gd2hpY2ggdGhlIHBvaW50IGlzIGZ1bGx5IGluc2lkZS5cbiAgICAgICAgICByZXR1cm4gY2xpZW50UmVjdHMuZmluZChyZWN0ID0+IHggPiByZWN0LmxlZnQgLSBwYWRkaW5nT2JqZWN0LmxlZnQgJiYgeCA8IHJlY3QucmlnaHQgKyBwYWRkaW5nT2JqZWN0LnJpZ2h0ICYmIHkgPiByZWN0LnRvcCAtIHBhZGRpbmdPYmplY3QudG9wICYmIHkgPCByZWN0LmJvdHRvbSArIHBhZGRpbmdPYmplY3QuYm90dG9tKSB8fCBmYWxsYmFjaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZXJlIGFyZSAyIG9yIG1vcmUgY29ubmVjdGVkIHJlY3RzLlxuICAgICAgICBpZiAoY2xpZW50UmVjdHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICBpZiAoZ2V0U2lkZUF4aXMocGxhY2VtZW50KSA9PT0gJ3knKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdFJlY3QgPSBjbGllbnRSZWN0c1swXTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RSZWN0ID0gY2xpZW50UmVjdHNbY2xpZW50UmVjdHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjb25zdCBpc1RvcCA9IGdldFNpZGUocGxhY2VtZW50KSA9PT0gJ3RvcCc7XG4gICAgICAgICAgICBjb25zdCB0b3AgPSBmaXJzdFJlY3QudG9wO1xuICAgICAgICAgICAgY29uc3QgYm90dG9tID0gbGFzdFJlY3QuYm90dG9tO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IGlzVG9wID8gZmlyc3RSZWN0LmxlZnQgOiBsYXN0UmVjdC5sZWZ0O1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBpc1RvcCA/IGZpcnN0UmVjdC5yaWdodCA6IGxhc3RSZWN0LnJpZ2h0O1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICAgIGJvdHRvbSxcbiAgICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgIHg6IGxlZnQsXG4gICAgICAgICAgICAgIHk6IHRvcFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaXNMZWZ0U2lkZSA9IGdldFNpZGUocGxhY2VtZW50KSA9PT0gJ2xlZnQnO1xuICAgICAgICAgIGNvbnN0IG1heFJpZ2h0ID0gbWF4KC4uLmNsaWVudFJlY3RzLm1hcChyZWN0ID0+IHJlY3QucmlnaHQpKTtcbiAgICAgICAgICBjb25zdCBtaW5MZWZ0ID0gbWluKC4uLmNsaWVudFJlY3RzLm1hcChyZWN0ID0+IHJlY3QubGVmdCkpO1xuICAgICAgICAgIGNvbnN0IG1lYXN1cmVSZWN0cyA9IGNsaWVudFJlY3RzLmZpbHRlcihyZWN0ID0+IGlzTGVmdFNpZGUgPyByZWN0LmxlZnQgPT09IG1pbkxlZnQgOiByZWN0LnJpZ2h0ID09PSBtYXhSaWdodCk7XG4gICAgICAgICAgY29uc3QgdG9wID0gbWVhc3VyZVJlY3RzWzBdLnRvcDtcbiAgICAgICAgICBjb25zdCBib3R0b20gPSBtZWFzdXJlUmVjdHNbbWVhc3VyZVJlY3RzLmxlbmd0aCAtIDFdLmJvdHRvbTtcbiAgICAgICAgICBjb25zdCBsZWZ0ID0gbWluTGVmdDtcbiAgICAgICAgICBjb25zdCByaWdodCA9IG1heFJpZ2h0O1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgYm90dG9tLFxuICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICB4OiBsZWZ0LFxuICAgICAgICAgICAgeTogdG9wXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNldFJlY3RzID0gYXdhaXQgcGxhdGZvcm0uZ2V0RWxlbWVudFJlY3RzKHtcbiAgICAgICAgcmVmZXJlbmNlOiB7XG4gICAgICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gICAgICAgIH0sXG4gICAgICAgIGZsb2F0aW5nOiBlbGVtZW50cy5mbG9hdGluZyxcbiAgICAgICAgc3RyYXRlZ3lcbiAgICAgIH0pO1xuICAgICAgaWYgKHJlY3RzLnJlZmVyZW5jZS54ICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS54IHx8IHJlY3RzLnJlZmVyZW5jZS55ICE9PSByZXNldFJlY3RzLnJlZmVyZW5jZS55IHx8IHJlY3RzLnJlZmVyZW5jZS53aWR0aCAhPT0gcmVzZXRSZWN0cy5yZWZlcmVuY2Uud2lkdGggfHwgcmVjdHMucmVmZXJlbmNlLmhlaWdodCAhPT0gcmVzZXRSZWN0cy5yZWZlcmVuY2UuaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHJlY3RzOiByZXNldFJlY3RzXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIEZvciB0eXBlIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LCB0aGUgYE9mZnNldE9wdGlvbnNgIHR5cGUgd2FzIGFsc29cbi8vIERlcml2YWJsZS5cbmFzeW5jIGZ1bmN0aW9uIGNvbnZlcnRWYWx1ZVRvQ29vcmRzKHN0YXRlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBwbGFjZW1lbnQsXG4gICAgcGxhdGZvcm0sXG4gICAgZWxlbWVudHNcbiAgfSA9IHN0YXRlO1xuICBjb25zdCBydGwgPSBhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGVsZW1lbnRzLmZsb2F0aW5nKSk7XG4gIGNvbnN0IHNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCk7XG4gIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICBjb25zdCBpc1ZlcnRpY2FsID0gZ2V0U2lkZUF4aXMocGxhY2VtZW50KSA9PT0gJ3knO1xuICBjb25zdCBtYWluQXhpc011bHRpID0gWydsZWZ0JywgJ3RvcCddLmluY2x1ZGVzKHNpZGUpID8gLTEgOiAxO1xuICBjb25zdCBjcm9zc0F4aXNNdWx0aSA9IHJ0bCAmJiBpc1ZlcnRpY2FsID8gLTEgOiAxO1xuICBjb25zdCByYXdWYWx1ZSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gIGxldCB7XG4gICAgbWFpbkF4aXMsXG4gICAgY3Jvc3NBeGlzLFxuICAgIGFsaWdubWVudEF4aXNcbiAgfSA9IHR5cGVvZiByYXdWYWx1ZSA9PT0gJ251bWJlcicgPyB7XG4gICAgbWFpbkF4aXM6IHJhd1ZhbHVlLFxuICAgIGNyb3NzQXhpczogMCxcbiAgICBhbGlnbm1lbnRBeGlzOiBudWxsXG4gIH0gOiB7XG4gICAgbWFpbkF4aXM6IDAsXG4gICAgY3Jvc3NBeGlzOiAwLFxuICAgIGFsaWdubWVudEF4aXM6IG51bGwsXG4gICAgLi4ucmF3VmFsdWVcbiAgfTtcbiAgaWYgKGFsaWdubWVudCAmJiB0eXBlb2YgYWxpZ25tZW50QXhpcyA9PT0gJ251bWJlcicpIHtcbiAgICBjcm9zc0F4aXMgPSBhbGlnbm1lbnQgPT09ICdlbmQnID8gYWxpZ25tZW50QXhpcyAqIC0xIDogYWxpZ25tZW50QXhpcztcbiAgfVxuICByZXR1cm4gaXNWZXJ0aWNhbCA/IHtcbiAgICB4OiBjcm9zc0F4aXMgKiBjcm9zc0F4aXNNdWx0aSxcbiAgICB5OiBtYWluQXhpcyAqIG1haW5BeGlzTXVsdGlcbiAgfSA6IHtcbiAgICB4OiBtYWluQXhpcyAqIG1haW5BeGlzTXVsdGksXG4gICAgeTogY3Jvc3NBeGlzICogY3Jvc3NBeGlzTXVsdGlcbiAgfTtcbn1cblxuLyoqXG4gKiBNb2RpZmllcyB0aGUgcGxhY2VtZW50IGJ5IHRyYW5zbGF0aW5nIHRoZSBmbG9hdGluZyBlbGVtZW50IGFsb25nIHRoZVxuICogc3BlY2lmaWVkIGF4ZXMuXG4gKiBBIG51bWJlciAoc2hvcnRoYW5kIGZvciBgbWFpbkF4aXNgIG9yIGRpc3RhbmNlKSwgb3IgYW4gYXhlcyBjb25maWd1cmF0aW9uXG4gKiBvYmplY3QgbWF5IGJlIHBhc3NlZC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9vZmZzZXRcbiAqL1xuY29uc3Qgb2Zmc2V0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ29mZnNldCcsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRvZmZzZSwgX21pZGRsZXdhcmVEYXRhJGFycm93O1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCBkaWZmQ29vcmRzID0gYXdhaXQgY29udmVydFZhbHVlVG9Db29yZHMoc3RhdGUsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBJZiB0aGUgcGxhY2VtZW50IGlzIHRoZSBzYW1lIGFuZCB0aGUgYXJyb3cgY2F1c2VkIGFuIGFsaWdubWVudCBvZmZzZXRcbiAgICAgIC8vIHRoZW4gd2UgZG9uJ3QgbmVlZCB0byBjaGFuZ2UgdGhlIHBvc2l0aW9uaW5nIGNvb3JkaW5hdGVzLlxuICAgICAgaWYgKHBsYWNlbWVudCA9PT0gKChfbWlkZGxld2FyZURhdGEkb2Zmc2UgPSBtaWRkbGV3YXJlRGF0YS5vZmZzZXQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkb2Zmc2UucGxhY2VtZW50KSAmJiAoX21pZGRsZXdhcmVEYXRhJGFycm93ID0gbWlkZGxld2FyZURhdGEuYXJyb3cpICE9IG51bGwgJiYgX21pZGRsZXdhcmVEYXRhJGFycm93LmFsaWdubWVudE9mZnNldCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4ICsgZGlmZkNvb3Jkcy54LFxuICAgICAgICB5OiB5ICsgZGlmZkNvb3Jkcy55LFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgLi4uZGlmZkNvb3JkcyxcbiAgICAgICAgICBwbGFjZW1lbnRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBzaGlmdGluZyBpdCBpbiBvcmRlciB0b1xuICoga2VlcCBpdCBpbiB2aWV3IHdoZW4gaXQgd2lsbCBvdmVyZmxvdyB0aGUgY2xpcHBpbmcgYm91bmRhcnkuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2hpZnRcbiAqL1xuY29uc3Qgc2hpZnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ3NoaWZ0JyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHBsYWNlbWVudFxuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9IHRydWUsXG4gICAgICAgIGNyb3NzQXhpczogY2hlY2tDcm9zc0F4aXMgPSBmYWxzZSxcbiAgICAgICAgbGltaXRlciA9IHtcbiAgICAgICAgICBmbjogX3JlZiA9PiB7XG4gICAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICB5XG4gICAgICAgICAgICB9ID0gX3JlZjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgIHlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBjb29yZHMgPSB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH07XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3QgY3Jvc3NBeGlzID0gZ2V0U2lkZUF4aXMoZ2V0U2lkZShwbGFjZW1lbnQpKTtcbiAgICAgIGNvbnN0IG1haW5BeGlzID0gZ2V0T3Bwb3NpdGVBeGlzKGNyb3NzQXhpcyk7XG4gICAgICBsZXQgbWFpbkF4aXNDb29yZCA9IGNvb3Jkc1ttYWluQXhpc107XG4gICAgICBsZXQgY3Jvc3NBeGlzQ29vcmQgPSBjb29yZHNbY3Jvc3NBeGlzXTtcbiAgICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICAgIGNvbnN0IG1pblNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgICAgIGNvbnN0IG1heFNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICAgICAgICBjb25zdCBtaW4gPSBtYWluQXhpc0Nvb3JkICsgb3ZlcmZsb3dbbWluU2lkZV07XG4gICAgICAgIGNvbnN0IG1heCA9IG1haW5BeGlzQ29vcmQgLSBvdmVyZmxvd1ttYXhTaWRlXTtcbiAgICAgICAgbWFpbkF4aXNDb29yZCA9IGNsYW1wKG1pbiwgbWFpbkF4aXNDb29yZCwgbWF4KTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGVja0Nyb3NzQXhpcykge1xuICAgICAgICBjb25zdCBtaW5TaWRlID0gY3Jvc3NBeGlzID09PSAneScgPyAndG9wJyA6ICdsZWZ0JztcbiAgICAgICAgY29uc3QgbWF4U2lkZSA9IGNyb3NzQXhpcyA9PT0gJ3knID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICAgICAgICBjb25zdCBtaW4gPSBjcm9zc0F4aXNDb29yZCArIG92ZXJmbG93W21pblNpZGVdO1xuICAgICAgICBjb25zdCBtYXggPSBjcm9zc0F4aXNDb29yZCAtIG92ZXJmbG93W21heFNpZGVdO1xuICAgICAgICBjcm9zc0F4aXNDb29yZCA9IGNsYW1wKG1pbiwgY3Jvc3NBeGlzQ29vcmQsIG1heCk7XG4gICAgICB9XG4gICAgICBjb25zdCBsaW1pdGVkQ29vcmRzID0gbGltaXRlci5mbih7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBbbWFpbkF4aXNdOiBtYWluQXhpc0Nvb3JkLFxuICAgICAgICBbY3Jvc3NBeGlzXTogY3Jvc3NBeGlzQ29vcmRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubGltaXRlZENvb3JkcyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHg6IGxpbWl0ZWRDb29yZHMueCAtIHgsXG4gICAgICAgICAgeTogbGltaXRlZENvb3Jkcy55IC0geVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG4vKipcbiAqIEJ1aWx0LWluIGBsaW1pdGVyYCB0aGF0IHdpbGwgc3RvcCBgc2hpZnQoKWAgYXQgYSBjZXJ0YWluIHBvaW50LlxuICovXG5jb25zdCBsaW1pdFNoaWZ0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG9wdGlvbnMsXG4gICAgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICByZWN0cyxcbiAgICAgICAgbWlkZGxld2FyZURhdGFcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb2Zmc2V0ID0gMCxcbiAgICAgICAgbWFpbkF4aXM6IGNoZWNrTWFpbkF4aXMgPSB0cnVlLFxuICAgICAgICBjcm9zc0F4aXM6IGNoZWNrQ3Jvc3NBeGlzID0gdHJ1ZVxuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNyb3NzQXhpcyA9IGdldFNpZGVBeGlzKHBsYWNlbWVudCk7XG4gICAgICBjb25zdCBtYWluQXhpcyA9IGdldE9wcG9zaXRlQXhpcyhjcm9zc0F4aXMpO1xuICAgICAgbGV0IG1haW5BeGlzQ29vcmQgPSBjb29yZHNbbWFpbkF4aXNdO1xuICAgICAgbGV0IGNyb3NzQXhpc0Nvb3JkID0gY29vcmRzW2Nyb3NzQXhpc107XG4gICAgICBjb25zdCByYXdPZmZzZXQgPSBldmFsdWF0ZShvZmZzZXQsIHN0YXRlKTtcbiAgICAgIGNvbnN0IGNvbXB1dGVkT2Zmc2V0ID0gdHlwZW9mIHJhd09mZnNldCA9PT0gJ251bWJlcicgPyB7XG4gICAgICAgIG1haW5BeGlzOiByYXdPZmZzZXQsXG4gICAgICAgIGNyb3NzQXhpczogMFxuICAgICAgfSA6IHtcbiAgICAgICAgbWFpbkF4aXM6IDAsXG4gICAgICAgIGNyb3NzQXhpczogMCxcbiAgICAgICAgLi4ucmF3T2Zmc2V0XG4gICAgICB9O1xuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgY29uc3QgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICAgICAgY29uc3QgbGltaXRNaW4gPSByZWN0cy5yZWZlcmVuY2VbbWFpbkF4aXNdIC0gcmVjdHMuZmxvYXRpbmdbbGVuXSArIGNvbXB1dGVkT2Zmc2V0Lm1haW5BeGlzO1xuICAgICAgICBjb25zdCBsaW1pdE1heCA9IHJlY3RzLnJlZmVyZW5jZVttYWluQXhpc10gKyByZWN0cy5yZWZlcmVuY2VbbGVuXSAtIGNvbXB1dGVkT2Zmc2V0Lm1haW5BeGlzO1xuICAgICAgICBpZiAobWFpbkF4aXNDb29yZCA8IGxpbWl0TWluKSB7XG4gICAgICAgICAgbWFpbkF4aXNDb29yZCA9IGxpbWl0TWluO1xuICAgICAgICB9IGVsc2UgaWYgKG1haW5BeGlzQ29vcmQgPiBsaW1pdE1heCkge1xuICAgICAgICAgIG1haW5BeGlzQ29vcmQgPSBsaW1pdE1heDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNoZWNrQ3Jvc3NBeGlzKSB7XG4gICAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkb2Zmc2UsIF9taWRkbGV3YXJlRGF0YSRvZmZzZTI7XG4gICAgICAgIGNvbnN0IGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgICAgIGNvbnN0IGlzT3JpZ2luU2lkZSA9IFsndG9wJywgJ2xlZnQnXS5pbmNsdWRlcyhnZXRTaWRlKHBsYWNlbWVudCkpO1xuICAgICAgICBjb25zdCBsaW1pdE1pbiA9IHJlY3RzLnJlZmVyZW5jZVtjcm9zc0F4aXNdIC0gcmVjdHMuZmxvYXRpbmdbbGVuXSArIChpc09yaWdpblNpZGUgPyAoKF9taWRkbGV3YXJlRGF0YSRvZmZzZSA9IG1pZGRsZXdhcmVEYXRhLm9mZnNldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRvZmZzZVtjcm9zc0F4aXNdKSB8fCAwIDogMCkgKyAoaXNPcmlnaW5TaWRlID8gMCA6IGNvbXB1dGVkT2Zmc2V0LmNyb3NzQXhpcyk7XG4gICAgICAgIGNvbnN0IGxpbWl0TWF4ID0gcmVjdHMucmVmZXJlbmNlW2Nyb3NzQXhpc10gKyByZWN0cy5yZWZlcmVuY2VbbGVuXSArIChpc09yaWdpblNpZGUgPyAwIDogKChfbWlkZGxld2FyZURhdGEkb2Zmc2UyID0gbWlkZGxld2FyZURhdGEub2Zmc2V0KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJG9mZnNlMltjcm9zc0F4aXNdKSB8fCAwKSAtIChpc09yaWdpblNpZGUgPyBjb21wdXRlZE9mZnNldC5jcm9zc0F4aXMgOiAwKTtcbiAgICAgICAgaWYgKGNyb3NzQXhpc0Nvb3JkIDwgbGltaXRNaW4pIHtcbiAgICAgICAgICBjcm9zc0F4aXNDb29yZCA9IGxpbWl0TWluO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQXhpc0Nvb3JkID4gbGltaXRNYXgpIHtcbiAgICAgICAgICBjcm9zc0F4aXNDb29yZCA9IGxpbWl0TWF4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbbWFpbkF4aXNdOiBtYWluQXhpc0Nvb3JkLFxuICAgICAgICBbY3Jvc3NBeGlzXTogY3Jvc3NBeGlzQ29vcmRcbiAgICAgIH07XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRoYXQgYWxsb3dzIHlvdSB0byBjaGFuZ2UgdGhlIHNpemUgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQg4oCUXG4gKiBmb3IgaW5zdGFuY2UsIHByZXZlbnQgaXQgZnJvbSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgYm91bmRhcnkgb3IgbWF0Y2ggdGhlXG4gKiB3aWR0aCBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2l6ZVxuICovXG5jb25zdCBzaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdzaXplJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBlbGVtZW50c1xuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhcHBseSA9ICgpID0+IHt9LFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICAgICAgY29uc3QgaXNZQXhpcyA9IGdldFNpZGVBeGlzKHBsYWNlbWVudCkgPT09ICd5JztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSA9IHJlY3RzLmZsb2F0aW5nO1xuICAgICAgbGV0IGhlaWdodFNpZGU7XG4gICAgICBsZXQgd2lkdGhTaWRlO1xuICAgICAgaWYgKHNpZGUgPT09ICd0b3AnIHx8IHNpZGUgPT09ICdib3R0b20nKSB7XG4gICAgICAgIGhlaWdodFNpZGUgPSBzaWRlO1xuICAgICAgICB3aWR0aFNpZGUgPSBhbGlnbm1lbnQgPT09ICgoYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpKSA/ICdzdGFydCcgOiAnZW5kJykgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2lkdGhTaWRlID0gc2lkZTtcbiAgICAgICAgaGVpZ2h0U2lkZSA9IGFsaWdubWVudCA9PT0gJ2VuZCcgPyAndG9wJyA6ICdib3R0b20nO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3ZlcmZsb3dBdmFpbGFibGVIZWlnaHQgPSBoZWlnaHQgLSBvdmVyZmxvd1toZWlnaHRTaWRlXTtcbiAgICAgIGNvbnN0IG92ZXJmbG93QXZhaWxhYmxlV2lkdGggPSB3aWR0aCAtIG92ZXJmbG93W3dpZHRoU2lkZV07XG4gICAgICBjb25zdCBub1NoaWZ0ID0gIXN0YXRlLm1pZGRsZXdhcmVEYXRhLnNoaWZ0O1xuICAgICAgbGV0IGF2YWlsYWJsZUhlaWdodCA9IG92ZXJmbG93QXZhaWxhYmxlSGVpZ2h0O1xuICAgICAgbGV0IGF2YWlsYWJsZVdpZHRoID0gb3ZlcmZsb3dBdmFpbGFibGVXaWR0aDtcbiAgICAgIGlmIChpc1lBeGlzKSB7XG4gICAgICAgIGNvbnN0IG1heGltdW1DbGlwcGluZ1dpZHRoID0gd2lkdGggLSBvdmVyZmxvdy5sZWZ0IC0gb3ZlcmZsb3cucmlnaHQ7XG4gICAgICAgIGF2YWlsYWJsZVdpZHRoID0gYWxpZ25tZW50IHx8IG5vU2hpZnQgPyBtaW4ob3ZlcmZsb3dBdmFpbGFibGVXaWR0aCwgbWF4aW11bUNsaXBwaW5nV2lkdGgpIDogbWF4aW11bUNsaXBwaW5nV2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBtYXhpbXVtQ2xpcHBpbmdIZWlnaHQgPSBoZWlnaHQgLSBvdmVyZmxvdy50b3AgLSBvdmVyZmxvdy5ib3R0b207XG4gICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IGFsaWdubWVudCB8fCBub1NoaWZ0ID8gbWluKG92ZXJmbG93QXZhaWxhYmxlSGVpZ2h0LCBtYXhpbXVtQ2xpcHBpbmdIZWlnaHQpIDogbWF4aW11bUNsaXBwaW5nSGVpZ2h0O1xuICAgICAgfVxuICAgICAgaWYgKG5vU2hpZnQgJiYgIWFsaWdubWVudCkge1xuICAgICAgICBjb25zdCB4TWluID0gbWF4KG92ZXJmbG93LmxlZnQsIDApO1xuICAgICAgICBjb25zdCB4TWF4ID0gbWF4KG92ZXJmbG93LnJpZ2h0LCAwKTtcbiAgICAgICAgY29uc3QgeU1pbiA9IG1heChvdmVyZmxvdy50b3AsIDApO1xuICAgICAgICBjb25zdCB5TWF4ID0gbWF4KG92ZXJmbG93LmJvdHRvbSwgMCk7XG4gICAgICAgIGlmIChpc1lBeGlzKSB7XG4gICAgICAgICAgYXZhaWxhYmxlV2lkdGggPSB3aWR0aCAtIDIgKiAoeE1pbiAhPT0gMCB8fCB4TWF4ICE9PSAwID8geE1pbiArIHhNYXggOiBtYXgob3ZlcmZsb3cubGVmdCwgb3ZlcmZsb3cucmlnaHQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBoZWlnaHQgLSAyICogKHlNaW4gIT09IDAgfHwgeU1heCAhPT0gMCA/IHlNaW4gKyB5TWF4IDogbWF4KG92ZXJmbG93LnRvcCwgb3ZlcmZsb3cuYm90dG9tKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGF3YWl0IGFwcGx5KHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGF2YWlsYWJsZVdpZHRoLFxuICAgICAgICBhdmFpbGFibGVIZWlnaHRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbmV4dERpbWVuc2lvbnMgPSBhd2FpdCBwbGF0Zm9ybS5nZXREaW1lbnNpb25zKGVsZW1lbnRzLmZsb2F0aW5nKTtcbiAgICAgIGlmICh3aWR0aCAhPT0gbmV4dERpbWVuc2lvbnMud2lkdGggfHwgaGVpZ2h0ICE9PSBuZXh0RGltZW5zaW9ucy5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcmVjdHM6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuZXhwb3J0IHsgYXJyb3csIGF1dG9QbGFjZW1lbnQsIGNvbXB1dGVQb3NpdGlvbiwgZGV0ZWN0T3ZlcmZsb3csIGZsaXAsIGhpZGUsIGlubGluZSwgbGltaXRTaGlmdCwgb2Zmc2V0LCBzaGlmdCwgc2l6ZSB9O1xuIl0sIm5hbWVzIjpbImdldFNpZGVBeGlzIiwiZ2V0QWxpZ25tZW50QXhpcyIsImdldEF4aXNMZW5ndGgiLCJnZXRTaWRlIiwiZ2V0QWxpZ25tZW50IiwiZXZhbHVhdGUiLCJnZXRQYWRkaW5nT2JqZWN0IiwicmVjdFRvQ2xpZW50UmVjdCIsIm1pbiIsImNsYW1wIiwicGxhY2VtZW50cyIsImdldEFsaWdubWVudFNpZGVzIiwiZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQiLCJnZXRPcHBvc2l0ZVBsYWNlbWVudCIsImdldEV4cGFuZGVkUGxhY2VtZW50cyIsImdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMiLCJzaWRlcyIsIm1heCIsImdldE9wcG9zaXRlQXhpcyIsImNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50IiwiX3JlZiIsInBsYWNlbWVudCIsInJ0bCIsInJlZmVyZW5jZSIsImZsb2F0aW5nIiwic2lkZUF4aXMiLCJhbGlnbm1lbnRBeGlzIiwiYWxpZ25MZW5ndGgiLCJzaWRlIiwiaXNWZXJ0aWNhbCIsImNvbW1vblgiLCJ4Iiwid2lkdGgiLCJjb21tb25ZIiwieSIsImhlaWdodCIsImNvbW1vbkFsaWduIiwiY29vcmRzIiwiY29tcHV0ZVBvc2l0aW9uIiwiY29uZmlnIiwic3RyYXRlZ3kiLCJtaWRkbGV3YXJlIiwicGxhdGZvcm0iLCJ2YWxpZE1pZGRsZXdhcmUiLCJmaWx0ZXIiLCJCb29sZWFuIiwiaXNSVEwiLCJyZWN0cyIsImdldEVsZW1lbnRSZWN0cyIsInN0YXRlZnVsUGxhY2VtZW50IiwibWlkZGxld2FyZURhdGEiLCJyZXNldENvdW50IiwiaSIsImxlbmd0aCIsIm5hbWUiLCJmbiIsIm5leHRYIiwibmV4dFkiLCJkYXRhIiwicmVzZXQiLCJpbml0aWFsUGxhY2VtZW50IiwiZWxlbWVudHMiLCJkZXRlY3RPdmVyZmxvdyIsInN0YXRlIiwib3B0aW9ucyIsIl9hd2FpdCRwbGF0Zm9ybSRpc0VsZSIsImJvdW5kYXJ5Iiwicm9vdEJvdW5kYXJ5IiwiZWxlbWVudENvbnRleHQiLCJhbHRCb3VuZGFyeSIsInBhZGRpbmciLCJwYWRkaW5nT2JqZWN0IiwiYWx0Q29udGV4dCIsImVsZW1lbnQiLCJjbGlwcGluZ0NsaWVudFJlY3QiLCJnZXRDbGlwcGluZ1JlY3QiLCJpc0VsZW1lbnQiLCJjb250ZXh0RWxlbWVudCIsImdldERvY3VtZW50RWxlbWVudCIsInJlY3QiLCJvZmZzZXRQYXJlbnQiLCJnZXRPZmZzZXRQYXJlbnQiLCJvZmZzZXRTY2FsZSIsImdldFNjYWxlIiwiZWxlbWVudENsaWVudFJlY3QiLCJjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCIsInRvcCIsImJvdHRvbSIsImxlZnQiLCJyaWdodCIsImFycm93IiwiYXhpcyIsImFycm93RGltZW5zaW9ucyIsImdldERpbWVuc2lvbnMiLCJpc1lBeGlzIiwibWluUHJvcCIsIm1heFByb3AiLCJjbGllbnRQcm9wIiwiZW5kRGlmZiIsInN0YXJ0RGlmZiIsImFycm93T2Zmc2V0UGFyZW50IiwiY2xpZW50U2l6ZSIsImNlbnRlclRvUmVmZXJlbmNlIiwibGFyZ2VzdFBvc3NpYmxlUGFkZGluZyIsIm1pblBhZGRpbmciLCJtYXhQYWRkaW5nIiwibWluJDEiLCJjZW50ZXIiLCJvZmZzZXQiLCJzaG91bGRBZGRPZmZzZXQiLCJhbGlnbm1lbnRPZmZzZXQiLCJjZW50ZXJPZmZzZXQiLCJnZXRQbGFjZW1lbnRMaXN0IiwiYWxpZ25tZW50IiwiYXV0b0FsaWdubWVudCIsImFsbG93ZWRQbGFjZW1lbnRzIiwiYWxsb3dlZFBsYWNlbWVudHNTb3J0ZWRCeUFsaWdubWVudCIsImF1dG9QbGFjZW1lbnQiLCJfbWlkZGxld2FyZURhdGEkYXV0b1AiLCJfbWlkZGxld2FyZURhdGEkYXV0b1AyIiwiX3BsYWNlbWVudHNUaGF0Rml0T25FIiwiY3Jvc3NBeGlzIiwiZGV0ZWN0T3ZlcmZsb3dPcHRpb25zIiwicGxhY2VtZW50cyQxIiwidW5kZWZpbmVkIiwib3ZlcmZsb3ciLCJjdXJyZW50SW5kZXgiLCJpbmRleCIsImN1cnJlbnRQbGFjZW1lbnQiLCJhbGlnbm1lbnRTaWRlcyIsImN1cnJlbnRPdmVyZmxvd3MiLCJhbGxPdmVyZmxvd3MiLCJvdmVyZmxvd3MiLCJuZXh0UGxhY2VtZW50IiwicGxhY2VtZW50c1NvcnRlZEJ5TW9zdFNwYWNlIiwibWFwIiwiZCIsInNsaWNlIiwicmVkdWNlIiwiYWNjIiwidiIsInNvcnQiLCJhIiwiYiIsInBsYWNlbWVudHNUaGF0Rml0T25FYWNoU2lkZSIsImV2ZXJ5IiwicmVzZXRQbGFjZW1lbnQiLCJmbGlwIiwiX21pZGRsZXdhcmVEYXRhJGFycm93IiwiX21pZGRsZXdhcmVEYXRhJGZsaXAiLCJtYWluQXhpcyIsImNoZWNrTWFpbkF4aXMiLCJjaGVja0Nyb3NzQXhpcyIsImZhbGxiYWNrUGxhY2VtZW50cyIsInNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyIsImZhbGxiYWNrU3RyYXRlZ3kiLCJmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uIiwiZmxpcEFsaWdubWVudCIsImlzQmFzZVBsYWNlbWVudCIsInB1c2giLCJvdmVyZmxvd3NEYXRhIiwiX21pZGRsZXdhcmVEYXRhJGZsaXAyIiwiX292ZXJmbG93c0RhdGEkZmlsdGVyIiwibmV4dEluZGV4IiwiX292ZXJmbG93c0RhdGEkbWFwJHNvIiwiZ2V0U2lkZU9mZnNldHMiLCJpc0FueVNpZGVGdWxseUNsaXBwZWQiLCJzb21lIiwiaGlkZSIsIm9mZnNldHMiLCJyZWZlcmVuY2VIaWRkZW5PZmZzZXRzIiwicmVmZXJlbmNlSGlkZGVuIiwiZXNjYXBlZE9mZnNldHMiLCJlc2NhcGVkIiwiZ2V0Qm91bmRpbmdSZWN0IiwibWluWCIsIm1pblkiLCJtYXhYIiwibWF4WSIsImdldFJlY3RzQnlMaW5lIiwic29ydGVkUmVjdHMiLCJncm91cHMiLCJwcmV2UmVjdCIsImlubGluZSIsIm5hdGl2ZUNsaWVudFJlY3RzIiwiQXJyYXkiLCJmcm9tIiwiZ2V0Q2xpZW50UmVjdHMiLCJjbGllbnRSZWN0cyIsImZhbGxiYWNrIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZmluZCIsImZpcnN0UmVjdCIsImxhc3RSZWN0IiwiaXNUb3AiLCJpc0xlZnRTaWRlIiwibWF4UmlnaHQiLCJtaW5MZWZ0IiwibWVhc3VyZVJlY3RzIiwicmVzZXRSZWN0cyIsImNvbnZlcnRWYWx1ZVRvQ29vcmRzIiwibWFpbkF4aXNNdWx0aSIsImluY2x1ZGVzIiwiY3Jvc3NBeGlzTXVsdGkiLCJyYXdWYWx1ZSIsIl9taWRkbGV3YXJlRGF0YSRvZmZzZSIsImRpZmZDb29yZHMiLCJzaGlmdCIsImxpbWl0ZXIiLCJtYWluQXhpc0Nvb3JkIiwiY3Jvc3NBeGlzQ29vcmQiLCJtaW5TaWRlIiwibWF4U2lkZSIsImxpbWl0ZWRDb29yZHMiLCJsaW1pdFNoaWZ0IiwicmF3T2Zmc2V0IiwiY29tcHV0ZWRPZmZzZXQiLCJsZW4iLCJsaW1pdE1pbiIsImxpbWl0TWF4IiwiX21pZGRsZXdhcmVEYXRhJG9mZnNlMiIsImlzT3JpZ2luU2lkZSIsInNpemUiLCJhcHBseSIsImhlaWdodFNpZGUiLCJ3aWR0aFNpZGUiLCJvdmVyZmxvd0F2YWlsYWJsZUhlaWdodCIsIm92ZXJmbG93QXZhaWxhYmxlV2lkdGgiLCJub1NoaWZ0IiwiYXZhaWxhYmxlSGVpZ2h0IiwiYXZhaWxhYmxlV2lkdGgiLCJtYXhpbXVtQ2xpcHBpbmdXaWR0aCIsIm1heGltdW1DbGlwcGluZ0hlaWdodCIsInhNaW4iLCJ4TWF4IiwieU1pbiIsInlNYXgiLCJuZXh0RGltZW5zaW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.arrow),\n/* harmony export */   autoPlacement: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.autoPlacement),\n/* harmony export */   autoUpdate: () => (/* binding */ autoUpdate),\n/* harmony export */   computePosition: () => (/* binding */ computePosition),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.detectOverflow),\n/* harmony export */   flip: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.hide),\n/* harmony export */   inline: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.inline),\n/* harmony export */   limitShift: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.limitShift),\n/* harmony export */   offset: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.offset),\n/* harmony export */   platform: () => (/* binding */ platform),\n/* harmony export */   shift: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.shift),\n/* harmony export */   size: () => (/* reexport safe */ _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.size)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/utils */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n/* harmony import */ var _floating_ui_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/core */ \"(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\");\n/* harmony import */ var _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/utils/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs\");\n\n\n\n\n\nfunction getCssDimensions(element) {\n    const css = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element);\n    // In testing environments, the `width` and `height` properties are empty\n    // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n    let width = parseFloat(css.width) || 0;\n    let height = parseFloat(css.height) || 0;\n    const hasOffset = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element);\n    const offsetWidth = hasOffset ? element.offsetWidth : width;\n    const offsetHeight = hasOffset ? element.offsetHeight : height;\n    const shouldFallback = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.round)(width) !== offsetWidth || (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.round)(height) !== offsetHeight;\n    if (shouldFallback) {\n        width = offsetWidth;\n        height = offsetHeight;\n    }\n    return {\n        width,\n        height,\n        $: shouldFallback\n    };\n}\nfunction unwrapElement(element) {\n    return !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(element) ? element.contextElement : element;\n}\nfunction getScale(element) {\n    const domElement = unwrapElement(element);\n    if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(domElement)) {\n        return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(1);\n    }\n    const rect = domElement.getBoundingClientRect();\n    const { width, height, $ } = getCssDimensions(domElement);\n    let x = ($ ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.round)(rect.width) : rect.width) / width;\n    let y = ($ ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.round)(rect.height) : rect.height) / height;\n    // 0, NaN, or Infinity should always fallback to 1.\n    if (!x || !Number.isFinite(x)) {\n        x = 1;\n    }\n    if (!y || !Number.isFinite(y)) {\n        y = 1;\n    }\n    return {\n        x,\n        y\n    };\n}\nconst noOffsets = /*#__PURE__*/ (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(0);\nfunction getVisualOffsets(element) {\n    const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(element);\n    if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isWebKit)() || !win.visualViewport) {\n        return noOffsets;\n    }\n    return {\n        x: win.visualViewport.offsetLeft,\n        y: win.visualViewport.offsetTop\n    };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n    if (isFixed === void 0) {\n        isFixed = false;\n    }\n    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(element)) {\n        return false;\n    }\n    return isFixed;\n}\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n    if (includeScale === void 0) {\n        includeScale = false;\n    }\n    if (isFixedStrategy === void 0) {\n        isFixedStrategy = false;\n    }\n    const clientRect = element.getBoundingClientRect();\n    const domElement = unwrapElement(element);\n    let scale = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(1);\n    if (includeScale) {\n        if (offsetParent) {\n            if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(offsetParent)) {\n                scale = getScale(offsetParent);\n            }\n        } else {\n            scale = getScale(element);\n        }\n    }\n    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(0);\n    let x = (clientRect.left + visualOffsets.x) / scale.x;\n    let y = (clientRect.top + visualOffsets.y) / scale.y;\n    let width = clientRect.width / scale.x;\n    let height = clientRect.height / scale.y;\n    if (domElement) {\n        const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(domElement);\n        const offsetWin = offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(offsetParent) ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(offsetParent) : offsetParent;\n        let currentIFrame = win.frameElement;\n        while(currentIFrame && offsetParent && offsetWin !== win){\n            const iframeScale = getScale(currentIFrame);\n            const iframeRect = currentIFrame.getBoundingClientRect();\n            const css = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(currentIFrame);\n            const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n            const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n            x *= iframeScale.x;\n            y *= iframeScale.y;\n            width *= iframeScale.x;\n            height *= iframeScale.y;\n            x += left;\n            y += top;\n            currentIFrame = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(currentIFrame).frameElement;\n        }\n    }\n    return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.rectToClientRect)({\n        width,\n        height,\n        x,\n        y\n    });\n}\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n    let { rect, offsetParent, strategy } = _ref;\n    const isOffsetParentAnElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent);\n    const documentElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(offsetParent);\n    if (offsetParent === documentElement) {\n        return rect;\n    }\n    let scroll = {\n        scrollLeft: 0,\n        scrollTop: 0\n    };\n    let scale = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(1);\n    const offsets = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(0);\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== \"fixed\") {\n        if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(offsetParent) !== \"body\" || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isOverflowElement)(documentElement)) {\n            scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeScroll)(offsetParent);\n        }\n        if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent)) {\n            const offsetRect = getBoundingClientRect(offsetParent);\n            scale = getScale(offsetParent);\n            offsets.x = offsetRect.x + offsetParent.clientLeft;\n            offsets.y = offsetRect.y + offsetParent.clientTop;\n        }\n    }\n    return {\n        width: rect.width * scale.x,\n        height: rect.height * scale.y,\n        x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n        y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n    };\n}\nfunction getClientRects(element) {\n    return Array.from(element.getClientRects());\n}\nfunction getWindowScrollBarX(element) {\n    // If <html> has a CSS width greater than the viewport, then this will be\n    // incorrect for RTL.\n    return getBoundingClientRect((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element)).left + (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeScroll)(element).scrollLeft;\n}\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n    const html = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element);\n    const scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeScroll)(element);\n    const body = element.ownerDocument.body;\n    const width = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n    const height = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n    let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n    const y = -scroll.scrollTop;\n    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(body).direction === \"rtl\") {\n        x += (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(html.clientWidth, body.clientWidth) - width;\n    }\n    return {\n        width,\n        height,\n        x,\n        y\n    };\n}\nfunction getViewportRect(element, strategy) {\n    const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(element);\n    const html = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element);\n    const visualViewport = win.visualViewport;\n    let width = html.clientWidth;\n    let height = html.clientHeight;\n    let x = 0;\n    let y = 0;\n    if (visualViewport) {\n        width = visualViewport.width;\n        height = visualViewport.height;\n        const visualViewportBased = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isWebKit)();\n        if (!visualViewportBased || visualViewportBased && strategy === \"fixed\") {\n            x = visualViewport.offsetLeft;\n            y = visualViewport.offsetTop;\n        }\n    }\n    return {\n        width,\n        height,\n        x,\n        y\n    };\n}\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n    const clientRect = getBoundingClientRect(element, true, strategy === \"fixed\");\n    const top = clientRect.top + element.clientTop;\n    const left = clientRect.left + element.clientLeft;\n    const scale = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element) ? getScale(element) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(1);\n    const width = element.clientWidth * scale.x;\n    const height = element.clientHeight * scale.y;\n    const x = left * scale.x;\n    const y = top * scale.y;\n    return {\n        width,\n        height,\n        x,\n        y\n    };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n    let rect;\n    if (clippingAncestor === \"viewport\") {\n        rect = getViewportRect(element, strategy);\n    } else if (clippingAncestor === \"document\") {\n        rect = getDocumentRect((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element));\n    } else if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(clippingAncestor)) {\n        rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n    } else {\n        const visualOffsets = getVisualOffsets(element);\n        rect = {\n            ...clippingAncestor,\n            x: clippingAncestor.x - visualOffsets.x,\n            y: clippingAncestor.y - visualOffsets.y\n        };\n    }\n    return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.rectToClientRect)(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n    const parentNode = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getParentNode)(element);\n    if (parentNode === stopNode || !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(parentNode) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isLastTraversableNode)(parentNode)) {\n        return false;\n    }\n    return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(parentNode).position === \"fixed\" || hasFixedPositionAncestor(parentNode, stopNode);\n}\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n    const cachedResult = cache.get(element);\n    if (cachedResult) {\n        return cachedResult;\n    }\n    let result = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors)(element, [], false).filter((el)=>(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(el) && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(el) !== \"body\");\n    let currentContainingBlockComputedStyle = null;\n    const elementIsFixed = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element).position === \"fixed\";\n    let currentNode = elementIsFixed ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getParentNode)(element) : element;\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n    while((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement)(currentNode) && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isLastTraversableNode)(currentNode)){\n        const computedStyle = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(currentNode);\n        const currentNodeIsContaining = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isContainingBlock)(currentNode);\n        if (!currentNodeIsContaining && computedStyle.position === \"fixed\") {\n            currentContainingBlockComputedStyle = null;\n        }\n        const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === \"static\" && !!currentContainingBlockComputedStyle && [\n            \"absolute\",\n            \"fixed\"\n        ].includes(currentContainingBlockComputedStyle.position) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isOverflowElement)(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n        if (shouldDropCurrentNode) {\n            // Drop non-containing blocks.\n            result = result.filter((ancestor)=>ancestor !== currentNode);\n        } else {\n            // Record last containing block for next iteration.\n            currentContainingBlockComputedStyle = computedStyle;\n        }\n        currentNode = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getParentNode)(currentNode);\n    }\n    cache.set(element, result);\n    return result;\n}\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n    let { element, boundary, rootBoundary, strategy } = _ref;\n    const elementClippingAncestors = boundary === \"clippingAncestors\" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n    const clippingAncestors = [\n        ...elementClippingAncestors,\n        rootBoundary\n    ];\n    const firstClippingAncestor = clippingAncestors[0];\n    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor)=>{\n        const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n        accRect.top = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(rect.top, accRect.top);\n        accRect.right = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.min)(rect.right, accRect.right);\n        accRect.bottom = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.min)(rect.bottom, accRect.bottom);\n        accRect.left = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(rect.left, accRect.left);\n        return accRect;\n    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n    return {\n        width: clippingRect.right - clippingRect.left,\n        height: clippingRect.bottom - clippingRect.top,\n        x: clippingRect.left,\n        y: clippingRect.top\n    };\n}\nfunction getDimensions(element) {\n    return getCssDimensions(element);\n}\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n    const isOffsetParentAnElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent);\n    const documentElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(offsetParent);\n    const isFixed = strategy === \"fixed\";\n    const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n    let scroll = {\n        scrollLeft: 0,\n        scrollTop: 0\n    };\n    const offsets = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.createCoords)(0);\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n        if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(offsetParent) !== \"body\" || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isOverflowElement)(documentElement)) {\n            scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeScroll)(offsetParent);\n        }\n        if (isOffsetParentAnElement) {\n            const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n            offsets.x = offsetRect.x + offsetParent.clientLeft;\n            offsets.y = offsetRect.y + offsetParent.clientTop;\n        } else if (documentElement) {\n            offsets.x = getWindowScrollBarX(documentElement);\n        }\n    }\n    return {\n        x: rect.left + scroll.scrollLeft - offsets.x,\n        y: rect.top + scroll.scrollTop - offsets.y,\n        width: rect.width,\n        height: rect.height\n    };\n}\nfunction getTrueOffsetParent(element, polyfill) {\n    if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element).position === \"fixed\") {\n        return null;\n    }\n    if (polyfill) {\n        return polyfill(element);\n    }\n    return element.offsetParent;\n}\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n    const window = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getWindow)(element);\n    if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element)) {\n        return window;\n    }\n    let offsetParent = getTrueOffsetParent(element, polyfill);\n    while(offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isTableElement)(offsetParent) && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(offsetParent).position === \"static\"){\n        offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n    }\n    if (offsetParent && ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(offsetParent) === \"html\" || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getNodeName)(offsetParent) === \"body\" && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(offsetParent).position === \"static\" && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isContainingBlock)(offsetParent))) {\n        return window;\n    }\n    return offsetParent || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getContainingBlock)(element) || window;\n}\nconst getElementRects = async function(_ref) {\n    let { reference, floating, strategy } = _ref;\n    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n    const getDimensionsFn = this.getDimensions;\n    return {\n        reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n        floating: {\n            x: 0,\n            y: 0,\n            ...await getDimensionsFn(floating)\n        }\n    };\n};\nfunction isRTL(element) {\n    return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getComputedStyle)(element).direction === \"rtl\";\n}\nconst platform = {\n    convertOffsetParentRelativeRectToViewportRelativeRect,\n    getDocumentElement: _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement,\n    getClippingRect,\n    getOffsetParent,\n    getElementRects,\n    getClientRects,\n    getDimensions,\n    getScale,\n    isElement: _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isElement,\n    isRTL\n};\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n    let io = null;\n    let timeoutId;\n    const root = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getDocumentElement)(element);\n    function cleanup() {\n        clearTimeout(timeoutId);\n        io && io.disconnect();\n        io = null;\n    }\n    function refresh(skip, threshold) {\n        if (skip === void 0) {\n            skip = false;\n        }\n        if (threshold === void 0) {\n            threshold = 1;\n        }\n        cleanup();\n        const { left, top, width, height } = element.getBoundingClientRect();\n        if (!skip) {\n            onMove();\n        }\n        if (!width || !height) {\n            return;\n        }\n        const insetTop = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(top);\n        const insetRight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(root.clientWidth - (left + width));\n        const insetBottom = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(root.clientHeight - (top + height));\n        const insetLeft = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(left);\n        const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n        const options = {\n            rootMargin,\n            threshold: (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.max)(0, (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.min)(1, threshold)) || 1\n        };\n        let isFirstUpdate = true;\n        function handleObserve(entries) {\n            const ratio = entries[0].intersectionRatio;\n            if (ratio !== threshold) {\n                if (!isFirstUpdate) {\n                    return refresh();\n                }\n                if (!ratio) {\n                    timeoutId = setTimeout(()=>{\n                        refresh(false, 1e-7);\n                    }, 100);\n                } else {\n                    refresh(false, ratio);\n                }\n            }\n            isFirstUpdate = false;\n        }\n        // Older browsers don't support a `document` as the root and will throw an\n        // error.\n        try {\n            io = new IntersectionObserver(handleObserve, {\n                ...options,\n                // Handle <iframe>s\n                root: root.ownerDocument\n            });\n        } catch (e) {\n            io = new IntersectionObserver(handleObserve, options);\n        }\n        io.observe(element);\n    }\n    refresh(true);\n    return cleanup;\n}\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */ function autoUpdate(reference, floating, update, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { ancestorScroll = true, ancestorResize = true, elementResize = typeof ResizeObserver === \"function\", layoutShift = typeof IntersectionObserver === \"function\", animationFrame = false } = options;\n    const referenceEl = unwrapElement(reference);\n    const ancestors = ancestorScroll || ancestorResize ? [\n        ...referenceEl ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors)(referenceEl) : [],\n        ...(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors)(floating)\n    ] : [];\n    ancestors.forEach((ancestor)=>{\n        ancestorScroll && ancestor.addEventListener(\"scroll\", update, {\n            passive: true\n        });\n        ancestorResize && ancestor.addEventListener(\"resize\", update);\n    });\n    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n    let reobserveFrame = -1;\n    let resizeObserver = null;\n    if (elementResize) {\n        resizeObserver = new ResizeObserver((_ref)=>{\n            let [firstEntry] = _ref;\n            if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n                // Prevent update loops when using the `size` middleware.\n                // https://github.com/floating-ui/floating-ui/issues/1740\n                resizeObserver.unobserve(floating);\n                cancelAnimationFrame(reobserveFrame);\n                reobserveFrame = requestAnimationFrame(()=>{\n                    resizeObserver && resizeObserver.observe(floating);\n                });\n            }\n            update();\n        });\n        if (referenceEl && !animationFrame) {\n            resizeObserver.observe(referenceEl);\n        }\n        resizeObserver.observe(floating);\n    }\n    let frameId;\n    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n    if (animationFrame) {\n        frameLoop();\n    }\n    function frameLoop() {\n        const nextRefRect = getBoundingClientRect(reference);\n        if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n            update();\n        }\n        prevRefRect = nextRefRect;\n        frameId = requestAnimationFrame(frameLoop);\n    }\n    update();\n    return ()=>{\n        ancestors.forEach((ancestor)=>{\n            ancestorScroll && ancestor.removeEventListener(\"scroll\", update);\n            ancestorResize && ancestor.removeEventListener(\"resize\", update);\n        });\n        cleanupIo && cleanupIo();\n        resizeObserver && resizeObserver.disconnect();\n        resizeObserver = null;\n        if (animationFrame) {\n            cancelAnimationFrame(frameId);\n        }\n    };\n}\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */ const computePosition = (reference, floating, options)=>{\n    // This caches the expensive `getClippingElementAncestors` function so that\n    // multiple lifecycle resets re-use the same result. It only lives for a\n    // single call. If other functions become expensive, we can add them as well.\n    const cache = new Map();\n    const mergedOptions = {\n        platform,\n        ...options\n    };\n    const platformWithCache = {\n        ...mergedOptions.platform,\n        _c: cache\n    };\n    return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_0__.computePosition)(reference, floating, {\n        ...mergedOptions,\n        platform: platformWithCache\n    });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2RvbS9kaXN0L2Zsb2F0aW5nLXVpLmRvbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMkY7QUFDbUM7QUFDcEQ7QUFDcU47QUFDak87QUFFOUQsU0FBU2lDLGlCQUFpQkMsT0FBTztJQUMvQixNQUFNQyxNQUFNakIsd0VBQWdCQSxDQUFDZ0I7SUFDN0IseUVBQXlFO0lBQ3pFLHlFQUF5RTtJQUN6RSxJQUFJRSxRQUFRQyxXQUFXRixJQUFJQyxLQUFLLEtBQUs7SUFDckMsSUFBSUUsU0FBU0QsV0FBV0YsSUFBSUcsTUFBTSxLQUFLO0lBQ3ZDLE1BQU1DLFlBQVlwQixxRUFBYUEsQ0FBQ2U7SUFDaEMsTUFBTU0sY0FBY0QsWUFBWUwsUUFBUU0sV0FBVyxHQUFHSjtJQUN0RCxNQUFNSyxlQUFlRixZQUFZTCxRQUFRTyxZQUFZLEdBQUdIO0lBQ3hELE1BQU1JLGlCQUFpQjdCLHlEQUFLQSxDQUFDdUIsV0FBV0ksZUFBZTNCLHlEQUFLQSxDQUFDeUIsWUFBWUc7SUFDekUsSUFBSUMsZ0JBQWdCO1FBQ2xCTixRQUFRSTtRQUNSRixTQUFTRztJQUNYO0lBQ0EsT0FBTztRQUNMTDtRQUNBRTtRQUNBSyxHQUFHRDtJQUNMO0FBQ0Y7QUFFQSxTQUFTRSxjQUFjVixPQUFPO0lBQzVCLE9BQU8sQ0FBQ2QsaUVBQVNBLENBQUNjLFdBQVdBLFFBQVFXLGNBQWMsR0FBR1g7QUFDeEQ7QUFFQSxTQUFTWSxTQUFTWixPQUFPO0lBQ3ZCLE1BQU1hLGFBQWFILGNBQWNWO0lBQ2pDLElBQUksQ0FBQ2YscUVBQWFBLENBQUM0QixhQUFhO1FBQzlCLE9BQU9qQyxnRUFBWUEsQ0FBQztJQUN0QjtJQUNBLE1BQU1rQyxPQUFPRCxXQUFXRSxxQkFBcUI7SUFDN0MsTUFBTSxFQUNKYixLQUFLLEVBQ0xFLE1BQU0sRUFDTkssQ0FBQyxFQUNGLEdBQUdWLGlCQUFpQmM7SUFDckIsSUFBSUcsSUFBSSxDQUFDUCxJ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M0Usd0VBQXdFO0lBQ3hFLDZFQUE2RTtJQUM3RSxNQUFNekQsUUFBUSxJQUFJNkY7SUFDbEIsTUFBTUMsZ0JBQWdCO1FBQ3BCdEQ7UUFDQSxHQUFHaUIsT0FBTztJQUNaO0lBQ0EsTUFBTXNDLG9CQUFvQjtRQUN4QixHQUFHRCxjQUFjdEQsUUFBUTtRQUN6QnJCLElBQUluQjtJQUNOO0lBQ0EsT0FBTy9HLGtFQUFpQkEsQ0FBQ2tKLFdBQVdDLFVBQVU7UUFDNUMsR0FBRzBELGFBQWE7UUFDaEJ0RCxVQUFVdUQ7SUFDWjtBQUNGO0FBRWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLWFwcC8uL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvZG9tL2Rpc3QvZmxvYXRpbmctdWkuZG9tLm1qcz8zZmEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlY3RUb0NsaWVudFJlY3QsIGNvbXB1dGVQb3NpdGlvbiBhcyBjb21wdXRlUG9zaXRpb24kMSB9IGZyb20gJ0BmbG9hdGluZy11aS9jb3JlJztcbmV4cG9ydCB7IGFycm93LCBhdXRvUGxhY2VtZW50LCBkZXRlY3RPdmVyZmxvdywgZmxpcCwgaGlkZSwgaW5saW5lLCBsaW1pdFNoaWZ0LCBvZmZzZXQsIHNoaWZ0LCBzaXplIH0gZnJvbSAnQGZsb2F0aW5nLXVpL2NvcmUnO1xuaW1wb3J0IHsgcm91bmQsIGNyZWF0ZUNvb3JkcywgbWF4LCBtaW4sIGZsb29yIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzJztcbmltcG9ydCB7IGdldENvbXB1dGVkU3R5bGUsIGlzSFRNTEVsZW1lbnQsIGlzRWxlbWVudCwgZ2V0V2luZG93LCBpc1dlYktpdCwgZ2V0RG9jdW1lbnRFbGVtZW50LCBnZXROb2RlTmFtZSwgaXNPdmVyZmxvd0VsZW1lbnQsIGdldE5vZGVTY3JvbGwsIGdldE92ZXJmbG93QW5jZXN0b3JzLCBnZXRQYXJlbnROb2RlLCBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUsIGlzQ29udGFpbmluZ0Jsb2NrLCBpc1RhYmxlRWxlbWVudCwgZ2V0Q29udGFpbmluZ0Jsb2NrIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzL2RvbSc7XG5leHBvcnQgeyBnZXRPdmVyZmxvd0FuY2VzdG9ycyB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscy9kb20nO1xuXG5mdW5jdGlvbiBnZXRDc3NEaW1lbnNpb25zKGVsZW1lbnQpIHtcbiAgY29uc3QgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgLy8gSW4gdGVzdGluZyBlbnZpcm9ubWVudHMsIHRoZSBgd2lkdGhgIGFuZCBgaGVpZ2h0YCBwcm9wZXJ0aWVzIGFyZSBlbXB0eVxuICAvLyBzdHJpbmdzIGZvciBTVkcgZWxlbWVudHMsIHJldHVybmluZyBOYU4uIEZhbGxiYWNrIHRvIGAwYCBpbiB0aGlzIGNhc2UuXG4gIGxldCB3aWR0aCA9IHBhcnNlRmxvYXQoY3NzLndpZHRoKSB8fCAwO1xuICBsZXQgaGVpZ2h0ID0gcGFyc2VGbG9hdChjc3MuaGVpZ2h0KSB8fCAwO1xuICBjb25zdCBoYXNPZmZzZXQgPSBpc0hUTUxFbGVtZW50KGVsZW1lbnQpO1xuICBjb25zdCBvZmZzZXRXaWR0aCA9IGhhc09mZnNldCA/IGVsZW1lbnQub2Zmc2V0V2lkdGggOiB3aWR0aDtcbiAgY29uc3Qgb2Zmc2V0SGVpZ2h0ID0gaGFzT2Zmc2V0ID8gZWxlbWVudC5vZmZzZXRIZWlnaHQgOiBoZWlnaHQ7XG4gIGNvbnN0IHNob3VsZEZhbGxiYWNrID0gcm91bmQod2lkdGgpICE9PSBvZmZzZXRXaWR0aCB8fCByb3VuZChoZWlnaHQpICE9PSBvZmZzZXRIZWlnaHQ7XG4gIGlmIChzaG91bGRGYWxsYmFjaykge1xuICAgIHdpZHRoID0gb2Zmc2V0V2lkdGg7XG4gICAgaGVpZ2h0ID0gb2Zmc2V0SGVpZ2h0O1xuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgICQ6IHNob3VsZEZhbGxiYWNrXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVud3JhcEVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gIWlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgOiBlbGVtZW50O1xufVxuXG5mdW5jdGlvbiBnZXRTY2FsZShlbGVtZW50KSB7XG4gIGNvbnN0IGRvbUVsZW1lbnQgPSB1bndyYXBFbGVtZW50KGVsZW1lbnQpO1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZG9tRWxlbWVudCkpIHtcbiAgICByZXR1cm4gY3JlYXRlQ29vcmRzKDEpO1xuICB9XG4gIGNvbnN0IHJlY3QgPSBkb21FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgICRcbiAgfSA9IGdldENzc0RpbWVuc2lvbnMoZG9tRWxlbWVudCk7XG4gIGxldCB4ID0gKCQgPyByb3VuZChyZWN0LndpZHRoKSA6IHJlY3Qud2lkdGgpIC8gd2lkdGg7XG4gIGxldCB5ID0gKCQgPyByb3VuZChyZWN0LmhlaWdodCkgOiByZWN0LmhlaWdodCkgLyBoZWlnaHQ7XG5cbiAgLy8gMCwgTmFOLCBvciBJbmZpbml0eSBzaG91bGQgYWx3YXlzIGZhbGxiYWNrIHRvIDEuXG5cbiAgaWYgKCF4IHx8ICFOdW1iZXIuaXNGaW5pdGUoeCkpIHtcbiAgICB4ID0gMTtcbiAgfVxuICBpZiAoIXkgfHwgIU51bWJlci5pc0Zpbml0ZSh5KSkge1xuICAgIHkgPSAxO1xuICB9XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbmNvbnN0IG5vT2Zmc2V0cyA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb29yZHMoMCk7XG5mdW5jdGlvbiBnZXRWaXN1YWxPZmZzZXRzKGVsZW1lbnQpIHtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICBpZiAoIWlzV2ViS2l0KCkgfHwgIXdpbi52aXN1YWxWaWV3cG9ydCkge1xuICAgIHJldHVybiBub09mZnNldHM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiB3aW4udmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdCxcbiAgICB5OiB3aW4udmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wXG4gIH07XG59XG5mdW5jdGlvbiBzaG91bGRBZGRWaXN1YWxPZmZzZXRzKGVsZW1lbnQsIGlzRml4ZWQsIGZsb2F0aW5nT2Zmc2V0UGFyZW50KSB7XG4gIGlmIChpc0ZpeGVkID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkID0gZmFsc2U7XG4gIH1cbiAgaWYgKCFmbG9hdGluZ09mZnNldFBhcmVudCB8fCBpc0ZpeGVkICYmIGZsb2F0aW5nT2Zmc2V0UGFyZW50ICE9PSBnZXRXaW5kb3coZWxlbWVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzRml4ZWQ7XG59XG5cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBpbmNsdWRlU2NhbGUsIGlzRml4ZWRTdHJhdGVneSwgb2Zmc2V0UGFyZW50KSB7XG4gIGlmIChpbmNsdWRlU2NhbGUgPT09IHZvaWQgMCkge1xuICAgIGluY2x1ZGVTY2FsZSA9IGZhbHNlO1xuICB9XG4gIGlmIChpc0ZpeGVkU3RyYXRlZ3kgPT09IHZvaWQgMCkge1xuICAgIGlzRml4ZWRTdHJhdGVneSA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGNsaWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCBkb21FbGVtZW50ID0gdW53cmFwRWxlbWVudChlbGVtZW50KTtcbiAgbGV0IHNjYWxlID0gY3JlYXRlQ29vcmRzKDEpO1xuICBpZiAoaW5jbHVkZVNjYWxlKSB7XG4gICAgaWYgKG9mZnNldFBhcmVudCkge1xuICAgICAgaWYgKGlzRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICAgIHNjYWxlID0gZ2V0U2NhbGUob2Zmc2V0UGFyZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGUgPSBnZXRTY2FsZShlbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdmlzdWFsT2Zmc2V0cyA9IHNob3VsZEFkZFZpc3VhbE9mZnNldHMoZG9tRWxlbWVudCwgaXNGaXhlZFN0cmF0ZWd5LCBvZmZzZXRQYXJlbnQpID8gZ2V0VmlzdWFsT2Zmc2V0cyhkb21FbGVtZW50KSA6IGNyZWF0ZUNvb3JkcygwKTtcbiAgbGV0IHggPSAoY2xpZW50UmVjdC5sZWZ0ICsgdmlzdWFsT2Zmc2V0cy54KSAvIHNjYWxlLng7XG4gIGxldCB5ID0gKGNsaWVudFJlY3QudG9wICsgdmlzdWFsT2Zmc2V0cy55KSAvIHNjYWxlLnk7XG4gIGxldCB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGggLyBzY2FsZS54O1xuICBsZXQgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQgLyBzY2FsZS55O1xuICBpZiAoZG9tRWxlbWVudCkge1xuICAgIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhkb21FbGVtZW50KTtcbiAgICBjb25zdCBvZmZzZXRXaW4gPSBvZmZzZXRQYXJlbnQgJiYgaXNFbGVtZW50KG9mZnNldFBhcmVudCkgPyBnZXRXaW5kb3cob2Zmc2V0UGFyZW50KSA6IG9mZnNldFBhcmVudDtcbiAgICBsZXQgY3VycmVudElGcmFtZSA9IHdpbi5mcmFtZUVsZW1lbnQ7XG4gICAgd2hpbGUgKGN1cnJlbnRJRnJhbWUgJiYgb2Zmc2V0UGFyZW50ICYmIG9mZnNldFdpbiAhPT0gd2luKSB7XG4gICAgICBjb25zdCBpZnJhbWVTY2FsZSA9IGdldFNjYWxlKGN1cnJlbnRJRnJhbWUpO1xuICAgICAgY29uc3QgaWZyYW1lUmVjdCA9IGN1cnJlbnRJRnJhbWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnRJRnJhbWUpO1xuICAgICAgY29uc3QgbGVmdCA9IGlmcmFtZVJlY3QubGVmdCArIChjdXJyZW50SUZyYW1lLmNsaWVudExlZnQgKyBwYXJzZUZsb2F0KGNzcy5wYWRkaW5nTGVmdCkpICogaWZyYW1lU2NhbGUueDtcbiAgICAgIGNvbnN0IHRvcCA9IGlmcmFtZVJlY3QudG9wICsgKGN1cnJlbnRJRnJhbWUuY2xpZW50VG9wICsgcGFyc2VGbG9hdChjc3MucGFkZGluZ1RvcCkpICogaWZyYW1lU2NhbGUueTtcbiAgICAgIHggKj0gaWZyYW1lU2NhbGUueDtcbiAgICAgIHkgKj0gaWZyYW1lU2NhbGUueTtcbiAgICAgIHdpZHRoICo9IGlmcmFtZVNjYWxlLng7XG4gICAgICBoZWlnaHQgKj0gaWZyYW1lU2NhbGUueTtcbiAgICAgIHggKz0gbGVmdDtcbiAgICAgIHkgKz0gdG9wO1xuICAgICAgY3VycmVudElGcmFtZSA9IGdldFdpbmRvdyhjdXJyZW50SUZyYW1lKS5mcmFtZUVsZW1lbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZWN0VG9DbGllbnRSZWN0KHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdChfcmVmKSB7XG4gIGxldCB7XG4gICAgcmVjdCxcbiAgICBvZmZzZXRQYXJlbnQsXG4gICAgc3RyYXRlZ3lcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgaWYgKG9mZnNldFBhcmVudCA9PT0gZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcmV0dXJuIHJlY3Q7XG4gIH1cbiAgbGV0IHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICBsZXQgc2NhbGUgPSBjcmVhdGVDb29yZHMoMSk7XG4gIGNvbnN0IG9mZnNldHMgPSBjcmVhdGVDb29yZHMoMCk7XG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgc3RyYXRlZ3kgIT09ICdmaXhlZCcpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IGlzT3ZlcmZsb3dFbGVtZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG4gICAgaWYgKGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgY29uc3Qgb2Zmc2V0UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQpO1xuICAgICAgc2NhbGUgPSBnZXRTY2FsZShvZmZzZXRQYXJlbnQpO1xuICAgICAgb2Zmc2V0cy54ID0gb2Zmc2V0UmVjdC54ICsgb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgPSBvZmZzZXRSZWN0LnkgKyBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoOiByZWN0LndpZHRoICogc2NhbGUueCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0ICogc2NhbGUueSxcbiAgICB4OiByZWN0LnggKiBzY2FsZS54IC0gc2Nyb2xsLnNjcm9sbExlZnQgKiBzY2FsZS54ICsgb2Zmc2V0cy54LFxuICAgIHk6IHJlY3QueSAqIHNjYWxlLnkgLSBzY3JvbGwuc2Nyb2xsVG9wICogc2NhbGUueSArIG9mZnNldHMueVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0cyhlbGVtZW50KSB7XG4gIHJldHVybiBBcnJheS5mcm9tKGVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKSk7XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCkge1xuICAvLyBJZiA8aHRtbD4gaGFzIGEgQ1NTIHdpZHRoIGdyZWF0ZXIgdGhhbiB0aGUgdmlld3BvcnQsIHRoZW4gdGhpcyB3aWxsIGJlXG4gIC8vIGluY29ycmVjdCBmb3IgUlRMLlxuICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkubGVmdCArIGdldE5vZGVTY3JvbGwoZWxlbWVudCkuc2Nyb2xsTGVmdDtcbn1cblxuLy8gR2V0cyB0aGUgZW50aXJlIHNpemUgb2YgdGhlIHNjcm9sbGFibGUgZG9jdW1lbnQgYXJlYSwgZXZlbiBleHRlbmRpbmcgb3V0c2lkZVxuLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZS5cbmZ1bmN0aW9uIGdldERvY3VtZW50UmVjdChlbGVtZW50KSB7XG4gIGNvbnN0IGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIGNvbnN0IHNjcm9sbCA9IGdldE5vZGVTY3JvbGwoZWxlbWVudCk7XG4gIGNvbnN0IGJvZHkgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcbiAgY29uc3Qgd2lkdGggPSBtYXgoaHRtbC5zY3JvbGxXaWR0aCwgaHRtbC5jbGllbnRXaWR0aCwgYm9keS5zY3JvbGxXaWR0aCwgYm9keS5jbGllbnRXaWR0aCk7XG4gIGNvbnN0IGhlaWdodCA9IG1heChodG1sLnNjcm9sbEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQsIGJvZHkuc2Nyb2xsSGVpZ2h0LCBib2R5LmNsaWVudEhlaWdodCk7XG4gIGxldCB4ID0gLXNjcm9sbC5zY3JvbGxMZWZ0ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KTtcbiAgY29uc3QgeSA9IC1zY3JvbGwuc2Nyb2xsVG9wO1xuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShib2R5KS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgeCArPSBtYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keS5jbGllbnRXaWR0aCkgLSB3aWR0aDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgY29uc3QgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgY29uc3QgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gIGxldCB3aWR0aCA9IGh0bWwuY2xpZW50V2lkdGg7XG4gIGxldCBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgbGV0IHggPSAwO1xuICBsZXQgeSA9IDA7XG4gIGlmICh2aXN1YWxWaWV3cG9ydCkge1xuICAgIHdpZHRoID0gdmlzdWFsVmlld3BvcnQud2lkdGg7XG4gICAgaGVpZ2h0ID0gdmlzdWFsVmlld3BvcnQuaGVpZ2h0O1xuICAgIGNvbnN0IHZpc3VhbFZpZXdwb3J0QmFzZWQgPSBpc1dlYktpdCgpO1xuICAgIGlmICghdmlzdWFsVmlld3BvcnRCYXNlZCB8fCB2aXN1YWxWaWV3cG9ydEJhc2VkICYmIHN0cmF0ZWd5ID09PSAnZml4ZWQnKSB7XG4gICAgICB4ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdDtcbiAgICAgIHkgPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3A7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG4vLyBSZXR1cm5zIHRoZSBpbm5lciBjbGllbnQgcmVjdCwgc3VidHJhY3Rpbmcgc2Nyb2xsYmFycyBpZiBwcmVzZW50LlxuZnVuY3Rpb24gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcbiAgY29uc3QgY2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCB0cnVlLCBzdHJhdGVneSA9PT0gJ2ZpeGVkJyk7XG4gIGNvbnN0IHRvcCA9IGNsaWVudFJlY3QudG9wICsgZWxlbWVudC5jbGllbnRUb3A7XG4gIGNvbnN0IGxlZnQgPSBjbGllbnRSZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudExlZnQ7XG4gIGNvbnN0IHNjYWxlID0gaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldFNjYWxlKGVsZW1lbnQpIDogY3JlYXRlQ29vcmRzKDEpO1xuICBjb25zdCB3aWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGggKiBzY2FsZS54O1xuICBjb25zdCBoZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodCAqIHNjYWxlLnk7XG4gIGNvbnN0IHggPSBsZWZ0ICogc2NhbGUueDtcbiAgY29uc3QgeSA9IHRvcCAqIHNjYWxlLnk7XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yKGVsZW1lbnQsIGNsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KSB7XG4gIGxldCByZWN0O1xuICBpZiAoY2xpcHBpbmdBbmNlc3RvciA9PT0gJ3ZpZXdwb3J0Jykge1xuICAgIHJlY3QgPSBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpO1xuICB9IGVsc2UgaWYgKGNsaXBwaW5nQW5jZXN0b3IgPT09ICdkb2N1bWVudCcpIHtcbiAgICByZWN0ID0gZ2V0RG9jdW1lbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSk7XG4gIH0gZWxzZSBpZiAoaXNFbGVtZW50KGNsaXBwaW5nQW5jZXN0b3IpKSB7XG4gICAgcmVjdCA9IGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGNsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB2aXN1YWxPZmZzZXRzID0gZ2V0VmlzdWFsT2Zmc2V0cyhlbGVtZW50KTtcbiAgICByZWN0ID0ge1xuICAgICAgLi4uY2xpcHBpbmdBbmNlc3RvcixcbiAgICAgIHg6IGNsaXBwaW5nQW5jZXN0b3IueCAtIHZpc3VhbE9mZnNldHMueCxcbiAgICAgIHk6IGNsaXBwaW5nQW5jZXN0b3IueSAtIHZpc3VhbE9mZnNldHMueVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHJlY3RUb0NsaWVudFJlY3QocmVjdCk7XG59XG5mdW5jdGlvbiBoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IoZWxlbWVudCwgc3RvcE5vZGUpIHtcbiAgY29uc3QgcGFyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gIGlmIChwYXJlbnROb2RlID09PSBzdG9wTm9kZSB8fCAhaXNFbGVtZW50KHBhcmVudE5vZGUpIHx8IGlzTGFzdFRyYXZlcnNhYmxlTm9kZShwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnROb2RlKS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJyB8fCBoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IocGFyZW50Tm9kZSwgc3RvcE5vZGUpO1xufVxuXG4vLyBBIFwiY2xpcHBpbmcgYW5jZXN0b3JcIiBpcyBhbiBgb3ZlcmZsb3dgIGVsZW1lbnQgd2l0aCB0aGUgY2hhcmFjdGVyaXN0aWMgb2Zcbi8vIGNsaXBwaW5nIChvciBoaWRpbmcpIGNoaWxkIGVsZW1lbnRzLiBUaGlzIHJldHVybnMgYWxsIGNsaXBwaW5nIGFuY2VzdG9yc1xuLy8gb2YgdGhlIGdpdmVuIGVsZW1lbnQgdXAgdGhlIHRyZWUuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ0VsZW1lbnRBbmNlc3RvcnMoZWxlbWVudCwgY2FjaGUpIHtcbiAgY29uc3QgY2FjaGVkUmVzdWx0ID0gY2FjaGUuZ2V0KGVsZW1lbnQpO1xuICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgcmV0dXJuIGNhY2hlZFJlc3VsdDtcbiAgfVxuICBsZXQgcmVzdWx0ID0gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoZWxlbWVudCwgW10sIGZhbHNlKS5maWx0ZXIoZWwgPT4gaXNFbGVtZW50KGVsKSAmJiBnZXROb2RlTmFtZShlbCkgIT09ICdib2R5Jyk7XG4gIGxldCBjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA9IG51bGw7XG4gIGNvbnN0IGVsZW1lbnRJc0ZpeGVkID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJztcbiAgbGV0IGN1cnJlbnROb2RlID0gZWxlbWVudElzRml4ZWQgPyBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIDogZWxlbWVudDtcblxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xuICB3aGlsZSAoaXNFbGVtZW50KGN1cnJlbnROb2RlKSAmJiAhaXNMYXN0VHJhdmVyc2FibGVOb2RlKGN1cnJlbnROb2RlKSkge1xuICAgIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnROb2RlKTtcbiAgICBjb25zdCBjdXJyZW50Tm9kZUlzQ29udGFpbmluZyA9IGlzQ29udGFpbmluZ0Jsb2NrKGN1cnJlbnROb2RlKTtcbiAgICBpZiAoIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmIGNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICAgIGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc2hvdWxkRHJvcEN1cnJlbnROb2RlID0gZWxlbWVudElzRml4ZWQgPyAhY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgJiYgIWN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlIDogIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmIGNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09ICdzdGF0aWMnICYmICEhY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgJiYgWydhYnNvbHV0ZScsICdmaXhlZCddLmluY2x1ZGVzKGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlLnBvc2l0aW9uKSB8fCBpc092ZXJmbG93RWxlbWVudChjdXJyZW50Tm9kZSkgJiYgIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmIGhhc0ZpeGVkUG9zaXRpb25BbmNlc3RvcihlbGVtZW50LCBjdXJyZW50Tm9kZSk7XG4gICAgaWYgKHNob3VsZERyb3BDdXJyZW50Tm9kZSkge1xuICAgICAgLy8gRHJvcCBub24tY29udGFpbmluZyBibG9ja3MuXG4gICAgICByZXN1bHQgPSByZXN1bHQuZmlsdGVyKGFuY2VzdG9yID0+IGFuY2VzdG9yICE9PSBjdXJyZW50Tm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlY29yZCBsYXN0IGNvbnRhaW5pbmcgYmxvY2sgZm9yIG5leHQgaXRlcmF0aW9uLlxuICAgICAgY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUgPSBjb21wdXRlZFN0eWxlO1xuICAgIH1cbiAgICBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoY3VycmVudE5vZGUpO1xuICB9XG4gIGNhY2hlLnNldChlbGVtZW50LCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBHZXRzIHRoZSBtYXhpbXVtIGFyZWEgdGhhdCB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIGluIGR1ZSB0byBhbnkgbnVtYmVyIG9mXG4vLyBjbGlwcGluZyBhbmNlc3RvcnMuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ1JlY3QoX3JlZikge1xuICBsZXQge1xuICAgIGVsZW1lbnQsXG4gICAgYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5LFxuICAgIHN0cmF0ZWd5XG4gIH0gPSBfcmVmO1xuICBjb25zdCBlbGVtZW50Q2xpcHBpbmdBbmNlc3RvcnMgPSBib3VuZGFyeSA9PT0gJ2NsaXBwaW5nQW5jZXN0b3JzJyA/IGdldENsaXBwaW5nRWxlbWVudEFuY2VzdG9ycyhlbGVtZW50LCB0aGlzLl9jKSA6IFtdLmNvbmNhdChib3VuZGFyeSk7XG4gIGNvbnN0IGNsaXBwaW5nQW5jZXN0b3JzID0gWy4uLmVsZW1lbnRDbGlwcGluZ0FuY2VzdG9ycywgcm9vdEJvdW5kYXJ5XTtcbiAgY29uc3QgZmlyc3RDbGlwcGluZ0FuY2VzdG9yID0gY2xpcHBpbmdBbmNlc3RvcnNbMF07XG4gIGNvbnN0IGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nQW5jZXN0b3JzLnJlZHVjZSgoYWNjUmVjdCwgY2xpcHBpbmdBbmNlc3RvcikgPT4ge1xuICAgIGNvbnN0IHJlY3QgPSBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgY2xpcHBpbmdBbmNlc3Rvciwgc3RyYXRlZ3kpO1xuICAgIGFjY1JlY3QudG9wID0gbWF4KHJlY3QudG9wLCBhY2NSZWN0LnRvcCk7XG4gICAgYWNjUmVjdC5yaWdodCA9IG1pbihyZWN0LnJpZ2h0LCBhY2NSZWN0LnJpZ2h0KTtcbiAgICBhY2NSZWN0LmJvdHRvbSA9IG1pbihyZWN0LmJvdHRvbSwgYWNjUmVjdC5ib3R0b20pO1xuICAgIGFjY1JlY3QubGVmdCA9IG1heChyZWN0LmxlZnQsIGFjY1JlY3QubGVmdCk7XG4gICAgcmV0dXJuIGFjY1JlY3Q7XG4gIH0sIGdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvcihlbGVtZW50LCBmaXJzdENsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KSk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IGNsaXBwaW5nUmVjdC5yaWdodCAtIGNsaXBwaW5nUmVjdC5sZWZ0LFxuICAgIGhlaWdodDogY2xpcHBpbmdSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC50b3AsXG4gICAgeDogY2xpcHBpbmdSZWN0LmxlZnQsXG4gICAgeTogY2xpcHBpbmdSZWN0LnRvcFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXREaW1lbnNpb25zKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldENzc0RpbWVuc2lvbnMoZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIGdldFJlY3RSZWxhdGl2ZVRvT2Zmc2V0UGFyZW50KGVsZW1lbnQsIG9mZnNldFBhcmVudCwgc3RyYXRlZ3kpIHtcbiAgY29uc3QgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCBpc0ZpeGVkID0gc3RyYXRlZ3kgPT09ICdmaXhlZCc7XG4gIGNvbnN0IHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgdHJ1ZSwgaXNGaXhlZCwgb2Zmc2V0UGFyZW50KTtcbiAgbGV0IHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICBjb25zdCBvZmZzZXRzID0gY3JlYXRlQ29vcmRzKDApO1xuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCBpc092ZXJmbG93RWxlbWVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuICAgIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCkge1xuICAgICAgY29uc3Qgb2Zmc2V0UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQsIHRydWUsIGlzRml4ZWQsIG9mZnNldFBhcmVudCk7XG4gICAgICBvZmZzZXRzLnggPSBvZmZzZXRSZWN0LnggKyBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSA9IG9mZnNldFJlY3QueSArIG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIG9mZnNldHMueCA9IGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiByZWN0LmxlZnQgKyBzY3JvbGwuc2Nyb2xsTGVmdCAtIG9mZnNldHMueCxcbiAgICB5OiByZWN0LnRvcCArIHNjcm9sbC5zY3JvbGxUb3AgLSBvZmZzZXRzLnksXG4gICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKSB7XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHBvbHlmaWxsKSB7XG4gICAgcmV0dXJuIHBvbHlmaWxsKGVsZW1lbnQpO1xuICB9XG4gIHJldHVybiBlbGVtZW50Lm9mZnNldFBhcmVudDtcbn1cblxuLy8gR2V0cyB0aGUgY2xvc2VzdCBhbmNlc3RvciBwb3NpdGlvbmVkIGVsZW1lbnQuIEhhbmRsZXMgc29tZSBlZGdlIGNhc2VzLFxuLy8gc3VjaCBhcyB0YWJsZSBhbmNlc3RvcnMgYW5kIGNyb3NzIGJyb3dzZXIgYnVncy5cbmZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50LCBwb2x5ZmlsbCkge1xuICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cbiAgbGV0IG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCwgcG9seWZpbGwpO1xuICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmIGlzVGFibGVFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50LCBwb2x5ZmlsbCk7XG4gIH1cbiAgaWYgKG9mZnNldFBhcmVudCAmJiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2h0bWwnIHx8IGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdib2R5JyAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnICYmICFpc0NvbnRhaW5pbmdCbG9jayhvZmZzZXRQYXJlbnQpKSkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cbiAgcmV0dXJuIG9mZnNldFBhcmVudCB8fCBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkgfHwgd2luZG93O1xufVxuXG5jb25zdCBnZXRFbGVtZW50UmVjdHMgPSBhc3luYyBmdW5jdGlvbiAoX3JlZikge1xuICBsZXQge1xuICAgIHJlZmVyZW5jZSxcbiAgICBmbG9hdGluZyxcbiAgICBzdHJhdGVneVxuICB9ID0gX3JlZjtcbiAgY29uc3QgZ2V0T2Zmc2V0UGFyZW50Rm4gPSB0aGlzLmdldE9mZnNldFBhcmVudCB8fCBnZXRPZmZzZXRQYXJlbnQ7XG4gIGNvbnN0IGdldERpbWVuc2lvbnNGbiA9IHRoaXMuZ2V0RGltZW5zaW9ucztcbiAgcmV0dXJuIHtcbiAgICByZWZlcmVuY2U6IGdldFJlY3RSZWxhdGl2ZVRvT2Zmc2V0UGFyZW50KHJlZmVyZW5jZSwgYXdhaXQgZ2V0T2Zmc2V0UGFyZW50Rm4oZmxvYXRpbmcpLCBzdHJhdGVneSksXG4gICAgZmxvYXRpbmc6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgLi4uKGF3YWl0IGdldERpbWVuc2lvbnNGbihmbG9hdGluZykpXG4gICAgfVxuICB9O1xufTtcblxuZnVuY3Rpb24gaXNSVEwoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5kaXJlY3Rpb24gPT09ICdydGwnO1xufVxuXG5jb25zdCBwbGF0Zm9ybSA9IHtcbiAgY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3QsXG4gIGdldERvY3VtZW50RWxlbWVudCxcbiAgZ2V0Q2xpcHBpbmdSZWN0LFxuICBnZXRPZmZzZXRQYXJlbnQsXG4gIGdldEVsZW1lbnRSZWN0cyxcbiAgZ2V0Q2xpZW50UmVjdHMsXG4gIGdldERpbWVuc2lvbnMsXG4gIGdldFNjYWxlLFxuICBpc0VsZW1lbnQsXG4gIGlzUlRMXG59O1xuXG4vLyBodHRwczovL3NhbXRob3IuYXUvMjAyMS9vYnNlcnZpbmctZG9tL1xuZnVuY3Rpb24gb2JzZXJ2ZU1vdmUoZWxlbWVudCwgb25Nb3ZlKSB7XG4gIGxldCBpbyA9IG51bGw7XG4gIGxldCB0aW1lb3V0SWQ7XG4gIGNvbnN0IHJvb3QgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgaW8gJiYgaW8uZGlzY29ubmVjdCgpO1xuICAgIGlvID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiByZWZyZXNoKHNraXAsIHRocmVzaG9sZCkge1xuICAgIGlmIChza2lwID09PSB2b2lkIDApIHtcbiAgICAgIHNraXAgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRocmVzaG9sZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJlc2hvbGQgPSAxO1xuICAgIH1cbiAgICBjbGVhbnVwKCk7XG4gICAgY29uc3Qge1xuICAgICAgbGVmdCxcbiAgICAgIHRvcCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKCFza2lwKSB7XG4gICAgICBvbk1vdmUoKTtcbiAgICB9XG4gICAgaWYgKCF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluc2V0VG9wID0gZmxvb3IodG9wKTtcbiAgICBjb25zdCBpbnNldFJpZ2h0ID0gZmxvb3Iocm9vdC5jbGllbnRXaWR0aCAtIChsZWZ0ICsgd2lkdGgpKTtcbiAgICBjb25zdCBpbnNldEJvdHRvbSA9IGZsb29yKHJvb3QuY2xpZW50SGVpZ2h0IC0gKHRvcCArIGhlaWdodCkpO1xuICAgIGNvbnN0IGluc2V0TGVmdCA9IGZsb29yKGxlZnQpO1xuICAgIGNvbnN0IHJvb3RNYXJnaW4gPSAtaW5zZXRUb3AgKyBcInB4IFwiICsgLWluc2V0UmlnaHQgKyBcInB4IFwiICsgLWluc2V0Qm90dG9tICsgXCJweCBcIiArIC1pbnNldExlZnQgKyBcInB4XCI7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIHJvb3RNYXJnaW4sXG4gICAgICB0aHJlc2hvbGQ6IG1heCgwLCBtaW4oMSwgdGhyZXNob2xkKSkgfHwgMVxuICAgIH07XG4gICAgbGV0IGlzRmlyc3RVcGRhdGUgPSB0cnVlO1xuICAgIGZ1bmN0aW9uIGhhbmRsZU9ic2VydmUoZW50cmllcykge1xuICAgICAgY29uc3QgcmF0aW8gPSBlbnRyaWVzWzBdLmludGVyc2VjdGlvblJhdGlvO1xuICAgICAgaWYgKHJhdGlvICE9PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgaWYgKCFpc0ZpcnN0VXBkYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJhdGlvKSB7XG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICByZWZyZXNoKGZhbHNlLCAxZS03KTtcbiAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZnJlc2goZmFsc2UsIHJhdGlvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaXNGaXJzdFVwZGF0ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIE9sZGVyIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgYSBgZG9jdW1lbnRgIGFzIHRoZSByb290IGFuZCB3aWxsIHRocm93IGFuXG4gICAgLy8gZXJyb3IuXG4gICAgdHJ5IHtcbiAgICAgIGlvID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGhhbmRsZU9ic2VydmUsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgLy8gSGFuZGxlIDxpZnJhbWU+c1xuICAgICAgICByb290OiByb290Lm93bmVyRG9jdW1lbnRcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlvID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGhhbmRsZU9ic2VydmUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpby5vYnNlcnZlKGVsZW1lbnQpO1xuICB9XG4gIHJlZnJlc2godHJ1ZSk7XG4gIHJldHVybiBjbGVhbnVwO1xufVxuXG4vKipcbiAqIEF1dG9tYXRpY2FsbHkgdXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgd2hlbiBuZWNlc3NhcnkuXG4gKiBTaG91bGQgb25seSBiZSBjYWxsZWQgd2hlbiB0aGUgZmxvYXRpbmcgZWxlbWVudCBpcyBtb3VudGVkIG9uIHRoZSBET00gb3JcbiAqIHZpc2libGUgb24gdGhlIHNjcmVlbi5cbiAqIEByZXR1cm5zIGNsZWFudXAgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgaW52b2tlZCB3aGVuIHRoZSBmbG9hdGluZyBlbGVtZW50IGlzXG4gKiByZW1vdmVkIGZyb20gdGhlIERPTSBvciBoaWRkZW4gZnJvbSB0aGUgc2NyZWVuLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2F1dG9VcGRhdGVcbiAqL1xuZnVuY3Rpb24gYXV0b1VwZGF0ZShyZWZlcmVuY2UsIGZsb2F0aW5nLCB1cGRhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgYW5jZXN0b3JTY3JvbGwgPSB0cnVlLFxuICAgIGFuY2VzdG9yUmVzaXplID0gdHJ1ZSxcbiAgICBlbGVtZW50UmVzaXplID0gdHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSAnZnVuY3Rpb24nLFxuICAgIGxheW91dFNoaWZ0ID0gdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09PSAnZnVuY3Rpb24nLFxuICAgIGFuaW1hdGlvbkZyYW1lID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHJlZmVyZW5jZUVsID0gdW53cmFwRWxlbWVudChyZWZlcmVuY2UpO1xuICBjb25zdCBhbmNlc3RvcnMgPSBhbmNlc3RvclNjcm9sbCB8fCBhbmNlc3RvclJlc2l6ZSA/IFsuLi4ocmVmZXJlbmNlRWwgPyBnZXRPdmVyZmxvd0FuY2VzdG9ycyhyZWZlcmVuY2VFbCkgOiBbXSksIC4uLmdldE92ZXJmbG93QW5jZXN0b3JzKGZsb2F0aW5nKV0gOiBbXTtcbiAgYW5jZXN0b3JzLmZvckVhY2goYW5jZXN0b3IgPT4ge1xuICAgIGFuY2VzdG9yU2Nyb2xsICYmIGFuY2VzdG9yLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHVwZGF0ZSwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGFuY2VzdG9yUmVzaXplICYmIGFuY2VzdG9yLmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZSk7XG4gIH0pO1xuICBjb25zdCBjbGVhbnVwSW8gPSByZWZlcmVuY2VFbCAmJiBsYXlvdXRTaGlmdCA/IG9ic2VydmVNb3ZlKHJlZmVyZW5jZUVsLCB1cGRhdGUpIDogbnVsbDtcbiAgbGV0IHJlb2JzZXJ2ZUZyYW1lID0gLTE7XG4gIGxldCByZXNpemVPYnNlcnZlciA9IG51bGw7XG4gIGlmIChlbGVtZW50UmVzaXplKSB7XG4gICAgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoX3JlZiA9PiB7XG4gICAgICBsZXQgW2ZpcnN0RW50cnldID0gX3JlZjtcbiAgICAgIGlmIChmaXJzdEVudHJ5ICYmIGZpcnN0RW50cnkudGFyZ2V0ID09PSByZWZlcmVuY2VFbCAmJiByZXNpemVPYnNlcnZlcikge1xuICAgICAgICAvLyBQcmV2ZW50IHVwZGF0ZSBsb29wcyB3aGVuIHVzaW5nIHRoZSBgc2l6ZWAgbWlkZGxld2FyZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8xNzQwXG4gICAgICAgIHJlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZShmbG9hdGluZyk7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJlb2JzZXJ2ZUZyYW1lKTtcbiAgICAgICAgcmVvYnNlcnZlRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIHJlc2l6ZU9ic2VydmVyICYmIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoZmxvYXRpbmcpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZSgpO1xuICAgIH0pO1xuICAgIGlmIChyZWZlcmVuY2VFbCAmJiAhYW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUocmVmZXJlbmNlRWwpO1xuICAgIH1cbiAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKGZsb2F0aW5nKTtcbiAgfVxuICBsZXQgZnJhbWVJZDtcbiAgbGV0IHByZXZSZWZSZWN0ID0gYW5pbWF0aW9uRnJhbWUgPyBnZXRCb3VuZGluZ0NsaWVudFJlY3QocmVmZXJlbmNlKSA6IG51bGw7XG4gIGlmIChhbmltYXRpb25GcmFtZSkge1xuICAgIGZyYW1lTG9vcCgpO1xuICB9XG4gIGZ1bmN0aW9uIGZyYW1lTG9vcCgpIHtcbiAgICBjb25zdCBuZXh0UmVmUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChyZWZlcmVuY2UpO1xuICAgIGlmIChwcmV2UmVmUmVjdCAmJiAobmV4dFJlZlJlY3QueCAhPT0gcHJldlJlZlJlY3QueCB8fCBuZXh0UmVmUmVjdC55ICE9PSBwcmV2UmVmUmVjdC55IHx8IG5leHRSZWZSZWN0LndpZHRoICE9PSBwcmV2UmVmUmVjdC53aWR0aCB8fCBuZXh0UmVmUmVjdC5oZWlnaHQgIT09IHByZXZSZWZSZWN0LmhlaWdodCkpIHtcbiAgICAgIHVwZGF0ZSgpO1xuICAgIH1cbiAgICBwcmV2UmVmUmVjdCA9IG5leHRSZWZSZWN0O1xuICAgIGZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnJhbWVMb29wKTtcbiAgfVxuICB1cGRhdGUoKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgICBhbmNlc3RvclNjcm9sbCAmJiBhbmNlc3Rvci5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB1cGRhdGUpO1xuICAgICAgYW5jZXN0b3JSZXNpemUgJiYgYW5jZXN0b3IucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlKTtcbiAgICB9KTtcbiAgICBjbGVhbnVwSW8gJiYgY2xlYW51cElvKCk7XG4gICAgcmVzaXplT2JzZXJ2ZXIgJiYgcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIHJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgICBpZiAoYW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lSWQpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgdGhhdCB3aWxsIHBsYWNlIHRoZSBmbG9hdGluZyBlbGVtZW50XG4gKiBuZXh0IHRvIGEgcmVmZXJlbmNlIGVsZW1lbnQgd2hlbiBpdCBpcyBnaXZlbiBhIGNlcnRhaW4gQ1NTIHBvc2l0aW9uaW5nXG4gKiBzdHJhdGVneS5cbiAqL1xuY29uc3QgY29tcHV0ZVBvc2l0aW9uID0gKHJlZmVyZW5jZSwgZmxvYXRpbmcsIG9wdGlvbnMpID0+IHtcbiAgLy8gVGhpcyBjYWNoZXMgdGhlIGV4cGVuc2l2ZSBgZ2V0Q2xpcHBpbmdFbGVtZW50QW5jZXN0b3JzYCBmdW5jdGlvbiBzbyB0aGF0XG4gIC8vIG11bHRpcGxlIGxpZmVjeWNsZSByZXNldHMgcmUtdXNlIHRoZSBzYW1lIHJlc3VsdC4gSXQgb25seSBsaXZlcyBmb3IgYVxuICAvLyBzaW5nbGUgY2FsbC4gSWYgb3RoZXIgZnVuY3Rpb25zIGJlY29tZSBleHBlbnNpdmUsIHdlIGNhbiBhZGQgdGhlbSBhcyB3ZWxsLlxuICBjb25zdCBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IHtcbiAgICBwbGF0Zm9ybSxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIGNvbnN0IHBsYXRmb3JtV2l0aENhY2hlID0ge1xuICAgIC4uLm1lcmdlZE9wdGlvbnMucGxhdGZvcm0sXG4gICAgX2M6IGNhY2hlXG4gIH07XG4gIHJldHVybiBjb21wdXRlUG9zaXRpb24kMShyZWZlcmVuY2UsIGZsb2F0aW5nLCB7XG4gICAgLi4ubWVyZ2VkT3B0aW9ucyxcbiAgICBwbGF0Zm9ybTogcGxhdGZvcm1XaXRoQ2FjaGVcbiAgfSk7XG59O1xuXG5leHBvcnQgeyBhdXRvVXBkYXRlLCBjb21wdXRlUG9zaXRpb24sIHBsYXRmb3JtIH07XG4iXSwibmFtZXMiOlsicmVjdFRvQ2xpZW50UmVjdCIsImNvbXB1dGVQb3NpdGlvbiIsImNvbXB1dGVQb3NpdGlvbiQxIiwiYXJyb3ciLCJhdXRvUGxhY2VtZW50IiwiZGV0ZWN0T3ZlcmZsb3ciLCJmbGlwIiwiaGlkZSIsImlubGluZSIsImxpbWl0U2hpZnQiLCJvZmZzZXQiLCJzaGlmdCIsInNpemUiLCJyb3VuZCIsImNyZWF0ZUNvb3JkcyIsIm1heCIsIm1pbiIsImZsb29yIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImlzSFRNTEVsZW1lbnQiLCJpc0VsZW1lbnQiLCJnZXRXaW5kb3ciLCJpc1dlYktpdCIsImdldERvY3VtZW50RWxlbWVudCIsImdldE5vZGVOYW1lIiwiaXNPdmVyZmxvd0VsZW1lbnQiLCJnZXROb2RlU2Nyb2xsIiwiZ2V0T3ZlcmZsb3dBbmNlc3RvcnMiLCJnZXRQYXJlbnROb2RlIiwiaXNMYXN0VHJhdmVyc2FibGVOb2RlIiwiaXNDb250YWluaW5nQmxvY2siLCJpc1RhYmxlRWxlbWVudCIsImdldENvbnRhaW5pbmdCbG9jayIsImdldENzc0RpbWVuc2lvbnMiLCJlbGVtZW50IiwiY3NzIiwid2lkdGgiLCJwYXJzZUZsb2F0IiwiaGVpZ2h0IiwiaGFzT2Zmc2V0Iiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJzaG91bGRGYWxsYmFjayIsIiQiLCJ1bndyYXBFbGVtZW50IiwiY29udGV4dEVsZW1lbnQiLCJnZXRTY2FsZSIsImRvbUVsZW1lbnQiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwieCIsInkiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIm5vT2Zmc2V0cyIsImdldFZpc3VhbE9mZnNldHMiLCJ3aW4iLCJ2aXN1YWxWaWV3cG9ydCIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJzaG91bGRBZGRWaXN1YWxPZmZzZXRzIiwiaXNGaXhlZCIsImZsb2F0aW5nT2Zmc2V0UGFyZW50IiwiaW5jbHVkZVNjYWxlIiwiaXNGaXhlZFN0cmF0ZWd5Iiwib2Zmc2V0UGFyZW50IiwiY2xpZW50UmVjdCIsInNjYWxlIiwidmlzdWFsT2Zmc2V0cyIsImxlZnQiLCJ0b3AiLCJvZmZzZXRXaW4iLCJjdXJyZW50SUZyYW1lIiwiZnJhbWVFbGVtZW50IiwiaWZyYW1lU2NhbGUiLCJpZnJhbWVSZWN0IiwiY2xpZW50TGVmdCIsInBhZGRpbmdMZWZ0IiwiY2xpZW50VG9wIiwicGFkZGluZ1RvcCIsImNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0IiwiX3JlZiIsInN0cmF0ZWd5IiwiaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJzY3JvbGwiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsVG9wIiwib2Zmc2V0cyIsIm9mZnNldFJlY3QiLCJnZXRDbGllbnRSZWN0cyIsIkFycmF5IiwiZnJvbSIsImdldFdpbmRvd1Njcm9sbEJhclgiLCJnZXREb2N1bWVudFJlY3QiLCJodG1sIiwiYm9keSIsIm93bmVyRG9jdW1lbnQiLCJzY3JvbGxXaWR0aCIsImNsaWVudFdpZHRoIiwic2Nyb2xsSGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiZGlyZWN0aW9uIiwiZ2V0Vmlld3BvcnRSZWN0IiwidmlzdWFsVmlld3BvcnRCYXNlZCIsImdldElubmVyQm91bmRpbmdDbGllbnRSZWN0IiwiZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yIiwiY2xpcHBpbmdBbmNlc3RvciIsImhhc0ZpeGVkUG9zaXRpb25BbmNlc3RvciIsInN0b3BOb2RlIiwicGFyZW50Tm9kZSIsInBvc2l0aW9uIiwiZ2V0Q2xpcHBpbmdFbGVtZW50QW5jZXN0b3JzIiwiY2FjaGUiLCJjYWNoZWRSZXN1bHQiLCJnZXQiLCJyZXN1bHQiLCJmaWx0ZXIiLCJlbCIsImN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlIiwiZWxlbWVudElzRml4ZWQiLCJjdXJyZW50Tm9kZSIsImNvbXB1dGVkU3R5bGUiLCJjdXJyZW50Tm9kZUlzQ29udGFpbmluZyIsInNob3VsZERyb3BDdXJyZW50Tm9kZSIsImluY2x1ZGVzIiwiYW5jZXN0b3IiLCJzZXQiLCJnZXRDbGlwcGluZ1JlY3QiLCJib3VuZGFyeSIsInJvb3RCb3VuZGFyeSIsImVsZW1lbnRDbGlwcGluZ0FuY2VzdG9ycyIsIl9jIiwiY29uY2F0IiwiY2xpcHBpbmdBbmNlc3RvcnMiLCJmaXJzdENsaXBwaW5nQW5jZXN0b3IiLCJjbGlwcGluZ1JlY3QiLCJyZWR1Y2UiLCJhY2NSZWN0IiwicmlnaHQiLCJib3R0b20iLCJnZXREaW1lbnNpb25zIiwiZ2V0UmVjdFJlbGF0aXZlVG9PZmZzZXRQYXJlbnQiLCJnZXRUcnVlT2Zmc2V0UGFyZW50IiwicG9seWZpbGwiLCJnZXRPZmZzZXRQYXJlbnQiLCJ3aW5kb3ciLCJnZXRFbGVtZW50UmVjdHMiLCJyZWZlcmVuY2UiLCJmbG9hdGluZyIsImdldE9mZnNldFBhcmVudEZuIiwiZ2V0RGltZW5zaW9uc0ZuIiwiaXNSVEwiLCJwbGF0Zm9ybSIsIm9ic2VydmVNb3ZlIiwib25Nb3ZlIiwiaW8iLCJ0aW1lb3V0SWQiLCJyb290IiwiY2xlYW51cCIsImNsZWFyVGltZW91dCIsImRpc2Nvbm5lY3QiLCJyZWZyZXNoIiwic2tpcCIsInRocmVzaG9sZCIsImluc2V0VG9wIiwiaW5zZXRSaWdodCIsImluc2V0Qm90dG9tIiwiaW5zZXRMZWZ0Iiwicm9vdE1hcmdpbiIsIm9wdGlvbnMiLCJpc0ZpcnN0VXBkYXRlIiwiaGFuZGxlT2JzZXJ2ZSIsImVudHJpZXMiLCJyYXRpbyIsImludGVyc2VjdGlvblJhdGlvIiwic2V0VGltZW91dCIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwiZSIsIm9ic2VydmUiLCJhdXRvVXBkYXRlIiwidXBkYXRlIiwiYW5jZXN0b3JTY3JvbGwiLCJhbmNlc3RvclJlc2l6ZSIsImVsZW1lbnRSZXNpemUiLCJSZXNpemVPYnNlcnZlciIsImxheW91dFNoaWZ0IiwiYW5pbWF0aW9uRnJhbWUiLCJyZWZlcmVuY2VFbCIsImFuY2VzdG9ycyIsImZvckVhY2giLCJhZGRFdmVudExpc3RlbmVyIiwicGFzc2l2ZSIsImNsZWFudXBJbyIsInJlb2JzZXJ2ZUZyYW1lIiwicmVzaXplT2JzZXJ2ZXIiLCJmaXJzdEVudHJ5IiwidGFyZ2V0IiwidW5vYnNlcnZlIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJmcmFtZUlkIiwicHJldlJlZlJlY3QiLCJmcmFtZUxvb3AiLCJuZXh0UmVmUmVjdCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJNYXAiLCJtZXJnZWRPcHRpb25zIiwicGxhdGZvcm1XaXRoQ2FjaGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.autoPlacement),\n/* harmony export */   autoUpdate: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.autoUpdate),\n/* harmony export */   computePosition: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.computePosition),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.detectOverflow),\n/* harmony export */   flip: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.hide),\n/* harmony export */   inline: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.inline),\n/* harmony export */   limitShift: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.limitShift),\n/* harmony export */   offset: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.offset),\n/* harmony export */   platform: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.platform),\n/* harmony export */   shift: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.shift),\n/* harmony export */   size: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.size),\n/* harmony export */   useFloating: () => (/* binding */ useFloating)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\");\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n\n\n\n\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */ const arrow = (options)=>{\n    function isRef(value) {\n        return ({}).hasOwnProperty.call(value, \"current\");\n    }\n    return {\n        name: \"arrow\",\n        options,\n        fn (state) {\n            const { element, padding } = typeof options === \"function\" ? options(state) : options;\n            if (element && isRef(element)) {\n                if (element.current != null) {\n                    return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.arrow)({\n                        element: element.current,\n                        padding\n                    }).fn(state);\n                }\n                return {};\n            } else if (element) {\n                return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.arrow)({\n                    element,\n                    padding\n                }).fn(state);\n            }\n            return {};\n        }\n    };\n};\nvar index = typeof document !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_3__.useEffect;\n// Fork of `fast-deep-equal` that only does the comparisons we need and compares\n// functions\nfunction deepEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (typeof a !== typeof b) {\n        return false;\n    }\n    if (typeof a === \"function\" && a.toString() === b.toString()) {\n        return true;\n    }\n    let length, i, keys;\n    if (a && b && typeof a == \"object\") {\n        if (Array.isArray(a)) {\n            length = a.length;\n            if (length != b.length) return false;\n            for(i = length; i-- !== 0;){\n                if (!deepEqual(a[i], b[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        keys = Object.keys(a);\n        length = keys.length;\n        if (length !== Object.keys(b).length) {\n            return false;\n        }\n        for(i = length; i-- !== 0;){\n            if (!({}).hasOwnProperty.call(b, keys[i])) {\n                return false;\n            }\n        }\n        for(i = length; i-- !== 0;){\n            const key = keys[i];\n            if (key === \"_owner\" && a.$$typeof) {\n                continue;\n            }\n            if (!deepEqual(a[key], b[key])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return a !== a && b !== b;\n}\nfunction getDPR(element) {\n    if (true) {\n        return 1;\n    }\n    const win = element.ownerDocument.defaultView || window;\n    return win.devicePixelRatio || 1;\n}\nfunction roundByDPR(element, value) {\n    const dpr = getDPR(element);\n    return Math.round(value * dpr) / dpr;\n}\nfunction useLatestRef(value) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_3__.useRef(value);\n    index(()=>{\n        ref.current = value;\n    });\n    return ref;\n}\n/**\n * Provides data to position a floating element.\n * @see https://floating-ui.com/docs/useFloating\n */ function useFloating(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { placement = \"bottom\", strategy = \"absolute\", middleware = [], platform, elements: { reference: externalReference, floating: externalFloating } = {}, transform = true, whileElementsMounted, open } = options;\n    const [data, setData] = react__WEBPACK_IMPORTED_MODULE_3__.useState({\n        x: 0,\n        y: 0,\n        strategy,\n        placement,\n        middlewareData: {},\n        isPositioned: false\n    });\n    const [latestMiddleware, setLatestMiddleware] = react__WEBPACK_IMPORTED_MODULE_3__.useState(middleware);\n    if (!deepEqual(latestMiddleware, middleware)) {\n        setLatestMiddleware(middleware);\n    }\n    const [_reference, _setReference] = react__WEBPACK_IMPORTED_MODULE_3__.useState(null);\n    const [_floating, _setFloating] = react__WEBPACK_IMPORTED_MODULE_3__.useState(null);\n    const setReference = react__WEBPACK_IMPORTED_MODULE_3__.useCallback((node)=>{\n        if (node != referenceRef.current) {\n            referenceRef.current = node;\n            _setReference(node);\n        }\n    }, [\n        _setReference\n    ]);\n    const setFloating = react__WEBPACK_IMPORTED_MODULE_3__.useCallback((node)=>{\n        if (node !== floatingRef.current) {\n            floatingRef.current = node;\n            _setFloating(node);\n        }\n    }, [\n        _setFloating\n    ]);\n    const referenceEl = externalReference || _reference;\n    const floatingEl = externalFloating || _floating;\n    const referenceRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef(null);\n    const floatingRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef(null);\n    const dataRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef(data);\n    const whileElementsMountedRef = useLatestRef(whileElementsMounted);\n    const platformRef = useLatestRef(platform);\n    const update = react__WEBPACK_IMPORTED_MODULE_3__.useCallback(()=>{\n        if (!referenceRef.current || !floatingRef.current) {\n            return;\n        }\n        const config = {\n            placement,\n            strategy,\n            middleware: latestMiddleware\n        };\n        if (platformRef.current) {\n            config.platform = platformRef.current;\n        }\n        (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.computePosition)(referenceRef.current, floatingRef.current, config).then((data)=>{\n            const fullData = {\n                ...data,\n                isPositioned: true\n            };\n            if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {\n                dataRef.current = fullData;\n                react_dom__WEBPACK_IMPORTED_MODULE_4__.flushSync(()=>{\n                    setData(fullData);\n                });\n            }\n        });\n    }, [\n        latestMiddleware,\n        placement,\n        strategy,\n        platformRef\n    ]);\n    index(()=>{\n        if (open === false && dataRef.current.isPositioned) {\n            dataRef.current.isPositioned = false;\n            setData((data)=>({\n                    ...data,\n                    isPositioned: false\n                }));\n        }\n    }, [\n        open\n    ]);\n    const isMountedRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef(false);\n    index(()=>{\n        isMountedRef.current = true;\n        return ()=>{\n            isMountedRef.current = false;\n        };\n    }, []);\n    index(()=>{\n        if (referenceEl) referenceRef.current = referenceEl;\n        if (floatingEl) floatingRef.current = floatingEl;\n        if (referenceEl && floatingEl) {\n            if (whileElementsMountedRef.current) {\n                return whileElementsMountedRef.current(referenceEl, floatingEl, update);\n            } else {\n                update();\n            }\n        }\n    }, [\n        referenceEl,\n        floatingEl,\n        update,\n        whileElementsMountedRef\n    ]);\n    const refs = react__WEBPACK_IMPORTED_MODULE_3__.useMemo(()=>({\n            reference: referenceRef,\n            floating: floatingRef,\n            setReference,\n            setFloating\n        }), [\n        setReference,\n        setFloating\n    ]);\n    const elements = react__WEBPACK_IMPORTED_MODULE_3__.useMemo(()=>({\n            reference: referenceEl,\n            floating: floatingEl\n        }), [\n        referenceEl,\n        floatingEl\n    ]);\n    const floatingStyles = react__WEBPACK_IMPORTED_MODULE_3__.useMemo(()=>{\n        const initialStyles = {\n            position: strategy,\n            left: 0,\n            top: 0\n        };\n        if (!elements.floating) {\n            return initialStyles;\n        }\n        const x = roundByDPR(elements.floating, data.x);\n        const y = roundByDPR(elements.floating, data.y);\n        if (transform) {\n            return {\n                ...initialStyles,\n                transform: \"translate(\" + x + \"px, \" + y + \"px)\",\n                ...getDPR(elements.floating) >= 1.5 && {\n                    willChange: \"transform\"\n                }\n            };\n        }\n        return {\n            position: strategy,\n            left: x,\n            top: y\n        };\n    }, [\n        strategy,\n        transform,\n        elements.floating,\n        data.x,\n        data.y\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_3__.useMemo(()=>({\n            ...data,\n            update,\n            refs,\n            elements,\n            floatingStyles\n        }), [\n        data,\n        update,\n        refs,\n        elements,\n        floatingStyles\n    ]);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0LWRvbS9kaXN0L2Zsb2F0aW5nLXVpLnJlYWN0LWRvbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUU7QUFDOEc7QUFDcEo7QUFDb0I7QUFDYjtBQUV0Qzs7Ozs7Q0FLQyxHQUNELE1BQU1BLFFBQVFtQixDQUFBQTtJQUNaLFNBQVNDLE1BQU1DLEtBQUs7UUFDbEIsT0FBTyxFQUFDLEdBQUVDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDRixPQUFPO0lBQ3ZDO0lBQ0EsT0FBTztRQUNMRyxNQUFNO1FBQ05MO1FBQ0FNLElBQUdDLEtBQUs7WUFDTixNQUFNLEVBQ0pDLE9BQU8sRUFDUEMsT0FBTyxFQUNSLEdBQUcsT0FBT1QsWUFBWSxhQUFhQSxRQUFRTyxTQUFTUDtZQUNyRCxJQUFJUSxXQUFXUCxNQUFNTyxVQUFVO2dCQUM3QixJQUFJQSxRQUFRRSxPQUFPLElBQUksTUFBTTtvQkFDM0IsT0FBTzVCLHVEQUFPQSxDQUFDO3dCQUNiMEIsU0FBU0EsUUFBUUUsT0FBTzt3QkFDeEJEO29CQUNGLEdBQUdILEVBQUUsQ0FBQ0M7Z0JBQ1I7Z0JBQ0EsT0FBTyxDQUFDO1lBQ1YsT0FBTyxJQUFJQyxTQUFTO2dCQUNsQixPQUFPMUIsdURBQU9BLENBQUM7b0JBQ2IwQjtvQkFDQUM7Z0JBQ0YsR0FBR0gsRUFBRSxDQUFDQztZQUNSO1lBQ0EsT0FBTyxDQUFDO1FBQ1Y7SUFDRjtBQUNGO0FBRUEsSUFBSUksUUFBUSxPQUFPQyxhQUFhLGNBQWNmLGtEQUFlQSxHQUFHQyw0Q0FBU0E7QUFFekUsZ0ZBQWdGO0FBQ2hGLFlBQVk7QUFDWixTQUFTZSxVQUFVQyxDQUFDLEVBQUVDLENBQUM7SUFDckIsSUFBSUQsTUFBTUMsR0FBRztRQUNYLE9BQU87SUFDVDtJQUNBLElBQUksT0FBT0QsTUFBTSxPQUFPQyxHQUFHO1FBQ3pCLE9BQU87SUFDVDtJQUNBLElBQUksT0FBT0QsTUFBTSxjQUFj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QUNaLElBQUk7UUFBQ0Q7UUFBYUM7S0FBVztJQUM3QixNQUFNWSxpQkFBaUJ0RiwwQ0FBYSxDQUFDO1FBQ25DLE1BQU11RixnQkFBZ0I7WUFDcEJDLFVBQVU1QztZQUNWNkMsTUFBTTtZQUNOQyxLQUFLO1FBQ1A7UUFDQSxJQUFJLENBQUM1QyxTQUFTRyxRQUFRLEVBQUU7WUFDdEIsT0FBT3NDO1FBQ1Q7UUFDQSxNQUFNOUIsSUFBSXRCLFdBQVdXLFNBQVNHLFFBQVEsRUFBRUssS0FBS0csQ0FBQztRQUM5QyxNQUFNQyxJQUFJdkIsV0FBV1csU0FBU0csUUFBUSxFQUFFSyxLQUFLSSxDQUFDO1FBQzlDLElBQUlQLFdBQVc7WUFDYixPQUFPO2dCQUNMLEdBQUdvQyxhQUFhO2dCQUNoQnBDLFdBQVcsZUFBZU0sSUFBSSxTQUFTQyxJQUFJO2dCQUMzQyxHQUFJN0IsT0FBT2lCLFNBQVNHLFFBQVEsS0FBSyxPQUFPO29CQUN0QzBDLFlBQVk7Z0JBQ2QsQ0FBQztZQUNIO1FBQ0Y7UUFDQSxPQUFPO1lBQ0xILFVBQVU1QztZQUNWNkMsTUFBTWhDO1lBQ05pQyxLQUFLaEM7UUFDUDtJQUNGLEdBQUc7UUFBQ2Q7UUFBVU87UUFBV0wsU0FBU0csUUFBUTtRQUFFSyxLQUFLRyxDQUFDO1FBQUVILEtBQUtJLENBQUM7S0FBQztJQUMzRCxPQUFPMUQsMENBQWEsQ0FBQyxJQUFPO1lBQzFCLEdBQUdzRCxJQUFJO1lBQ1B3QjtZQUNBTTtZQUNBdEM7WUFDQXdDO1FBQ0YsSUFBSTtRQUFDaEM7UUFBTXdCO1FBQVFNO1FBQU10QztRQUFVd0M7S0FBZTtBQUNwRDtBQUU4QiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi1hcHAvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0LWRvbS9kaXN0L2Zsb2F0aW5nLXVpLnJlYWN0LWRvbS5tanM/Yzc5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhcnJvdyBhcyBhcnJvdyQxLCBjb21wdXRlUG9zaXRpb24gfSBmcm9tICdAZmxvYXRpbmctdWkvZG9tJztcbmV4cG9ydCB7IGF1dG9QbGFjZW1lbnQsIGF1dG9VcGRhdGUsIGNvbXB1dGVQb3NpdGlvbiwgZGV0ZWN0T3ZlcmZsb3csIGZsaXAsIGdldE92ZXJmbG93QW5jZXN0b3JzLCBoaWRlLCBpbmxpbmUsIGxpbWl0U2hpZnQsIG9mZnNldCwgcGxhdGZvcm0sIHNoaWZ0LCBzaXplIH0gZnJvbSAnQGZsb2F0aW5nLXVpL2RvbSc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhbiBpbm5lciBlbGVtZW50IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHNvIHRoYXQgaXRcbiAqIGFwcGVhcnMgY2VudGVyZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogVGhpcyB3cmFwcyB0aGUgY29yZSBgYXJyb3dgIG1pZGRsZXdhcmUgdG8gYWxsb3cgUmVhY3QgcmVmcyBhcyB0aGUgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hcnJvd1xuICovXG5jb25zdCBhcnJvdyA9IG9wdGlvbnMgPT4ge1xuICBmdW5jdGlvbiBpc1JlZih2YWx1ZSkge1xuICAgIHJldHVybiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY3VycmVudCcpO1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2Fycm93JyxcbiAgICBvcHRpb25zLFxuICAgIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIHBhZGRpbmdcbiAgICAgIH0gPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMoc3RhdGUpIDogb3B0aW9ucztcbiAgICAgIGlmIChlbGVtZW50ICYmIGlzUmVmKGVsZW1lbnQpKSB7XG4gICAgICAgIGlmIChlbGVtZW50LmN1cnJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBhcnJvdyQxKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQuY3VycmVudCxcbiAgICAgICAgICAgIHBhZGRpbmdcbiAgICAgICAgICB9KS5mbihzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfSBlbHNlIGlmIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBhcnJvdyQxKHtcbiAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgIHBhZGRpbmdcbiAgICAgICAgfSkuZm4oc3RhdGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbnZhciBpbmRleCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbi8vIEZvcmsgb2YgYGZhc3QtZGVlcC1lcXVhbGAgdGhhdCBvbmx5IGRvZXMgdGhlIGNvbXBhcmlzb25zIHdlIG5lZWQgYW5kIGNvbXBhcmVzXG4vLyBmdW5jdGlvbnNcbmZ1bmN0aW9uIGRlZXBFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBhICE9PSB0eXBlb2YgYikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIGEgPT09ICdmdW5jdGlvbicgJiYgYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBsZXQgbGVuZ3RoLCBpLCBrZXlzO1xuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09ICdvYmplY3QnKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICAgIGlmICghZGVlcEVxdWFsKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXlzW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChrZXkgPT09ICdfb3duZXInICYmIGEuJCR0eXBlb2YpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIWRlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gYSAhPT0gYSAmJiBiICE9PSBiO1xufVxuXG5mdW5jdGlvbiBnZXREUFIoZWxlbWVudCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBjb25zdCB3aW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICByZXR1cm4gd2luLmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbn1cblxuZnVuY3Rpb24gcm91bmRCeURQUihlbGVtZW50LCB2YWx1ZSkge1xuICBjb25zdCBkcHIgPSBnZXREUFIoZWxlbWVudCk7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogZHByKSAvIGRwcjtcbn1cblxuZnVuY3Rpb24gdXNlTGF0ZXN0UmVmKHZhbHVlKSB7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZih2YWx1ZSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlZjtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIHBvc2l0aW9uIGEgZmxvYXRpbmcgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VGbG9hdGluZ1xuICovXG5mdW5jdGlvbiB1c2VGbG9hdGluZyhvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCA9ICdib3R0b20nLFxuICAgIHN0cmF0ZWd5ID0gJ2Fic29sdXRlJyxcbiAgICBtaWRkbGV3YXJlID0gW10sXG4gICAgcGxhdGZvcm0sXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIHJlZmVyZW5jZTogZXh0ZXJuYWxSZWZlcmVuY2UsXG4gICAgICBmbG9hdGluZzogZXh0ZXJuYWxGbG9hdGluZ1xuICAgIH0gPSB7fSxcbiAgICB0cmFuc2Zvcm0gPSB0cnVlLFxuICAgIHdoaWxlRWxlbWVudHNNb3VudGVkLFxuICAgIG9wZW5cbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IFtkYXRhLCBzZXREYXRhXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgc3RyYXRlZ3ksXG4gICAgcGxhY2VtZW50LFxuICAgIG1pZGRsZXdhcmVEYXRhOiB7fSxcbiAgICBpc1Bvc2l0aW9uZWQ6IGZhbHNlXG4gIH0pO1xuICBjb25zdCBbbGF0ZXN0TWlkZGxld2FyZSwgc2V0TGF0ZXN0TWlkZGxld2FyZV0gPSBSZWFjdC51c2VTdGF0ZShtaWRkbGV3YXJlKTtcbiAgaWYgKCFkZWVwRXF1YWwobGF0ZXN0TWlkZGxld2FyZSwgbWlkZGxld2FyZSkpIHtcbiAgICBzZXRMYXRlc3RNaWRkbGV3YXJlKG1pZGRsZXdhcmUpO1xuICB9XG4gIGNvbnN0IFtfcmVmZXJlbmNlLCBfc2V0UmVmZXJlbmNlXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbX2Zsb2F0aW5nLCBfc2V0RmxvYXRpbmddID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IHNldFJlZmVyZW5jZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIGlmIChub2RlICE9IHJlZmVyZW5jZVJlZi5jdXJyZW50KSB7XG4gICAgICByZWZlcmVuY2VSZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICBfc2V0UmVmZXJlbmNlKG5vZGUpO1xuICAgIH1cbiAgfSwgW19zZXRSZWZlcmVuY2VdKTtcbiAgY29uc3Qgc2V0RmxvYXRpbmcgPSBSZWFjdC51c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBpZiAobm9kZSAhPT0gZmxvYXRpbmdSZWYuY3VycmVudCkge1xuICAgICAgZmxvYXRpbmdSZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICBfc2V0RmxvYXRpbmcobm9kZSk7XG4gICAgfVxuICB9LCBbX3NldEZsb2F0aW5nXSk7XG4gIGNvbnN0IHJlZmVyZW5jZUVsID0gZXh0ZXJuYWxSZWZlcmVuY2UgfHwgX3JlZmVyZW5jZTtcbiAgY29uc3QgZmxvYXRpbmdFbCA9IGV4dGVybmFsRmxvYXRpbmcgfHwgX2Zsb2F0aW5nO1xuICBjb25zdCByZWZlcmVuY2VSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGZsb2F0aW5nUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBkYXRhUmVmID0gUmVhY3QudXNlUmVmKGRhdGEpO1xuICBjb25zdCB3aGlsZUVsZW1lbnRzTW91bnRlZFJlZiA9IHVzZUxhdGVzdFJlZih3aGlsZUVsZW1lbnRzTW91bnRlZCk7XG4gIGNvbnN0IHBsYXRmb3JtUmVmID0gdXNlTGF0ZXN0UmVmKHBsYXRmb3JtKTtcbiAgY29uc3QgdXBkYXRlID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICghcmVmZXJlbmNlUmVmLmN1cnJlbnQgfHwgIWZsb2F0aW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgcGxhY2VtZW50LFxuICAgICAgc3RyYXRlZ3ksXG4gICAgICBtaWRkbGV3YXJlOiBsYXRlc3RNaWRkbGV3YXJlXG4gICAgfTtcbiAgICBpZiAocGxhdGZvcm1SZWYuY3VycmVudCkge1xuICAgICAgY29uZmlnLnBsYXRmb3JtID0gcGxhdGZvcm1SZWYuY3VycmVudDtcbiAgICB9XG4gICAgY29tcHV0ZVBvc2l0aW9uKHJlZmVyZW5jZVJlZi5jdXJyZW50LCBmbG9hdGluZ1JlZi5jdXJyZW50LCBjb25maWcpLnRoZW4oZGF0YSA9PiB7XG4gICAgICBjb25zdCBmdWxsRGF0YSA9IHtcbiAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgaXNQb3NpdGlvbmVkOiB0cnVlXG4gICAgICB9O1xuICAgICAgaWYgKGlzTW91bnRlZFJlZi5jdXJyZW50ICYmICFkZWVwRXF1YWwoZGF0YVJlZi5jdXJyZW50LCBmdWxsRGF0YSkpIHtcbiAgICAgICAgZGF0YVJlZi5jdXJyZW50ID0gZnVsbERhdGE7XG4gICAgICAgIFJlYWN0RE9NLmZsdXNoU3luYygoKSA9PiB7XG4gICAgICAgICAgc2V0RGF0YShmdWxsRGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBbbGF0ZXN0TWlkZGxld2FyZSwgcGxhY2VtZW50LCBzdHJhdGVneSwgcGxhdGZvcm1SZWZdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChvcGVuID09PSBmYWxzZSAmJiBkYXRhUmVmLmN1cnJlbnQuaXNQb3NpdGlvbmVkKSB7XG4gICAgICBkYXRhUmVmLmN1cnJlbnQuaXNQb3NpdGlvbmVkID0gZmFsc2U7XG4gICAgICBzZXREYXRhKGRhdGEgPT4gKHtcbiAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgaXNQb3NpdGlvbmVkOiBmYWxzZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSwgW29wZW5dKTtcbiAgY29uc3QgaXNNb3VudGVkUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAocmVmZXJlbmNlRWwpIHJlZmVyZW5jZVJlZi5jdXJyZW50ID0gcmVmZXJlbmNlRWw7XG4gICAgaWYgKGZsb2F0aW5nRWwpIGZsb2F0aW5nUmVmLmN1cnJlbnQgPSBmbG9hdGluZ0VsO1xuICAgIGlmIChyZWZlcmVuY2VFbCAmJiBmbG9hdGluZ0VsKSB7XG4gICAgICBpZiAod2hpbGVFbGVtZW50c01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgICByZXR1cm4gd2hpbGVFbGVtZW50c01vdW50ZWRSZWYuY3VycmVudChyZWZlcmVuY2VFbCwgZmxvYXRpbmdFbCwgdXBkYXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW3JlZmVyZW5jZUVsLCBmbG9hdGluZ0VsLCB1cGRhdGUsIHdoaWxlRWxlbWVudHNNb3VudGVkUmVmXSk7XG4gIGNvbnN0IHJlZnMgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VSZWYsXG4gICAgZmxvYXRpbmc6IGZsb2F0aW5nUmVmLFxuICAgIHNldFJlZmVyZW5jZSxcbiAgICBzZXRGbG9hdGluZ1xuICB9KSwgW3NldFJlZmVyZW5jZSwgc2V0RmxvYXRpbmddKTtcbiAgY29uc3QgZWxlbWVudHMgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VFbCxcbiAgICBmbG9hdGluZzogZmxvYXRpbmdFbFxuICB9KSwgW3JlZmVyZW5jZUVsLCBmbG9hdGluZ0VsXSk7XG4gIGNvbnN0IGZsb2F0aW5nU3R5bGVzID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgaW5pdGlhbFN0eWxlcyA9IHtcbiAgICAgIHBvc2l0aW9uOiBzdHJhdGVneSxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDBcbiAgICB9O1xuICAgIGlmICghZWxlbWVudHMuZmxvYXRpbmcpIHtcbiAgICAgIHJldHVybiBpbml0aWFsU3R5bGVzO1xuICAgIH1cbiAgICBjb25zdCB4ID0gcm91bmRCeURQUihlbGVtZW50cy5mbG9hdGluZywgZGF0YS54KTtcbiAgICBjb25zdCB5ID0gcm91bmRCeURQUihlbGVtZW50cy5mbG9hdGluZywgZGF0YS55KTtcbiAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5pbml0aWFsU3R5bGVzLFxuICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgpXCIsXG4gICAgICAgIC4uLihnZXREUFIoZWxlbWVudHMuZmxvYXRpbmcpID49IDEuNSAmJiB7XG4gICAgICAgICAgd2lsbENoYW5nZTogJ3RyYW5zZm9ybSdcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwb3NpdGlvbjogc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiB4LFxuICAgICAgdG9wOiB5XG4gICAgfTtcbiAgfSwgW3N0cmF0ZWd5LCB0cmFuc2Zvcm0sIGVsZW1lbnRzLmZsb2F0aW5nLCBkYXRhLngsIGRhdGEueV0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIC4uLmRhdGEsXG4gICAgdXBkYXRlLFxuICAgIHJlZnMsXG4gICAgZWxlbWVudHMsXG4gICAgZmxvYXRpbmdTdHlsZXNcbiAgfSksIFtkYXRhLCB1cGRhdGUsIHJlZnMsIGVsZW1lbnRzLCBmbG9hdGluZ1N0eWxlc10pO1xufVxuXG5leHBvcnQgeyBhcnJvdywgdXNlRmxvYXRpbmcgfTtcbiJdLCJuYW1lcyI6WyJhcnJvdyIsImFycm93JDEiLCJjb21wdXRlUG9zaXRpb24iLCJhdXRvUGxhY2VtZW50IiwiYXV0b1VwZGF0ZSIsImRldGVjdE92ZXJmbG93IiwiZmxpcCIsImdldE92ZXJmbG93QW5jZXN0b3JzIiwiaGlkZSIsImlubGluZSIsImxpbWl0U2hpZnQiLCJvZmZzZXQiLCJwbGF0Zm9ybSIsInNoaWZ0Iiwic2l6ZSIsIlJlYWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0IiwiUmVhY3RET00iLCJvcHRpb25zIiwiaXNSZWYiLCJ2YWx1ZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIm5hbWUiLCJmbiIsInN0YXRlIiwiZWxlbWVudCIsInBhZGRpbmciLCJjdXJyZW50IiwiaW5kZXgiLCJkb2N1bWVudCIsImRlZXBFcXVhbCIsImEiLCJiIiwidG9TdHJpbmciLCJsZW5ndGgiLCJpIiwia2V5cyIsIkFycmF5IiwiaXNBcnJheSIsIk9iamVjdCIsImtleSIsIiQkdHlwZW9mIiwiZ2V0RFBSIiwid2luIiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3Iiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsInJvdW5kQnlEUFIiLCJkcHIiLCJNYXRoIiwicm91bmQiLCJ1c2VMYXRlc3RSZWYiLCJyZWYiLCJ1c2VSZWYiLCJ1c2VGbG9hdGluZyIsInBsYWNlbWVudCIsInN0cmF0ZWd5IiwibWlkZGxld2FyZSIsImVsZW1lbnRzIiwicmVmZXJlbmNlIiwiZXh0ZXJuYWxSZWZlcmVuY2UiLCJmbG9hdGluZyIsImV4dGVybmFsRmxvYXRpbmciLCJ0cmFuc2Zvcm0iLCJ3aGlsZUVsZW1lbnRzTW91bnRlZCIsIm9wZW4iLCJkYXRhIiwic2V0RGF0YSIsInVzZVN0YXRlIiwieCIsInkiLCJtaWRkbGV3YXJlRGF0YSIsImlzUG9zaXRpb25lZCIsImxhdGVzdE1pZGRsZXdhcmUiLCJzZXRMYXRlc3RNaWRkbGV3YXJlIiwiX3JlZmVyZW5jZSIsIl9zZXRSZWZlcmVuY2UiLCJfZmxvYXRpbmciLCJfc2V0RmxvYXRpbmciLCJzZXRSZWZlcmVuY2UiLCJ1c2VDYWxsYmFjayIsIm5vZGUiLCJyZWZlcmVuY2VSZWYiLCJzZXRGbG9hdGluZyIsImZsb2F0aW5nUmVmIiwicmVmZXJlbmNlRWwiLCJmbG9hdGluZ0VsIiwiZGF0YVJlZiIsIndoaWxlRWxlbWVudHNNb3VudGVkUmVmIiwicGxhdGZvcm1SZWYiLCJ1cGRhdGUiLCJjb25maWciLCJ0aGVuIiwiZnVsbERhdGEiLCJpc01vdW50ZWRSZWYiLCJmbHVzaFN5bmMiLCJyZWZzIiwidXNlTWVtbyIsImZsb2F0aW5nU3R5bGVzIiwiaW5pdGlhbFN0eWxlcyIsInBvc2l0aW9uIiwibGVmdCIsInRvcCIsIndpbGxDaGFuZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@floating-ui/react/dist/floating-ui.react.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Composite: () => (/* binding */ Composite),\n/* harmony export */   CompositeItem: () => (/* binding */ CompositeItem),\n/* harmony export */   FloatingArrow: () => (/* binding */ FloatingArrow),\n/* harmony export */   FloatingDelayGroup: () => (/* binding */ FloatingDelayGroup),\n/* harmony export */   FloatingFocusManager: () => (/* binding */ FloatingFocusManager),\n/* harmony export */   FloatingList: () => (/* binding */ FloatingList),\n/* harmony export */   FloatingNode: () => (/* binding */ FloatingNode),\n/* harmony export */   FloatingOverlay: () => (/* binding */ FloatingOverlay),\n/* harmony export */   FloatingPortal: () => (/* binding */ FloatingPortal),\n/* harmony export */   FloatingTree: () => (/* binding */ FloatingTree),\n/* harmony export */   arrow: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.arrow),\n/* harmony export */   autoPlacement: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.autoPlacement),\n/* harmony export */   autoUpdate: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.autoUpdate),\n/* harmony export */   computePosition: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.computePosition),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.detectOverflow),\n/* harmony export */   flip: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.hide),\n/* harmony export */   inline: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.inline),\n/* harmony export */   inner: () => (/* binding */ inner),\n/* harmony export */   limitShift: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.limitShift),\n/* harmony export */   offset: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.offset),\n/* harmony export */   platform: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.platform),\n/* harmony export */   safePolygon: () => (/* binding */ safePolygon),\n/* harmony export */   shift: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.shift),\n/* harmony export */   size: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.size),\n/* harmony export */   useClick: () => (/* binding */ useClick),\n/* harmony export */   useClientPoint: () => (/* binding */ useClientPoint),\n/* harmony export */   useDelayGroup: () => (/* binding */ useDelayGroup),\n/* harmony export */   useDelayGroupContext: () => (/* binding */ useDelayGroupContext),\n/* harmony export */   useDismiss: () => (/* binding */ useDismiss),\n/* harmony export */   useFloating: () => (/* binding */ useFloating),\n/* harmony export */   useFloatingNodeId: () => (/* binding */ useFloatingNodeId),\n/* harmony export */   useFloatingParentNodeId: () => (/* binding */ useFloatingParentNodeId),\n/* harmony export */   useFloatingPortalNode: () => (/* binding */ useFloatingPortalNode),\n/* harmony export */   useFloatingTree: () => (/* binding */ useFloatingTree),\n/* harmony export */   useFocus: () => (/* binding */ useFocus),\n/* harmony export */   useHover: () => (/* binding */ useHover),\n/* harmony export */   useId: () => (/* binding */ useId),\n/* harmony export */   useInnerOffset: () => (/* binding */ useInnerOffset),\n/* harmony export */   useInteractions: () => (/* binding */ useInteractions),\n/* harmony export */   useListItem: () => (/* binding */ useListItem),\n/* harmony export */   useListNavigation: () => (/* binding */ useListNavigation),\n/* harmony export */   useMergeRefs: () => (/* binding */ useMergeRefs),\n/* harmony export */   useRole: () => (/* binding */ useRole),\n/* harmony export */   useTransitionStatus: () => (/* binding */ useTransitionStatus),\n/* harmony export */   useTransitionStyles: () => (/* binding */ useTransitionStyles),\n/* harmony export */   useTypeahead: () => (/* binding */ useTypeahead)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @floating-ui/react/utils */ \"(ssr)/./node_modules/@floating-ui/react/utils/dist/floating-ui.react.utils.mjs\");\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @floating-ui/utils */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @floating-ui/utils/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\");\n/* harmony import */ var tabbable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! tabbable */ \"(ssr)/./node_modules/tabbable/dist/index.esm.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n\n\n\n\n\n\n\n\n\n/**\n * Merges an array of refs into a single memoized callback ref or `null`.\n * @see https://floating-ui.com/docs/useMergeRefs\n */ function useMergeRefs(refs) {\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (refs.every((ref)=>ref == null)) {\n            return null;\n        }\n        return (value)=>{\n            refs.forEach((ref)=>{\n                if (typeof ref === \"function\") {\n                    ref(value);\n                } else if (ref != null) {\n                    ref.current = value;\n                }\n            });\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, refs);\n}\n// `toString()` prevents bundlers from trying to `import { useInsertionEffect } from 'react'`\nconst useInsertionEffect = /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)))[/*#__PURE__*/ \"useInsertionEffect\".toString()];\nconst useSafeInsertionEffect = useInsertionEffect || ((fn)=>fn());\nfunction useEffectEvent(callback) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(()=>{\n        if (true) {\n            throw new Error(\"Cannot call an event handler while rendering.\");\n        }\n    });\n    useSafeInsertionEffect(()=>{\n        ref.current = callback;\n    });\n    return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return ref.current == null ? void 0 : ref.current(...args);\n    }, []);\n}\nconst ARROW_UP = \"ArrowUp\";\nconst ARROW_DOWN = \"ArrowDown\";\nconst ARROW_LEFT = \"ArrowLeft\";\nconst ARROW_RIGHT = \"ArrowRight\";\nfunction isDifferentRow(index, cols, prevRow) {\n    return Math.floor(index / cols) !== prevRow;\n}\nfunction isIndexOutOfBounds(listRef, index) {\n    return index < 0 || index >= listRef.current.length;\n}\nfunction getMinIndex(listRef, disabledIndices) {\n    return findNonDisabledIndex(listRef, {\n        disabledIndices\n    });\n}\nfunction getMaxIndex(listRef, disabledIndices) {\n    return findNonDisabledIndex(listRef, {\n        decrement: true,\n        startingIndex: listRef.current.length,\n        disabledIndices\n    });\n}\nfunction findNonDisabledIndex(listRef, _temp) {\n    let { startingIndex = -1, decrement = false, disabledIndices, amount = 1 } = _temp === void 0 ? {} : _temp;\n    const list = listRef.current;\n    const isDisabledIndex = disabledIndices ? (index)=>disabledIndices.includes(index) : (index)=>{\n        const element = list[index];\n        return element == null || element.hasAttribute(\"disabled\") || element.getAttribute(\"aria-disabled\") === \"true\";\n    };\n    let index = startingIndex;\n    do {\n        index += decrement ? -amount : amount;\n    }while (index >= 0 && index <= list.length - 1 && isDisabledIndex(index));\n    return index;\n}\nfunction getGridNavigatedIndex(elementsRef, _ref) {\n    let { event, orientation, loop, cols, disabledIndices, minIndex, maxIndex, prevIndex, stopEvent: stop = false } = _ref;\n    let nextIndex = prevIndex;\n    if (event.key === ARROW_UP) {\n        stop && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n        if (prevIndex === -1) {\n            nextIndex = maxIndex;\n        } else {\n            nextIndex = findNonDisabledIndex(elementsRef, {\n                startingIndex: nextIndex,\n                amount: cols,\n                decrement: true,\n                disabledIndices\n            });\n            if (loop && (prevIndex - cols < minIndex || nextIndex < 0)) {\n                const col = prevIndex % cols;\n                const maxCol = maxIndex % cols;\n                const offset = maxIndex - (maxCol - col);\n                if (maxCol === col) {\n                    nextIndex = maxIndex;\n                } else {\n                    nextIndex = maxCol > col ? offset : offset - cols;\n                }\n            }\n        }\n        if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n            nextIndex = prevIndex;\n        }\n    }\n    if (event.key === ARROW_DOWN) {\n        stop && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n        if (prevIndex === -1) {\n            nextIndex = minIndex;\n        } else {\n            nextIndex = findNonDisabledIndex(elementsRef, {\n                startingIndex: prevIndex,\n                amount: cols,\n                disabledIndices\n            });\n            if (loop && prevIndex + cols > maxIndex) {\n                nextIndex = findNonDisabledIndex(elementsRef, {\n                    startingIndex: prevIndex % cols - cols,\n                    amount: cols,\n                    disabledIndices\n                });\n            }\n        }\n        if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n            nextIndex = prevIndex;\n        }\n    }\n    // Remains on the same row/column.\n    if (orientation === \"both\") {\n        const prevRow = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_7__.floor)(prevIndex / cols);\n        if (event.key === ARROW_RIGHT) {\n            stop && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n            if (prevIndex % cols !== cols - 1) {\n                nextIndex = findNonDisabledIndex(elementsRef, {\n                    startingIndex: prevIndex,\n                    disabledIndices\n                });\n                if (loop && isDifferentRow(nextIndex, cols, prevRow)) {\n                    nextIndex = findNonDisabledIndex(elementsRef, {\n                        startingIndex: prevIndex - prevIndex % cols - 1,\n                        disabledIndices\n                    });\n                }\n            } else if (loop) {\n                nextIndex = findNonDisabledIndex(elementsRef, {\n                    startingIndex: prevIndex - prevIndex % cols - 1,\n                    disabledIndices\n                });\n            }\n            if (isDifferentRow(nextIndex, cols, prevRow)) {\n                nextIndex = prevIndex;\n            }\n        }\n        if (event.key === ARROW_LEFT) {\n            stop && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n            if (prevIndex % cols !== 0) {\n                nextIndex = findNonDisabledIndex(elementsRef, {\n                    startingIndex: prevIndex,\n                    disabledIndices,\n                    decrement: true\n                });\n                if (loop && isDifferentRow(nextIndex, cols, prevRow)) {\n                    nextIndex = findNonDisabledIndex(elementsRef, {\n                        startingIndex: prevIndex + (cols - prevIndex % cols),\n                        decrement: true,\n                        disabledIndices\n                    });\n                }\n            } else if (loop) {\n                nextIndex = findNonDisabledIndex(elementsRef, {\n                    startingIndex: prevIndex + (cols - prevIndex % cols),\n                    decrement: true,\n                    disabledIndices\n                });\n            }\n            if (isDifferentRow(nextIndex, cols, prevRow)) {\n                nextIndex = prevIndex;\n            }\n        }\n        const lastRow = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_7__.floor)(maxIndex / cols) === prevRow;\n        if (isIndexOutOfBounds(elementsRef, nextIndex)) {\n            if (loop && lastRow) {\n                nextIndex = event.key === ARROW_LEFT ? maxIndex : findNonDisabledIndex(elementsRef, {\n                    startingIndex: prevIndex - prevIndex % cols - 1,\n                    disabledIndices\n                });\n            } else {\n                nextIndex = prevIndex;\n            }\n        }\n    }\n    return nextIndex;\n}\nlet rafId = 0;\nfunction enqueueFocus(el, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { preventScroll = false, cancelPrevious = true, sync = false } = options;\n    cancelPrevious && cancelAnimationFrame(rafId);\n    const exec = ()=>el == null ? void 0 : el.focus({\n            preventScroll\n        });\n    if (sync) {\n        exec();\n    } else {\n        rafId = requestAnimationFrame(exec);\n    }\n}\nvar index = typeof document !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction sortByDocumentPosition(a, b) {\n    const position = a.compareDocumentPosition(b);\n    if (position & Node.DOCUMENT_POSITION_FOLLOWING || position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n        return -1;\n    }\n    if (position & Node.DOCUMENT_POSITION_PRECEDING || position & Node.DOCUMENT_POSITION_CONTAINS) {\n        return 1;\n    }\n    return 0;\n}\nfunction areMapsEqual(map1, map2) {\n    if (map1.size !== map2.size) {\n        return false;\n    }\n    for (const [key, value] of map1.entries()){\n        if (value !== map2.get(key)) {\n            return false;\n        }\n    }\n    return true;\n}\nconst FloatingListContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    register: ()=>{},\n    unregister: ()=>{},\n    map: /*#__PURE__*/ new Map(),\n    elementsRef: {\n        current: []\n    }\n});\n/**\n * Provides context for a list of items within the floating element.\n * @see https://floating-ui.com/docs/FloatingList\n */ function FloatingList(_ref) {\n    let { children, elementsRef, labelsRef } = _ref;\n    const [map, setMap] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new Map());\n    const register = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        setMap((prevMap)=>new Map(prevMap).set(node, null));\n    }, []);\n    const unregister = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        setMap((prevMap)=>{\n            const map = new Map(prevMap);\n            map.delete(node);\n            return map;\n        });\n    }, []);\n    index(()=>{\n        const newMap = new Map(map);\n        const nodes = Array.from(newMap.keys()).sort(sortByDocumentPosition);\n        nodes.forEach((node, index)=>{\n            newMap.set(node, index);\n        });\n        if (!areMapsEqual(map, newMap)) {\n            setMap(newMap);\n        }\n    }, [\n        map\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingListContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n                register,\n                unregister,\n                map,\n                elementsRef,\n                labelsRef\n            }), [\n            register,\n            unregister,\n            map,\n            elementsRef,\n            labelsRef\n        ])\n    }, children);\n}\nfunction useListItem(_temp) {\n    let { label } = _temp === void 0 ? {} : _temp;\n    const [index$1, setIndex] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const componentRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const { register, unregister, map, elementsRef, labelsRef } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingListContext);\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        componentRef.current = node;\n        if (index$1 !== null) {\n            elementsRef.current[index$1] = node;\n            if (labelsRef) {\n                var _node$textContent;\n                const isLabelDefined = label !== undefined;\n                labelsRef.current[index$1] = isLabelDefined ? label : (_node$textContent = node == null ? void 0 : node.textContent) != null ? _node$textContent : null;\n            }\n        }\n    }, [\n        index$1,\n        elementsRef,\n        labelsRef,\n        label\n    ]);\n    index(()=>{\n        const node = componentRef.current;\n        if (node) {\n            register(node);\n            return ()=>{\n                unregister(node);\n            };\n        }\n    }, [\n        register,\n        unregister\n    ]);\n    index(()=>{\n        const index = componentRef.current ? map.get(componentRef.current) : null;\n        if (index != null) {\n            setIndex(index);\n        }\n    }, [\n        map\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            ref,\n            index: index$1 == null ? -1 : index$1\n        }), [\n        index$1,\n        ref\n    ]);\n}\nfunction renderJsx(render, computedProps) {\n    if (typeof render === \"function\") {\n        return render(computedProps);\n    } else if (render) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(render, computedProps);\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", computedProps);\n}\nconst CompositeContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    activeIndex: 0,\n    onNavigate: ()=>{}\n});\nconst horizontalKeys = [\n    ARROW_LEFT,\n    ARROW_RIGHT\n];\nconst verticalKeys = [\n    ARROW_UP,\n    ARROW_DOWN\n];\nconst allKeys = [\n    ...horizontalKeys,\n    ...verticalKeys\n];\nconst Composite = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function Composite(_ref, forwardedRef) {\n    let { render, orientation = \"both\", loop = true, cols = 1, disabledIndices, activeIndex: externalActiveIndex, onNavigate: externalSetActiveIndex, ...props } = _ref;\n    const [internalActiveIndex, internalSetActiveIndex] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);\n    const activeIndex = externalActiveIndex != null ? externalActiveIndex : internalActiveIndex;\n    const onNavigate = useEffectEvent(externalSetActiveIndex != null ? externalSetActiveIndex : internalSetActiveIndex);\n    const elementsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);\n    const renderElementProps = render && typeof render !== \"function\" ? render.props : {};\n    const contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            activeIndex,\n            onNavigate\n        }), [\n        activeIndex,\n        onNavigate\n    ]);\n    const isGrid = cols > 1;\n    function handleKeyDown(event) {\n        if (!allKeys.includes(event.key)) return;\n        const minIndex = getMinIndex(elementsRef, disabledIndices);\n        const maxIndex = getMaxIndex(elementsRef, disabledIndices);\n        const prevIndex = activeIndex;\n        let nextIndex = activeIndex;\n        if (isGrid) {\n            nextIndex = getGridNavigatedIndex(elementsRef, {\n                event,\n                orientation,\n                loop,\n                cols,\n                disabledIndices,\n                minIndex,\n                maxIndex,\n                prevIndex\n            });\n        }\n        const toEndKeys = {\n            horizontal: [\n                ARROW_RIGHT\n            ],\n            vertical: [\n                ARROW_DOWN\n            ],\n            both: [\n                ARROW_RIGHT,\n                ARROW_DOWN\n            ]\n        }[orientation];\n        const toStartKeys = {\n            horizontal: [\n                ARROW_LEFT\n            ],\n            vertical: [\n                ARROW_UP\n            ],\n            both: [\n                ARROW_LEFT,\n                ARROW_UP\n            ]\n        }[orientation];\n        const preventedKeys = isGrid ? allKeys : ({\n            horizontal: horizontalKeys,\n            vertical: verticalKeys,\n            both: allKeys\n        })[orientation];\n        if (nextIndex === activeIndex && [\n            ...toEndKeys,\n            ...toStartKeys\n        ].includes(event.key)) {\n            if (loop && nextIndex === maxIndex && toEndKeys.includes(event.key)) {\n                nextIndex = minIndex;\n            } else if (loop && nextIndex === minIndex && toStartKeys.includes(event.key)) {\n                nextIndex = maxIndex;\n            } else {\n                nextIndex = findNonDisabledIndex(elementsRef, {\n                    startingIndex: nextIndex,\n                    decrement: toStartKeys.includes(event.key),\n                    disabledIndices\n                });\n            }\n        }\n        if (nextIndex !== activeIndex && !isIndexOutOfBounds(elementsRef, nextIndex)) {\n            event.stopPropagation();\n            if (preventedKeys.includes(event.key)) {\n                event.preventDefault();\n            }\n            onNavigate(nextIndex);\n            // Wait for FocusManager `returnFocus` to execute.\n            queueMicrotask(()=>{\n                enqueueFocus(elementsRef.current[nextIndex]);\n            });\n        }\n    }\n    const computedProps = {\n        ...props,\n        ...renderElementProps,\n        ref: forwardedRef,\n        \"aria-orientation\": orientation === \"both\" ? undefined : orientation,\n        onKeyDown (e) {\n            props.onKeyDown == null || props.onKeyDown(e);\n            renderElementProps.onKeyDown == null || renderElementProps.onKeyDown(e);\n            handleKeyDown(e);\n        }\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(CompositeContext.Provider, {\n        value: contextValue\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingList, {\n        elementsRef: elementsRef\n    }, renderJsx(render, computedProps)));\n});\nconst CompositeItem = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function CompositeItem(_ref2, forwardedRef) {\n    let { render, ...props } = _ref2;\n    const renderElementProps = render && typeof render !== \"function\" ? render.props : {};\n    const { activeIndex, onNavigate } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CompositeContext);\n    const { ref, index } = useListItem();\n    const mergedRef = useMergeRefs([\n        ref,\n        forwardedRef,\n        renderElementProps.ref\n    ]);\n    const isActive = activeIndex === index;\n    const computedProps = {\n        ...props,\n        ...renderElementProps,\n        ref: mergedRef,\n        tabIndex: isActive ? 0 : -1,\n        \"data-active\": isActive ? \"\" : undefined,\n        onFocus (e) {\n            props.onFocus == null || props.onFocus(e);\n            renderElementProps.onFocus == null || renderElementProps.onFocus(e);\n            onNavigate(index);\n        }\n    };\n    return renderJsx(render, computedProps);\n});\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nlet serverHandoffComplete = false;\nlet count = 0;\nconst genId = ()=>\"floating-ui-\" + count++;\nfunction useFloatingId() {\n    const [id, setId] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>serverHandoffComplete ? genId() : undefined);\n    index(()=>{\n        if (id == null) {\n            setId(genId());\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!serverHandoffComplete) {\n            serverHandoffComplete = true;\n        }\n    }, []);\n    return id;\n}\n// `toString()` prevents bundlers from trying to `import { useId } from 'react'`\nconst useReactId = /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)))[/*#__PURE__*/ \"useId\".toString()];\n/**\n * Uses React 18's built-in `useId()` when available, or falls back to a\n * slightly less performant (requiring a double render) implementation for\n * earlier React versions.\n * @see https://floating-ui.com/docs/useId\n */ const useId = useReactId || useFloatingId;\n/**\n * Renders a pointing arrow triangle.\n * @see https://floating-ui.com/docs/FloatingArrow\n */ const FloatingArrow = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function FloatingArrow(_ref, ref) {\n    let { context: { placement, elements: { floating }, middlewareData: { arrow } }, width = 14, height = 7, tipRadius = 0, strokeWidth = 0, staticOffset, stroke, d, style: { transform, ...restStyle } = {}, ...rest } = _ref;\n    if (true) {\n        if (!ref) {\n            console.warn(\"Floating UI: The `ref` prop is required for the `FloatingArrow`\", \"component.\");\n        }\n    }\n    const clipPathId = useId();\n    if (!floating) {\n        return null;\n    }\n    // Strokes must be double the border width, this ensures the stroke's width\n    // works as you'd expect.\n    strokeWidth *= 2;\n    const halfStrokeWidth = strokeWidth / 2;\n    const svgX = width / 2 * (tipRadius / -8 + 1);\n    const svgY = height / 2 * tipRadius / 4;\n    const [side, alignment] = placement.split(\"-\");\n    const isRTL = _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.platform.isRTL(floating);\n    const isCustomShape = !!d;\n    const isVerticalSide = side === \"top\" || side === \"bottom\";\n    const yOffsetProp = staticOffset && alignment === \"end\" ? \"bottom\" : \"top\";\n    let xOffsetProp = staticOffset && alignment === \"end\" ? \"right\" : \"left\";\n    if (staticOffset && isRTL) {\n        xOffsetProp = alignment === \"end\" ? \"left\" : \"right\";\n    }\n    const arrowX = (arrow == null ? void 0 : arrow.x) != null ? staticOffset || arrow.x : \"\";\n    const arrowY = (arrow == null ? void 0 : arrow.y) != null ? staticOffset || arrow.y : \"\";\n    const dValue = d || \"M0,0\" + (\" H\" + width) + (\" L\" + (width - svgX) + \",\" + (height - svgY)) + (\" Q\" + width / 2 + \",\" + height + \" \" + svgX + \",\" + (height - svgY)) + \" Z\";\n    const rotation = {\n        top: isCustomShape ? \"rotate(180deg)\" : \"\",\n        left: isCustomShape ? \"rotate(90deg)\" : \"rotate(-90deg)\",\n        bottom: isCustomShape ? \"\" : \"rotate(180deg)\",\n        right: isCustomShape ? \"rotate(-90deg)\" : \"rotate(90deg)\"\n    }[side];\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", _extends({}, rest, {\n        \"aria-hidden\": true,\n        ref: ref,\n        width: isCustomShape ? width : width + strokeWidth,\n        height: width,\n        viewBox: \"0 0 \" + width + \" \" + (height > width ? height : width),\n        style: {\n            position: \"absolute\",\n            pointerEvents: \"none\",\n            [xOffsetProp]: arrowX,\n            [yOffsetProp]: arrowY,\n            [side]: isVerticalSide || isCustomShape ? \"100%\" : \"calc(100% - \" + strokeWidth / 2 + \"px)\",\n            transform: \"\" + rotation + (transform != null ? transform : \"\"),\n            ...restStyle\n        }\n    }), strokeWidth > 0 && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        clipPath: \"url(#\" + clipPathId + \")\",\n        fill: \"none\",\n        stroke: stroke,\n        strokeWidth: strokeWidth + (d ? 0 : 1),\n        d: dValue\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        stroke: strokeWidth && !d ? rest.fill : \"none\",\n        d: dValue\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"clipPath\", {\n        id: clipPathId\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", {\n        x: -halfStrokeWidth,\n        y: halfStrokeWidth * (isCustomShape ? -1 : 1),\n        width: width + strokeWidth,\n        height: width\n    })));\n});\nfunction createPubSub() {\n    const map = new Map();\n    return {\n        emit (event, data) {\n            var _map$get;\n            (_map$get = map.get(event)) == null || _map$get.forEach((handler)=>handler(data));\n        },\n        on (event, listener) {\n            map.set(event, [\n                ...map.get(event) || [],\n                listener\n            ]);\n        },\n        off (event, listener) {\n            var _map$get2;\n            map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter((l)=>l !== listener)) || []);\n        }\n    };\n}\nconst FloatingNodeContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst FloatingTreeContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst useFloatingParentNodeId = ()=>{\n    var _React$useContext;\n    return ((_React$useContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;\n};\nconst useFloatingTree = ()=>react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingTreeContext);\n/**\n * Registers a node into the floating tree, returning its id.\n */ function useFloatingNodeId(customParentId) {\n    const id = useId();\n    const tree = useFloatingTree();\n    const reactParentId = useFloatingParentNodeId();\n    const parentId = customParentId || reactParentId;\n    index(()=>{\n        const node = {\n            id,\n            parentId\n        };\n        tree == null || tree.addNode(node);\n        return ()=>{\n            tree == null || tree.removeNode(node);\n        };\n    }, [\n        tree,\n        id,\n        parentId\n    ]);\n    return id;\n}\n/**\n * Provides parent node context for nested floating elements.\n * @see https://floating-ui.com/docs/FloatingTree\n */ function FloatingNode(_ref) {\n    let { children, id } = _ref;\n    const parentId = useFloatingParentNodeId();\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingNodeContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n                id,\n                parentId\n            }), [\n            id,\n            parentId\n        ])\n    }, children);\n}\n/**\n * Provides context for nested floating elements when they are not children of\n * each other on the DOM (i.e. portalled to a common node, rather than their\n * respective parent).\n * @see https://floating-ui.com/docs/FloatingTree\n */ function FloatingTree(_ref2) {\n    let { children } = _ref2;\n    const nodesRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);\n    const addNode = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        nodesRef.current = [\n            ...nodesRef.current,\n            node\n        ];\n    }, []);\n    const removeNode = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        nodesRef.current = nodesRef.current.filter((n)=>n !== node);\n    }, []);\n    const events = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>createPubSub())[0];\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingTreeContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n                nodesRef,\n                addNode,\n                removeNode,\n                events\n            }), [\n            nodesRef,\n            addNode,\n            removeNode,\n            events\n        ])\n    }, children);\n}\nfunction createAttribute(name) {\n    return \"data-floating-ui-\" + name;\n}\nfunction useLatestRef(value) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n    index(()=>{\n        ref.current = value;\n    });\n    return ref;\n}\nconst safePolygonIdentifier = /*#__PURE__*/ createAttribute(\"safe-polygon\");\nfunction getDelay(value, prop, pointerType) {\n    if (pointerType && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMouseLikePointerType)(pointerType)) {\n        return 0;\n    }\n    if (typeof value === \"number\") {\n        return value;\n    }\n    return value == null ? void 0 : value[prop];\n}\n/**\n * Opens the floating element while hovering over the reference element, like\n * CSS `:hover`.\n * @see https://floating-ui.com/docs/useHover\n */ function useHover(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, onOpenChange, dataRef, events, elements: { domReference, floating }, refs } = context;\n    const { enabled = true, delay = 0, handleClose = null, mouseOnly = false, restMs = 0, move = true } = props;\n    const tree = useFloatingTree();\n    const parentId = useFloatingParentNodeId();\n    const handleCloseRef = useLatestRef(handleClose);\n    const delayRef = useLatestRef(delay);\n    const pointerTypeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const timeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const handlerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const restTimeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const blockMouseMoveRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n    const performedPointerEventsMutationRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const unbindMouseMoveRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(()=>{});\n    const isHoverOpen = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        var _dataRef$current$open;\n        const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;\n        return (type == null ? void 0 : type.includes(\"mouse\")) && type !== \"mousedown\";\n    }, [\n        dataRef\n    ]);\n    // When closing before opening, clear the delay timeouts to cancel it\n    // from showing.\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled) {\n            return;\n        }\n        function onOpenChange(_ref) {\n            let { open } = _ref;\n            if (!open) {\n                clearTimeout(timeoutRef.current);\n                clearTimeout(restTimeoutRef.current);\n                blockMouseMoveRef.current = true;\n            }\n        }\n        events.on(\"openchange\", onOpenChange);\n        return ()=>{\n            events.off(\"openchange\", onOpenChange);\n        };\n    }, [\n        enabled,\n        events\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled || !handleCloseRef.current || !open) {\n            return;\n        }\n        function onLeave(event) {\n            if (isHoverOpen()) {\n                onOpenChange(false, event, \"hover\");\n            }\n        }\n        const html = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating).documentElement;\n        html.addEventListener(\"mouseleave\", onLeave);\n        return ()=>{\n            html.removeEventListener(\"mouseleave\", onLeave);\n        };\n    }, [\n        floating,\n        open,\n        onOpenChange,\n        enabled,\n        handleCloseRef,\n        dataRef,\n        isHoverOpen\n    ]);\n    const closeWithDelay = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(event, runElseBranch, reason) {\n        if (runElseBranch === void 0) {\n            runElseBranch = true;\n        }\n        if (reason === void 0) {\n            reason = \"hover\";\n        }\n        const closeDelay = getDelay(delayRef.current, \"close\", pointerTypeRef.current);\n        if (closeDelay && !handlerRef.current) {\n            clearTimeout(timeoutRef.current);\n            timeoutRef.current = setTimeout(()=>onOpenChange(false, event, reason), closeDelay);\n        } else if (runElseBranch) {\n            clearTimeout(timeoutRef.current);\n            onOpenChange(false, event, reason);\n        }\n    }, [\n        delayRef,\n        onOpenChange\n    ]);\n    const cleanupMouseMoveHandler = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        unbindMouseMoveRef.current();\n        handlerRef.current = undefined;\n    }, []);\n    const clearPointerEvents = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        if (performedPointerEventsMutationRef.current) {\n            const body = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(refs.floating.current).body;\n            body.style.pointerEvents = \"\";\n            body.removeAttribute(safePolygonIdentifier);\n            performedPointerEventsMutationRef.current = false;\n        }\n    }, [\n        refs\n    ]);\n    // Registering the mouse events on the reference directly to bypass React's\n    // delegation system. If the cursor was on a disabled element and then entered\n    // the reference (no gap), `mouseenter` doesn't fire in the delegation system.\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled) {\n            return;\n        }\n        function isClickLikeOpenEvent() {\n            return dataRef.current.openEvent ? [\n                \"click\",\n                \"mousedown\"\n            ].includes(dataRef.current.openEvent.type) : false;\n        }\n        function onMouseEnter(event) {\n            clearTimeout(timeoutRef.current);\n            blockMouseMoveRef.current = false;\n            if (mouseOnly && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMouseLikePointerType)(pointerTypeRef.current) || restMs > 0 && getDelay(delayRef.current, \"open\") === 0) {\n                return;\n            }\n            const openDelay = getDelay(delayRef.current, \"open\", pointerTypeRef.current);\n            if (openDelay) {\n                timeoutRef.current = setTimeout(()=>{\n                    onOpenChange(true, event, \"hover\");\n                }, openDelay);\n            } else {\n                onOpenChange(true, event, \"hover\");\n            }\n        }\n        function onMouseLeave(event) {\n            if (isClickLikeOpenEvent()) {\n                return;\n            }\n            unbindMouseMoveRef.current();\n            const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating);\n            clearTimeout(restTimeoutRef.current);\n            if (handleCloseRef.current) {\n                // Prevent clearing `onScrollMouseLeave` timeout.\n                if (!open) {\n                    clearTimeout(timeoutRef.current);\n                }\n                handlerRef.current = handleCloseRef.current({\n                    ...context,\n                    tree,\n                    x: event.clientX,\n                    y: event.clientY,\n                    onClose () {\n                        clearPointerEvents();\n                        cleanupMouseMoveHandler();\n                        closeWithDelay(event, true, \"safe-polygon\");\n                    }\n                });\n                const handler = handlerRef.current;\n                doc.addEventListener(\"mousemove\", handler);\n                unbindMouseMoveRef.current = ()=>{\n                    doc.removeEventListener(\"mousemove\", handler);\n                };\n                return;\n            }\n            // Allow interactivity without `safePolygon` on touch devices. With a\n            // pointer, a short close delay is an alternative, so it should work\n            // consistently.\n            const shouldClose = pointerTypeRef.current === \"touch\" ? !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(floating, event.relatedTarget) : true;\n            if (shouldClose) {\n                closeWithDelay(event);\n            }\n        }\n        // Ensure the floating element closes after scrolling even if the pointer\n        // did not move.\n        // https://github.com/floating-ui/floating-ui/discussions/1692\n        function onScrollMouseLeave(event) {\n            if (isClickLikeOpenEvent()) {\n                return;\n            }\n            handleCloseRef.current == null || handleCloseRef.current({\n                ...context,\n                tree,\n                x: event.clientX,\n                y: event.clientY,\n                onClose () {\n                    clearPointerEvents();\n                    cleanupMouseMoveHandler();\n                    closeWithDelay(event);\n                }\n            })(event);\n        }\n        if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(domReference)) {\n            const ref = domReference;\n            open && ref.addEventListener(\"mouseleave\", onScrollMouseLeave);\n            floating == null || floating.addEventListener(\"mouseleave\", onScrollMouseLeave);\n            move && ref.addEventListener(\"mousemove\", onMouseEnter, {\n                once: true\n            });\n            ref.addEventListener(\"mouseenter\", onMouseEnter);\n            ref.addEventListener(\"mouseleave\", onMouseLeave);\n            return ()=>{\n                open && ref.removeEventListener(\"mouseleave\", onScrollMouseLeave);\n                floating == null || floating.removeEventListener(\"mouseleave\", onScrollMouseLeave);\n                move && ref.removeEventListener(\"mousemove\", onMouseEnter);\n                ref.removeEventListener(\"mouseenter\", onMouseEnter);\n                ref.removeEventListener(\"mouseleave\", onMouseLeave);\n            };\n        }\n    }, [\n        domReference,\n        floating,\n        enabled,\n        context,\n        mouseOnly,\n        restMs,\n        move,\n        closeWithDelay,\n        cleanupMouseMoveHandler,\n        clearPointerEvents,\n        onOpenChange,\n        open,\n        tree,\n        delayRef,\n        handleCloseRef,\n        dataRef\n    ]);\n    // Block pointer-events of every element other than the reference and floating\n    // while the floating element is open and has a `handleClose` handler. Also\n    // handles nested floating elements.\n    // https://github.com/floating-ui/floating-ui/issues/1722\n    index(()=>{\n        var _handleCloseRef$curre;\n        if (!enabled) {\n            return;\n        }\n        if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && _handleCloseRef$curre.__options.blockPointerEvents && isHoverOpen()) {\n            const body = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating).body;\n            body.setAttribute(safePolygonIdentifier, \"\");\n            body.style.pointerEvents = \"none\";\n            performedPointerEventsMutationRef.current = true;\n            if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(domReference) && floating) {\n                var _tree$nodesRef$curren;\n                const ref = domReference;\n                const parentFloating = tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find((node)=>node.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren.elements.floating;\n                if (parentFloating) {\n                    parentFloating.style.pointerEvents = \"\";\n                }\n                ref.style.pointerEvents = \"auto\";\n                floating.style.pointerEvents = \"auto\";\n                return ()=>{\n                    ref.style.pointerEvents = \"\";\n                    floating.style.pointerEvents = \"\";\n                };\n            }\n        }\n    }, [\n        enabled,\n        open,\n        parentId,\n        floating,\n        domReference,\n        tree,\n        handleCloseRef,\n        dataRef,\n        isHoverOpen\n    ]);\n    index(()=>{\n        if (!open) {\n            pointerTypeRef.current = undefined;\n            cleanupMouseMoveHandler();\n            clearPointerEvents();\n        }\n    }, [\n        open,\n        cleanupMouseMoveHandler,\n        clearPointerEvents\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        return ()=>{\n            cleanupMouseMoveHandler();\n            clearTimeout(timeoutRef.current);\n            clearTimeout(restTimeoutRef.current);\n            clearPointerEvents();\n        };\n    }, [\n        enabled,\n        domReference,\n        cleanupMouseMoveHandler,\n        clearPointerEvents\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) {\n            return {};\n        }\n        function setPointerRef(event) {\n            pointerTypeRef.current = event.pointerType;\n        }\n        return {\n            reference: {\n                onPointerDown: setPointerRef,\n                onPointerEnter: setPointerRef,\n                onMouseMove (event) {\n                    if (open || restMs === 0) {\n                        return;\n                    }\n                    clearTimeout(restTimeoutRef.current);\n                    restTimeoutRef.current = setTimeout(()=>{\n                        if (!blockMouseMoveRef.current) {\n                            onOpenChange(true, event.nativeEvent, \"hover\");\n                        }\n                    }, restMs);\n                }\n            },\n            floating: {\n                onMouseEnter () {\n                    clearTimeout(timeoutRef.current);\n                },\n                onMouseLeave (event) {\n                    closeWithDelay(event.nativeEvent, false);\n                }\n            }\n        };\n    }, [\n        enabled,\n        restMs,\n        open,\n        onOpenChange,\n        closeWithDelay\n    ]);\n}\nconst FloatingDelayGroupContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    delay: 0,\n    initialDelay: 0,\n    timeoutMs: 0,\n    currentId: null,\n    setCurrentId: ()=>{},\n    setState: ()=>{},\n    isInstantPhase: false\n});\nconst useDelayGroupContext = ()=>react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingDelayGroupContext);\n/**\n * Provides context for a group of floating elements that should share a\n * `delay`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */ const FloatingDelayGroup = (_ref)=>{\n    let { children, delay, timeoutMs = 0 } = _ref;\n    const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useReducer((prev, next)=>({\n            ...prev,\n            ...next\n        }), {\n        delay,\n        timeoutMs,\n        initialDelay: delay,\n        currentId: null,\n        isInstantPhase: false\n    });\n    const initialCurrentIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const setCurrentId = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((currentId)=>{\n        setState({\n            currentId\n        });\n    }, []);\n    index(()=>{\n        if (state.currentId) {\n            if (initialCurrentIdRef.current === null) {\n                initialCurrentIdRef.current = state.currentId;\n            } else {\n                setState({\n                    isInstantPhase: true\n                });\n            }\n        } else {\n            setState({\n                isInstantPhase: false\n            });\n            initialCurrentIdRef.current = null;\n        }\n    }, [\n        state.currentId\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FloatingDelayGroupContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n                ...state,\n                setState,\n                setCurrentId\n            }), [\n            state,\n            setState,\n            setCurrentId\n        ])\n    }, children);\n};\nconst useDelayGroup = (_ref2, _ref3)=>{\n    let { open, onOpenChange } = _ref2;\n    let { id } = _ref3;\n    const { currentId, setCurrentId, initialDelay, setState, timeoutMs } = useDelayGroupContext();\n    index(()=>{\n        if (currentId) {\n            setState({\n                delay: {\n                    open: 1,\n                    close: getDelay(initialDelay, \"close\")\n                }\n            });\n            if (currentId !== id) {\n                onOpenChange(false);\n            }\n        }\n    }, [\n        id,\n        onOpenChange,\n        setState,\n        currentId,\n        initialDelay\n    ]);\n    index(()=>{\n        function unset() {\n            onOpenChange(false);\n            setState({\n                delay: initialDelay,\n                currentId: null\n            });\n        }\n        if (!open && currentId === id) {\n            if (timeoutMs) {\n                const timeout = window.setTimeout(unset, timeoutMs);\n                return ()=>{\n                    clearTimeout(timeout);\n                };\n            } else {\n                unset();\n            }\n        }\n    }, [\n        open,\n        setState,\n        currentId,\n        id,\n        onOpenChange,\n        initialDelay,\n        timeoutMs\n    ]);\n    index(()=>{\n        if (open) {\n            setCurrentId(id);\n        }\n    }, [\n        open,\n        setCurrentId,\n        id\n    ]);\n};\nfunction getAncestors(nodes, id) {\n    var _nodes$find;\n    let allAncestors = [];\n    let currentParentId = (_nodes$find = nodes.find((node)=>node.id === id)) == null ? void 0 : _nodes$find.parentId;\n    while(currentParentId){\n        const currentNode = nodes.find((node)=>node.id === currentParentId);\n        currentParentId = currentNode == null ? void 0 : currentNode.parentId;\n        if (currentNode) {\n            allAncestors = allAncestors.concat(currentNode);\n        }\n    }\n    return allAncestors;\n}\nfunction getChildren(nodes, id) {\n    let allChildren = nodes.filter((node)=>{\n        var _node$context;\n        return node.parentId === id && ((_node$context = node.context) == null ? void 0 : _node$context.open);\n    });\n    let currentChildren = allChildren;\n    while(currentChildren.length){\n        currentChildren = nodes.filter((node)=>{\n            var _currentChildren;\n            return (_currentChildren = currentChildren) == null ? void 0 : _currentChildren.some((n)=>{\n                var _node$context2;\n                return node.parentId === n.id && ((_node$context2 = node.context) == null ? void 0 : _node$context2.open);\n            });\n        });\n        allChildren = allChildren.concat(currentChildren);\n    }\n    return allChildren;\n}\nfunction getDeepestNode(nodes, id) {\n    let deepestNodeId;\n    let maxDepth = -1;\n    function findDeepest(nodeId, depth) {\n        if (depth > maxDepth) {\n            deepestNodeId = nodeId;\n            maxDepth = depth;\n        }\n        const children = getChildren(nodes, nodeId);\n        children.forEach((child)=>{\n            findDeepest(child.id, depth + 1);\n        });\n    }\n    findDeepest(id, 0);\n    return nodes.find((node)=>node.id === deepestNodeId);\n}\n// Modified to add conditional `aria-hidden` support:\n// https://github.com/theKashey/aria-hidden/blob/9220c8f4a4fd35f63bee5510a9f41a37264382d4/src/index.ts\nlet counterMap = /*#__PURE__*/ new WeakMap();\nlet uncontrolledElementsSet = /*#__PURE__*/ new WeakSet();\nlet markerMap = {};\nlet lockCount = 0;\nconst supportsInert = ()=>typeof HTMLElement !== \"undefined\" && \"inert\" in HTMLElement.prototype;\nconst unwrapHost = (node)=>node && (node.host || unwrapHost(node.parentNode));\nconst correctElements = (parent, targets)=>targets.map((target)=>{\n        if (parent.contains(target)) {\n            return target;\n        }\n        const correctedTarget = unwrapHost(target);\n        if (parent.contains(correctedTarget)) {\n            return correctedTarget;\n        }\n        return null;\n    }).filter((x)=>x != null);\nfunction applyAttributeToOthers(uncorrectedAvoidElements, body, ariaHidden, inert) {\n    const markerName = \"data-floating-ui-inert\";\n    const controlAttribute = inert ? \"inert\" : ariaHidden ? \"aria-hidden\" : null;\n    const avoidElements = correctElements(body, uncorrectedAvoidElements);\n    const elementsToKeep = new Set();\n    const elementsToStop = new Set(avoidElements);\n    const hiddenElements = [];\n    if (!markerMap[markerName]) {\n        markerMap[markerName] = new WeakMap();\n    }\n    const markerCounter = markerMap[markerName];\n    avoidElements.forEach(keep);\n    deep(body);\n    elementsToKeep.clear();\n    function keep(el) {\n        if (!el || elementsToKeep.has(el)) {\n            return;\n        }\n        elementsToKeep.add(el);\n        el.parentNode && keep(el.parentNode);\n    }\n    function deep(parent) {\n        if (!parent || elementsToStop.has(parent)) {\n            return;\n        }\n        Array.prototype.forEach.call(parent.children, (node)=>{\n            if (elementsToKeep.has(node)) {\n                deep(node);\n            } else {\n                const attr = controlAttribute ? node.getAttribute(controlAttribute) : null;\n                const alreadyHidden = attr !== null && attr !== \"false\";\n                const counterValue = (counterMap.get(node) || 0) + 1;\n                const markerValue = (markerCounter.get(node) || 0) + 1;\n                counterMap.set(node, counterValue);\n                markerCounter.set(node, markerValue);\n                hiddenElements.push(node);\n                if (counterValue === 1 && alreadyHidden) {\n                    uncontrolledElementsSet.add(node);\n                }\n                if (markerValue === 1) {\n                    node.setAttribute(markerName, \"\");\n                }\n                if (!alreadyHidden && controlAttribute) {\n                    node.setAttribute(controlAttribute, \"true\");\n                }\n            }\n        });\n    }\n    lockCount++;\n    return ()=>{\n        hiddenElements.forEach((element)=>{\n            const counterValue = (counterMap.get(element) || 0) - 1;\n            const markerValue = (markerCounter.get(element) || 0) - 1;\n            counterMap.set(element, counterValue);\n            markerCounter.set(element, markerValue);\n            if (!counterValue) {\n                if (!uncontrolledElementsSet.has(element) && controlAttribute) {\n                    element.removeAttribute(controlAttribute);\n                }\n                uncontrolledElementsSet.delete(element);\n            }\n            if (!markerValue) {\n                element.removeAttribute(markerName);\n            }\n        });\n        lockCount--;\n        if (!lockCount) {\n            counterMap = new WeakMap();\n            counterMap = new WeakMap();\n            uncontrolledElementsSet = new WeakSet();\n            markerMap = {};\n        }\n    };\n}\nfunction markOthers(avoidElements, ariaHidden, inert) {\n    if (ariaHidden === void 0) {\n        ariaHidden = false;\n    }\n    if (inert === void 0) {\n        inert = false;\n    }\n    const body = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(avoidElements[0]).body;\n    return applyAttributeToOthers(avoidElements.concat(Array.from(body.querySelectorAll(\"[aria-live]\"))), body, ariaHidden, inert);\n}\nconst getTabbableOptions = ()=>({\n        getShadowRoot: true,\n        displayCheck: // JSDOM does not support the `tabbable` library. To solve this we can\n        // check if `ResizeObserver` is a real function (not polyfilled), which\n        // determines if the current environment is JSDOM-like.\n        typeof ResizeObserver === \"function\" && ResizeObserver.toString().includes(\"[native code]\") ? \"full\" : \"none\"\n    });\nfunction getTabbableIn(container, direction) {\n    const allTabbable = (0,tabbable__WEBPACK_IMPORTED_MODULE_8__.tabbable)(container, getTabbableOptions());\n    if (direction === \"prev\") {\n        allTabbable.reverse();\n    }\n    const activeIndex = allTabbable.indexOf((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(container)));\n    const nextTabbableElements = allTabbable.slice(activeIndex + 1);\n    return nextTabbableElements[0];\n}\nfunction getNextTabbable() {\n    return getTabbableIn(document.body, \"next\");\n}\nfunction getPreviousTabbable() {\n    return getTabbableIn(document.body, \"prev\");\n}\nfunction isOutsideEvent(event, container) {\n    const containerElement = container || event.currentTarget;\n    const relatedTarget = event.relatedTarget;\n    return !relatedTarget || !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(containerElement, relatedTarget);\n}\nfunction disableFocusInside(container) {\n    const tabbableElements = (0,tabbable__WEBPACK_IMPORTED_MODULE_8__.tabbable)(container, getTabbableOptions());\n    tabbableElements.forEach((element)=>{\n        element.dataset.tabindex = element.getAttribute(\"tabindex\") || \"\";\n        element.setAttribute(\"tabindex\", \"-1\");\n    });\n}\nfunction enableFocusInside(container) {\n    const elements = container.querySelectorAll(\"[data-tabindex]\");\n    elements.forEach((element)=>{\n        const tabindex = element.dataset.tabindex;\n        delete element.dataset.tabindex;\n        if (tabindex) {\n            element.setAttribute(\"tabindex\", tabindex);\n        } else {\n            element.removeAttribute(\"tabindex\");\n        }\n    });\n}\n// See Diego Haz's Sandbox for making this logic work well on Safari/iOS:\n// https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/FocusTrap.tsx\nconst HIDDEN_STYLES = {\n    border: 0,\n    clip: \"rect(0 0 0 0)\",\n    height: \"1px\",\n    margin: \"-1px\",\n    overflow: \"hidden\",\n    padding: 0,\n    position: \"fixed\",\n    whiteSpace: \"nowrap\",\n    width: \"1px\",\n    top: 0,\n    left: 0\n};\nlet timeoutId;\nfunction setActiveElementOnTab(event) {\n    if (event.key === \"Tab\") {\n        event.target;\n        clearTimeout(timeoutId);\n    }\n}\nconst FocusGuard = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function FocusGuard(props, ref) {\n    const [role, setRole] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    index(()=>{\n        if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isSafari)()) {\n            // Unlike other screen readers such as NVDA and JAWS, the virtual cursor\n            // on VoiceOver does trigger the onFocus event, so we can use the focus\n            // trap element. On Safari, only buttons trigger the onFocus event.\n            // NB: \"group\" role in the Sandbox no longer appears to work, must be a\n            // button role.\n            setRole(\"button\");\n        }\n        document.addEventListener(\"keydown\", setActiveElementOnTab);\n        return ()=>{\n            document.removeEventListener(\"keydown\", setActiveElementOnTab);\n        };\n    }, []);\n    const restProps = {\n        ref,\n        tabIndex: 0,\n        // Role is only for VoiceOver\n        role,\n        \"aria-hidden\": role ? undefined : true,\n        [createAttribute(\"focus-guard\")]: \"\",\n        style: HIDDEN_STYLES\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", _extends({}, props, restProps));\n});\nconst PortalContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction useFloatingPortalNode(_temp) {\n    let { id, root } = _temp === void 0 ? {} : _temp;\n    const [portalNode, setPortalNode] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const uniqueId = useId();\n    const portalContext = usePortalContext();\n    const data = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            id,\n            root,\n            portalContext,\n            uniqueId\n        }), [\n        id,\n        root,\n        portalContext,\n        uniqueId\n    ]);\n    const dataRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    index(()=>{\n        return ()=>{\n            portalNode == null || portalNode.remove();\n        };\n    }, [\n        portalNode,\n        data\n    ]);\n    index(()=>{\n        if (dataRef.current === data) return;\n        dataRef.current = data;\n        const { id, root, portalContext, uniqueId } = data;\n        const existingIdRoot = id ? document.getElementById(id) : null;\n        const attr = createAttribute(\"portal\");\n        if (existingIdRoot) {\n            const subRoot = document.createElement(\"div\");\n            subRoot.id = uniqueId;\n            subRoot.setAttribute(attr, \"\");\n            existingIdRoot.appendChild(subRoot);\n            setPortalNode(subRoot);\n        } else {\n            let container = root || (portalContext == null ? void 0 : portalContext.portalNode);\n            if (container && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(container)) container = container.current;\n            container = container || document.body;\n            let idWrapper = null;\n            if (id) {\n                idWrapper = document.createElement(\"div\");\n                idWrapper.id = id;\n                container.appendChild(idWrapper);\n            }\n            const subRoot = document.createElement(\"div\");\n            subRoot.id = uniqueId;\n            subRoot.setAttribute(attr, \"\");\n            container = idWrapper || container;\n            container.appendChild(subRoot);\n            setPortalNode(subRoot);\n        }\n    }, [\n        data\n    ]);\n    return portalNode;\n}\n/**\n * Portals the floating element into a given container element — by default,\n * outside of the app root and into the body.\n * @see https://floating-ui.com/docs/FloatingPortal\n */ function FloatingPortal(_ref) {\n    let { children, id, root = null, preserveTabOrder = true } = _ref;\n    const portalNode = useFloatingPortalNode({\n        id,\n        root\n    });\n    const [focusManagerState, setFocusManagerState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const beforeOutsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const afterOutsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const beforeInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const afterInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const shouldRenderGuards = // The FocusManager and therefore floating element are currently open/\n    // rendered.\n    !!focusManagerState && // Guards are only for non-modal focus management.\n    !focusManagerState.modal && // Don't render if unmount is transitioning.\n    focusManagerState.open && preserveTabOrder && !!(root || portalNode);\n    // https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/TabbablePortal.tsx\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!portalNode || !preserveTabOrder || focusManagerState != null && focusManagerState.modal) {\n            return;\n        }\n        // Make sure elements inside the portal element are tabbable only when the\n        // portal has already been focused, either by tabbing into a focus trap\n        // element outside or using the mouse.\n        function onFocus(event) {\n            if (portalNode && isOutsideEvent(event)) {\n                const focusing = event.type === \"focusin\";\n                const manageFocus = focusing ? enableFocusInside : disableFocusInside;\n                manageFocus(portalNode);\n            }\n        }\n        // Listen to the event on the capture phase so they run before the focus\n        // trap elements onFocus prop is called.\n        portalNode.addEventListener(\"focusin\", onFocus, true);\n        portalNode.addEventListener(\"focusout\", onFocus, true);\n        return ()=>{\n            portalNode.removeEventListener(\"focusin\", onFocus, true);\n            portalNode.removeEventListener(\"focusout\", onFocus, true);\n        };\n    }, [\n        portalNode,\n        preserveTabOrder,\n        focusManagerState == null ? void 0 : focusManagerState.modal\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PortalContext.Provider, {\n        value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n                preserveTabOrder,\n                beforeOutsideRef,\n                afterOutsideRef,\n                beforeInsideRef,\n                afterInsideRef,\n                portalNode,\n                setFocusManagerState\n            }), [\n            preserveTabOrder,\n            portalNode\n        ])\n    }, shouldRenderGuards && portalNode && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n        \"data-type\": \"outside\",\n        ref: beforeOutsideRef,\n        onFocus: (event)=>{\n            if (isOutsideEvent(event, portalNode)) {\n                var _beforeInsideRef$curr;\n                (_beforeInsideRef$curr = beforeInsideRef.current) == null || _beforeInsideRef$curr.focus();\n            } else {\n                const prevTabbable = getPreviousTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n                prevTabbable == null || prevTabbable.focus();\n            }\n        }\n    }), shouldRenderGuards && portalNode && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", {\n        \"aria-owns\": portalNode.id,\n        style: HIDDEN_STYLES\n    }), portalNode && /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_5__.createPortal)(children, portalNode), shouldRenderGuards && portalNode && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n        \"data-type\": \"outside\",\n        ref: afterOutsideRef,\n        onFocus: (event)=>{\n            if (isOutsideEvent(event, portalNode)) {\n                var _afterInsideRef$curre;\n                (_afterInsideRef$curre = afterInsideRef.current) == null || _afterInsideRef$curre.focus();\n            } else {\n                const nextTabbable = getNextTabbable() || (focusManagerState == null ? void 0 : focusManagerState.refs.domReference.current);\n                nextTabbable == null || nextTabbable.focus();\n                (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false, event.nativeEvent));\n            }\n        }\n    }));\n}\nconst usePortalContext = ()=>react__WEBPACK_IMPORTED_MODULE_0__.useContext(PortalContext);\nconst LIST_LIMIT = 20;\nlet previouslyFocusedElements = [];\nfunction addPreviouslyFocusedElement(element) {\n    previouslyFocusedElements = previouslyFocusedElements.filter((el)=>el.isConnected);\n    if (element && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getNodeName)(element) !== \"body\") {\n        previouslyFocusedElements.push(element);\n        if (previouslyFocusedElements.length > LIST_LIMIT) {\n            previouslyFocusedElements = previouslyFocusedElements.slice(-LIST_LIMIT);\n        }\n    }\n}\nfunction getPreviouslyFocusedElement() {\n    return previouslyFocusedElements.slice().reverse().find((el)=>el.isConnected);\n}\nconst VisuallyHiddenDismiss = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function VisuallyHiddenDismiss(props, ref) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", _extends({}, props, {\n        type: \"button\",\n        ref: ref,\n        tabIndex: -1,\n        style: HIDDEN_STYLES\n    }));\n});\n/**\n * Provides focus management for the floating element.\n * @see https://floating-ui.com/docs/FloatingFocusManager\n */ function FloatingFocusManager(props) {\n    const { context, children, disabled = false, order = [\n        \"content\"\n    ], guards: _guards = true, initialFocus = 0, returnFocus = true, modal = true, visuallyHiddenDismiss = false, closeOnFocusOut = true } = props;\n    const { open, refs, nodeId, onOpenChange, events, dataRef, elements: { domReference, floating } } = context;\n    const ignoreInitialFocus = typeof initialFocus === \"number\" && initialFocus < 0;\n    // If the reference is a combobox and is typeable (e.g. input/textarea),\n    // there are different focus semantics. The guards should not be rendered, but\n    // aria-hidden should be applied to all nodes still. Further, the visually\n    // hidden dismiss button should only appear at the end of the list, not the\n    // start.\n    const isUntrappedTypeableCombobox = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isTypeableCombobox)(domReference) && ignoreInitialFocus;\n    // Force the guards to be rendered if the `inert` attribute is not supported.\n    const guards = supportsInert() ? _guards : true;\n    const orderRef = useLatestRef(order);\n    const initialFocusRef = useLatestRef(initialFocus);\n    const returnFocusRef = useLatestRef(returnFocus);\n    const tree = useFloatingTree();\n    const portalContext = usePortalContext();\n    const startDismissButtonRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const endDismissButtonRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const preventReturnFocusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const isPointerDownRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const isInsidePortal = portalContext != null;\n    const getTabbableContent = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(container) {\n        if (container === void 0) {\n            container = floating;\n        }\n        return container ? (0,tabbable__WEBPACK_IMPORTED_MODULE_8__.tabbable)(container, getTabbableOptions()) : [];\n    }, [\n        floating\n    ]);\n    const getTabbableElements = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((container)=>{\n        const content = getTabbableContent(container);\n        return orderRef.current.map((type)=>{\n            if (domReference && type === \"reference\") {\n                return domReference;\n            }\n            if (floating && type === \"floating\") {\n                return floating;\n            }\n            return content;\n        }).filter(Boolean).flat();\n    }, [\n        domReference,\n        floating,\n        orderRef,\n        getTabbableContent\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (disabled || !modal) return;\n        function onKeyDown(event) {\n            if (event.key === \"Tab\") {\n                // The focus guards have nothing to focus, so we need to stop the event.\n                if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(floating, (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating))) && getTabbableContent().length === 0 && !isUntrappedTypeableCombobox) {\n                    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                }\n                const els = getTabbableElements();\n                const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event);\n                if (orderRef.current[0] === \"reference\" && target === domReference) {\n                    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                    if (event.shiftKey) {\n                        enqueueFocus(els[els.length - 1]);\n                    } else {\n                        enqueueFocus(els[1]);\n                    }\n                }\n                if (orderRef.current[1] === \"floating\" && target === floating && event.shiftKey) {\n                    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                    enqueueFocus(els[0]);\n                }\n            }\n        }\n        const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating);\n        doc.addEventListener(\"keydown\", onKeyDown);\n        return ()=>{\n            doc.removeEventListener(\"keydown\", onKeyDown);\n        };\n    }, [\n        disabled,\n        domReference,\n        floating,\n        modal,\n        orderRef,\n        refs,\n        isUntrappedTypeableCombobox,\n        getTabbableContent,\n        getTabbableElements\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (disabled || !closeOnFocusOut) return;\n        // In Safari, buttons lose focus when pressing them.\n        function handlePointerDown() {\n            isPointerDownRef.current = true;\n            setTimeout(()=>{\n                isPointerDownRef.current = false;\n            });\n        }\n        function handleFocusOutside(event) {\n            const relatedTarget = event.relatedTarget;\n            queueMicrotask(()=>{\n                const movedToUnrelatedNode = !((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(domReference, relatedTarget) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(floating, relatedTarget) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(relatedTarget, floating) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute(createAttribute(\"focus-guard\")) || tree && (getChildren(tree.nodesRef.current, nodeId).find((node)=>{\n                    var _node$context, _node$context2;\n                    return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)((_node$context = node.context) == null ? void 0 : _node$context.elements.floating, relatedTarget) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)((_node$context2 = node.context) == null ? void 0 : _node$context2.elements.domReference, relatedTarget);\n                }) || getAncestors(tree.nodesRef.current, nodeId).find((node)=>{\n                    var _node$context3, _node$context4;\n                    return ((_node$context3 = node.context) == null ? void 0 : _node$context3.elements.floating) === relatedTarget || ((_node$context4 = node.context) == null ? void 0 : _node$context4.elements.domReference) === relatedTarget;\n                })));\n                // Focus did not move inside the floating tree, and there are no tabbable\n                // portal guards to handle closing.\n                if (relatedTarget && movedToUnrelatedNode && !isPointerDownRef.current && // Fix React 18 Strict Mode returnFocus due to double rendering.\n                relatedTarget !== getPreviouslyFocusedElement()) {\n                    preventReturnFocusRef.current = true;\n                    onOpenChange(false, event);\n                }\n            });\n        }\n        if (floating && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(domReference)) {\n            domReference.addEventListener(\"focusout\", handleFocusOutside);\n            domReference.addEventListener(\"pointerdown\", handlePointerDown);\n            !modal && floating.addEventListener(\"focusout\", handleFocusOutside);\n            return ()=>{\n                domReference.removeEventListener(\"focusout\", handleFocusOutside);\n                domReference.removeEventListener(\"pointerdown\", handlePointerDown);\n                !modal && floating.removeEventListener(\"focusout\", handleFocusOutside);\n            };\n        }\n    }, [\n        disabled,\n        domReference,\n        floating,\n        modal,\n        nodeId,\n        tree,\n        portalContext,\n        onOpenChange,\n        closeOnFocusOut\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        var _portalContext$portal;\n        if (disabled) return;\n        // Don't hide portals nested within the parent portal.\n        const portalNodes = Array.from((portalContext == null || (_portalContext$portal = portalContext.portalNode) == null ? void 0 : _portalContext$portal.querySelectorAll(\"[\" + createAttribute(\"portal\") + \"]\")) || []);\n        if (floating) {\n            const insideElements = [\n                floating,\n                ...portalNodes,\n                startDismissButtonRef.current,\n                endDismissButtonRef.current,\n                orderRef.current.includes(\"reference\") || isUntrappedTypeableCombobox ? domReference : null\n            ].filter((x)=>x != null);\n            const cleanup = modal || isUntrappedTypeableCombobox ? markOthers(insideElements, guards, !guards) : markOthers(insideElements);\n            return ()=>{\n                cleanup();\n            };\n        }\n    }, [\n        disabled,\n        domReference,\n        floating,\n        modal,\n        orderRef,\n        portalContext,\n        isUntrappedTypeableCombobox,\n        guards\n    ]);\n    index(()=>{\n        if (disabled || !floating) return;\n        const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating);\n        const previouslyFocusedElement = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)(doc);\n        // Wait for any layout effect state setters to execute to set `tabIndex`.\n        queueMicrotask(()=>{\n            const focusableElements = getTabbableElements(floating);\n            const initialFocusValue = initialFocusRef.current;\n            const elToFocus = (typeof initialFocusValue === \"number\" ? focusableElements[initialFocusValue] : initialFocusValue.current) || floating;\n            const focusAlreadyInsideFloatingEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(floating, previouslyFocusedElement);\n            if (!ignoreInitialFocus && !focusAlreadyInsideFloatingEl && open) {\n                enqueueFocus(elToFocus, {\n                    preventScroll: elToFocus === floating\n                });\n            }\n        });\n    }, [\n        disabled,\n        open,\n        floating,\n        ignoreInitialFocus,\n        getTabbableElements,\n        initialFocusRef\n    ]);\n    index(()=>{\n        if (disabled || !floating) return;\n        let preventReturnFocusScroll = false;\n        const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating);\n        const previouslyFocusedElement = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)(doc);\n        const contextData = dataRef.current;\n        addPreviouslyFocusedElement(previouslyFocusedElement);\n        // Dismissing via outside press should always ignore `returnFocus` to\n        // prevent unwanted scrolling.\n        function onOpenChange(_ref) {\n            let { reason, event, nested } = _ref;\n            if (reason === \"escape-key\" && refs.domReference.current) {\n                addPreviouslyFocusedElement(refs.domReference.current);\n            }\n            if (reason === \"hover\" && event.type === \"mouseleave\") {\n                preventReturnFocusRef.current = true;\n            }\n            if (reason !== \"outside-press\") return;\n            if (nested) {\n                preventReturnFocusRef.current = false;\n                preventReturnFocusScroll = true;\n            } else {\n                preventReturnFocusRef.current = !((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isVirtualClick)(event) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isVirtualPointerEvent)(event));\n            }\n        }\n        events.on(\"openchange\", onOpenChange);\n        return ()=>{\n            events.off(\"openchange\", onOpenChange);\n            const activeEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)(doc);\n            const isFocusInsideFloatingTree = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(floating, activeEl) || tree && getChildren(tree.nodesRef.current, nodeId).some((node)=>{\n                var _node$context5;\n                return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)((_node$context5 = node.context) == null ? void 0 : _node$context5.elements.floating, activeEl);\n            });\n            const shouldFocusReference = isFocusInsideFloatingTree || contextData.openEvent && [\n                \"click\",\n                \"mousedown\"\n            ].includes(contextData.openEvent.type);\n            if (shouldFocusReference && refs.domReference.current) {\n                addPreviouslyFocusedElement(refs.domReference.current);\n            }\n            const returnElement = getPreviouslyFocusedElement();\n            if (// eslint-disable-next-line react-hooks/exhaustive-deps\n            returnFocusRef.current && !preventReturnFocusRef.current && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(returnElement) && // If the focus moved somewhere else after mount, avoid returning focus\n            // since it likely entered a different element which should be\n            // respected: https://github.com/floating-ui/floating-ui/issues/2607\n            (returnElement !== activeEl && activeEl !== doc.body ? isFocusInsideFloatingTree : true)) {\n                enqueueFocus(returnElement, {\n                    // When dismissing nested floating elements, by the time the rAF has\n                    // executed, the menus will all have been unmounted. When they try\n                    // to get focused, the calls get ignored — leaving the root\n                    // reference focused as desired.\n                    cancelPrevious: false,\n                    preventScroll: preventReturnFocusScroll\n                });\n            }\n        };\n    }, [\n        disabled,\n        floating,\n        returnFocusRef,\n        dataRef,\n        refs,\n        events,\n        tree,\n        nodeId\n    ]);\n    // Synchronize the `context` & `modal` value to the FloatingPortal context.\n    // It will decide whether or not it needs to render its own guards.\n    index(()=>{\n        if (disabled || !portalContext) return;\n        portalContext.setFocusManagerState({\n            modal,\n            closeOnFocusOut,\n            open,\n            onOpenChange,\n            refs\n        });\n        return ()=>{\n            portalContext.setFocusManagerState(null);\n        };\n    }, [\n        disabled,\n        portalContext,\n        modal,\n        open,\n        onOpenChange,\n        refs,\n        closeOnFocusOut\n    ]);\n    index(()=>{\n        if (disabled || !floating || typeof MutationObserver !== \"function\" || ignoreInitialFocus) {\n            return;\n        }\n        const handleMutation = ()=>{\n            const tabIndex = floating.getAttribute(\"tabindex\");\n            if (orderRef.current.includes(\"floating\") || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating)) !== refs.domReference.current && getTabbableContent().length === 0) {\n                if (tabIndex !== \"0\") {\n                    floating.setAttribute(\"tabindex\", \"0\");\n                }\n            } else if (tabIndex !== \"-1\") {\n                floating.setAttribute(\"tabindex\", \"-1\");\n            }\n        };\n        handleMutation();\n        const observer = new MutationObserver(handleMutation);\n        observer.observe(floating, {\n            childList: true,\n            subtree: true,\n            attributes: true\n        });\n        return ()=>{\n            observer.disconnect();\n        };\n    }, [\n        disabled,\n        floating,\n        refs,\n        orderRef,\n        getTabbableContent,\n        ignoreInitialFocus\n    ]);\n    function renderDismissButton(location) {\n        if (disabled || !visuallyHiddenDismiss || !modal) {\n            return null;\n        }\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(VisuallyHiddenDismiss, {\n            ref: location === \"start\" ? startDismissButtonRef : endDismissButtonRef,\n            onClick: (event)=>onOpenChange(false, event.nativeEvent)\n        }, typeof visuallyHiddenDismiss === \"string\" ? visuallyHiddenDismiss : \"Dismiss\");\n    }\n    const shouldRenderGuards = !disabled && guards && (isInsidePortal || modal);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, shouldRenderGuards && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n        \"data-type\": \"inside\",\n        ref: portalContext == null ? void 0 : portalContext.beforeInsideRef,\n        onFocus: (event)=>{\n            if (modal) {\n                const els = getTabbableElements();\n                enqueueFocus(order[0] === \"reference\" ? els[0] : els[els.length - 1]);\n            } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n                preventReturnFocusRef.current = false;\n                if (isOutsideEvent(event, portalContext.portalNode)) {\n                    const nextTabbable = getNextTabbable() || domReference;\n                    nextTabbable == null || nextTabbable.focus();\n                } else {\n                    var _portalContext$before;\n                    (_portalContext$before = portalContext.beforeOutsideRef.current) == null || _portalContext$before.focus();\n                }\n            }\n        }\n    }), !isUntrappedTypeableCombobox && renderDismissButton(\"start\"), children, renderDismissButton(\"end\"), shouldRenderGuards && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FocusGuard, {\n        \"data-type\": \"inside\",\n        ref: portalContext == null ? void 0 : portalContext.afterInsideRef,\n        onFocus: (event)=>{\n            if (modal) {\n                enqueueFocus(getTabbableElements()[0]);\n            } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n                if (closeOnFocusOut) {\n                    preventReturnFocusRef.current = true;\n                }\n                if (isOutsideEvent(event, portalContext.portalNode)) {\n                    const prevTabbable = getPreviousTabbable() || domReference;\n                    prevTabbable == null || prevTabbable.focus();\n                } else {\n                    var _portalContext$afterO;\n                    (_portalContext$afterO = portalContext.afterOutsideRef.current) == null || _portalContext$afterO.focus();\n                }\n            }\n        }\n    }));\n}\nconst activeLocks = /*#__PURE__*/ new Set();\n/**\n * Provides base styling for a fixed overlay element to dim content or block\n * pointer events behind a floating element.\n * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.\n * @see https://floating-ui.com/docs/FloatingOverlay\n */ const FloatingOverlay = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function FloatingOverlay(_ref, ref) {\n    let { lockScroll = false, ...rest } = _ref;\n    const lockId = useId();\n    index(()=>{\n        if (!lockScroll) return;\n        activeLocks.add(lockId);\n        const isIOS = /iP(hone|ad|od)|iOS/.test((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getPlatform)());\n        const bodyStyle = document.body.style;\n        // RTL <body> scrollbar\n        const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;\n        const paddingProp = scrollbarX ? \"paddingLeft\" : \"paddingRight\";\n        const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n        const scrollX = bodyStyle.left ? parseFloat(bodyStyle.left) : window.pageXOffset;\n        const scrollY = bodyStyle.top ? parseFloat(bodyStyle.top) : window.pageYOffset;\n        bodyStyle.overflow = \"hidden\";\n        if (scrollbarWidth) {\n            bodyStyle[paddingProp] = scrollbarWidth + \"px\";\n        }\n        // Only iOS doesn't respect `overflow: hidden` on document.body, and this\n        // technique has fewer side effects.\n        if (isIOS) {\n            var _window$visualViewpor, _window$visualViewpor2;\n            // iOS 12 does not support `visualViewport`.\n            const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;\n            const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;\n            Object.assign(bodyStyle, {\n                position: \"fixed\",\n                top: -(scrollY - Math.floor(offsetTop)) + \"px\",\n                left: -(scrollX - Math.floor(offsetLeft)) + \"px\",\n                right: \"0\"\n            });\n        }\n        return ()=>{\n            activeLocks.delete(lockId);\n            if (activeLocks.size === 0) {\n                Object.assign(bodyStyle, {\n                    overflow: \"\",\n                    [paddingProp]: \"\"\n                });\n                if (isIOS) {\n                    Object.assign(bodyStyle, {\n                        position: \"\",\n                        top: \"\",\n                        left: \"\",\n                        right: \"\"\n                    });\n                    window.scrollTo(scrollX, scrollY);\n                }\n            }\n        };\n    }, [\n        lockId,\n        lockScroll\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", _extends({\n        ref: ref\n    }, rest, {\n        style: {\n            position: \"fixed\",\n            overflow: \"auto\",\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0,\n            ...rest.style\n        }\n    }));\n});\nfunction isButtonTarget(event) {\n    return (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(event.target) && event.target.tagName === \"BUTTON\";\n}\nfunction isSpaceIgnored(element) {\n    return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isTypeableElement)(element);\n}\n/**\n * Opens or closes the floating element when clicking the reference element.\n * @see https://floating-ui.com/docs/useClick\n */ function useClick(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, onOpenChange, dataRef, elements: { domReference } } = context;\n    const { enabled = true, event: eventOption = \"click\", toggle = true, ignoreMouse = false, keyboardHandlers = true } = props;\n    const pointerTypeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const didKeyDownRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) return {};\n        return {\n            reference: {\n                onPointerDown (event) {\n                    pointerTypeRef.current = event.pointerType;\n                },\n                onMouseDown (event) {\n                    // Ignore all buttons except for the \"main\" button.\n                    // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n                    if (event.button !== 0) {\n                        return;\n                    }\n                    if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMouseLikePointerType)(pointerTypeRef.current, true) && ignoreMouse) {\n                        return;\n                    }\n                    if (eventOption === \"click\") {\n                        return;\n                    }\n                    if (open && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === \"mousedown\" : true)) {\n                        onOpenChange(false, event.nativeEvent, \"click\");\n                    } else {\n                        // Prevent stealing focus from the floating element\n                        event.preventDefault();\n                        onOpenChange(true, event.nativeEvent, \"click\");\n                    }\n                },\n                onClick (event) {\n                    if (eventOption === \"mousedown\" && pointerTypeRef.current) {\n                        pointerTypeRef.current = undefined;\n                        return;\n                    }\n                    if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMouseLikePointerType)(pointerTypeRef.current, true) && ignoreMouse) {\n                        return;\n                    }\n                    if (open && toggle && (dataRef.current.openEvent ? dataRef.current.openEvent.type === \"click\" : true)) {\n                        onOpenChange(false, event.nativeEvent, \"click\");\n                    } else {\n                        onOpenChange(true, event.nativeEvent, \"click\");\n                    }\n                },\n                onKeyDown (event) {\n                    pointerTypeRef.current = undefined;\n                    if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event)) {\n                        return;\n                    }\n                    if (event.key === \" \" && !isSpaceIgnored(domReference)) {\n                        // Prevent scrolling\n                        event.preventDefault();\n                        didKeyDownRef.current = true;\n                    }\n                    if (event.key === \"Enter\") {\n                        if (open && toggle) {\n                            onOpenChange(false, event.nativeEvent, \"click\");\n                        } else {\n                            onOpenChange(true, event.nativeEvent, \"click\");\n                        }\n                    }\n                },\n                onKeyUp (event) {\n                    if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event) || isSpaceIgnored(domReference)) {\n                        return;\n                    }\n                    if (event.key === \" \" && didKeyDownRef.current) {\n                        didKeyDownRef.current = false;\n                        if (open && toggle) {\n                            onOpenChange(false, event.nativeEvent, \"click\");\n                        } else {\n                            onOpenChange(true, event.nativeEvent, \"click\");\n                        }\n                    }\n                }\n            }\n        };\n    }, [\n        enabled,\n        dataRef,\n        eventOption,\n        ignoreMouse,\n        keyboardHandlers,\n        domReference,\n        toggle,\n        open,\n        onOpenChange\n    ]);\n}\nfunction createVirtualElement(domRef, data) {\n    let offsetX = null;\n    let offsetY = null;\n    let isAutoUpdateEvent = false;\n    return {\n        contextElement: domRef.current || undefined,\n        getBoundingClientRect () {\n            var _domRef$current, _data$dataRef$current;\n            const domRect = ((_domRef$current = domRef.current) == null ? void 0 : _domRef$current.getBoundingClientRect()) || {\n                width: 0,\n                height: 0,\n                x: 0,\n                y: 0\n            };\n            const isXAxis = data.axis === \"x\" || data.axis === \"both\";\n            const isYAxis = data.axis === \"y\" || data.axis === \"both\";\n            const canTrackCursorOnAutoUpdate = [\n                \"mouseenter\",\n                \"mousemove\"\n            ].includes(((_data$dataRef$current = data.dataRef.current.openEvent) == null ? void 0 : _data$dataRef$current.type) || \"\") && data.pointerType !== \"touch\";\n            let width = domRect.width;\n            let height = domRect.height;\n            let x = domRect.x;\n            let y = domRect.y;\n            if (offsetX == null && data.x && isXAxis) {\n                offsetX = domRect.x - data.x;\n            }\n            if (offsetY == null && data.y && isYAxis) {\n                offsetY = domRect.y - data.y;\n            }\n            x -= offsetX || 0;\n            y -= offsetY || 0;\n            width = 0;\n            height = 0;\n            if (!isAutoUpdateEvent || canTrackCursorOnAutoUpdate) {\n                width = data.axis === \"y\" ? domRect.width : 0;\n                height = data.axis === \"x\" ? domRect.height : 0;\n                x = isXAxis && data.x != null ? data.x : x;\n                y = isYAxis && data.y != null ? data.y : y;\n            } else if (isAutoUpdateEvent && !canTrackCursorOnAutoUpdate) {\n                height = data.axis === \"x\" ? domRect.height : height;\n                width = data.axis === \"y\" ? domRect.width : width;\n            }\n            isAutoUpdateEvent = true;\n            return {\n                width,\n                height,\n                x,\n                y,\n                top: y,\n                right: x + width,\n                bottom: y + height,\n                left: x\n            };\n        }\n    };\n}\nfunction isMouseBasedEvent(event) {\n    return event != null && event.clientX != null;\n}\n/**\n * Positions the floating element relative to a client point (in the viewport),\n * such as the mouse position. By default, it follows the mouse cursor.\n * @see https://floating-ui.com/docs/useClientPoint\n */ function useClientPoint(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, refs, dataRef, elements: { floating } } = context;\n    const { enabled = true, axis = \"both\", x = null, y = null } = props;\n    const initialRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const cleanupListenerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const [pointerType, setPointerType] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    const [reactive, setReactive] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]);\n    const setReference = useEffectEvent((x, y)=>{\n        if (initialRef.current) return;\n        // Prevent setting if the open event was not a mouse-like one\n        // (e.g. focus to open, then hover over the reference element).\n        // Only apply if the event exists.\n        if (dataRef.current.openEvent && !isMouseBasedEvent(dataRef.current.openEvent)) {\n            return;\n        }\n        refs.setPositionReference(createVirtualElement(refs.domReference, {\n            x,\n            y,\n            axis,\n            dataRef,\n            pointerType\n        }));\n    });\n    const handleReferenceEnterOrMove = useEffectEvent((event)=>{\n        if (x != null || y != null) return;\n        if (!open) {\n            setReference(event.clientX, event.clientY);\n        } else if (!cleanupListenerRef.current) {\n            // If there's no cleanup, there's no listener, but we want to ensure\n            // we add the listener if the cursor landed on the floating element and\n            // then back on the reference (i.e. it's interactive).\n            setReactive([]);\n        }\n    });\n    // If the pointer is a mouse-like pointer, we want to continue following the\n    // mouse even if the floating element is transitioning out. On touch\n    // devices, this is undesirable because the floating element will move to\n    // the dismissal touch point.\n    const openCheck = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMouseLikePointerType)(pointerType) ? floating : open;\n    const addListener = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        // Explicitly specified `x`/`y` coordinates shouldn't add a listener.\n        if (!openCheck || !enabled || x != null || y != null) return;\n        const win = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getWindow)(refs.floating.current);\n        function handleMouseMove(event) {\n            const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event);\n            if (!(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(refs.floating.current, target)) {\n                setReference(event.clientX, event.clientY);\n            } else {\n                win.removeEventListener(\"mousemove\", handleMouseMove);\n                cleanupListenerRef.current = null;\n            }\n        }\n        if (!dataRef.current.openEvent || isMouseBasedEvent(dataRef.current.openEvent)) {\n            win.addEventListener(\"mousemove\", handleMouseMove);\n            const cleanup = ()=>{\n                win.removeEventListener(\"mousemove\", handleMouseMove);\n                cleanupListenerRef.current = null;\n            };\n            cleanupListenerRef.current = cleanup;\n            return cleanup;\n        }\n        refs.setPositionReference(refs.domReference.current);\n    }, [\n        dataRef,\n        enabled,\n        openCheck,\n        refs,\n        setReference,\n        x,\n        y\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        return addListener();\n    }, [\n        addListener,\n        reactive\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (enabled && !floating) {\n            initialRef.current = false;\n        }\n    }, [\n        enabled,\n        floating\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled && open) {\n            initialRef.current = true;\n        }\n    }, [\n        enabled,\n        open\n    ]);\n    index(()=>{\n        if (enabled && (x != null || y != null)) {\n            initialRef.current = false;\n            setReference(x, y);\n        }\n    }, [\n        enabled,\n        x,\n        y,\n        setReference\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) return {};\n        function setPointerTypeRef(_ref) {\n            let { pointerType } = _ref;\n            setPointerType(pointerType);\n        }\n        return {\n            reference: {\n                onPointerDown: setPointerTypeRef,\n                onPointerEnter: setPointerTypeRef,\n                onMouseMove: handleReferenceEnterOrMove,\n                onMouseEnter: handleReferenceEnterOrMove\n            }\n        };\n    }, [\n        enabled,\n        handleReferenceEnterOrMove\n    ]);\n}\nconst bubbleHandlerKeys = {\n    pointerdown: \"onPointerDown\",\n    mousedown: \"onMouseDown\",\n    click: \"onClick\"\n};\nconst captureHandlerKeys = {\n    pointerdown: \"onPointerDownCapture\",\n    mousedown: \"onMouseDownCapture\",\n    click: \"onClickCapture\"\n};\nconst normalizeProp = (normalizable)=>{\n    var _normalizable$escapeK, _normalizable$outside;\n    return {\n        escapeKey: typeof normalizable === \"boolean\" ? normalizable : (_normalizable$escapeK = normalizable == null ? void 0 : normalizable.escapeKey) != null ? _normalizable$escapeK : false,\n        outsidePress: typeof normalizable === \"boolean\" ? normalizable : (_normalizable$outside = normalizable == null ? void 0 : normalizable.outsidePress) != null ? _normalizable$outside : true\n    };\n};\n/**\n * Closes the floating element when a dismissal is requested — by default, when\n * the user presses the `escape` key or outside of the floating element.\n * @see https://floating-ui.com/docs/useDismiss\n */ function useDismiss(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, onOpenChange, nodeId, elements: { reference, domReference, floating }, dataRef } = context;\n    const { enabled = true, escapeKey = true, outsidePress: unstable_outsidePress = true, outsidePressEvent = \"pointerdown\", referencePress = false, referencePressEvent = \"pointerdown\", ancestorScroll = false, bubbles, capture } = props;\n    const tree = useFloatingTree();\n    const outsidePressFn = useEffectEvent(typeof unstable_outsidePress === \"function\" ? unstable_outsidePress : ()=>false);\n    const outsidePress = typeof unstable_outsidePress === \"function\" ? outsidePressFn : unstable_outsidePress;\n    const insideReactTreeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const endedOrStartedInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const { escapeKey: escapeKeyBubbles, outsidePress: outsidePressBubbles } = normalizeProp(bubbles);\n    const { escapeKey: escapeKeyCapture, outsidePress: outsidePressCapture } = normalizeProp(capture);\n    const closeOnEscapeKeyDown = useEffectEvent((event)=>{\n        if (!open || !enabled || !escapeKey || event.key !== \"Escape\") {\n            return;\n        }\n        const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n        if (!escapeKeyBubbles) {\n            event.stopPropagation();\n            if (children.length > 0) {\n                let shouldDismiss = true;\n                children.forEach((child)=>{\n                    var _child$context;\n                    if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {\n                        shouldDismiss = false;\n                        return;\n                    }\n                });\n                if (!shouldDismiss) {\n                    return;\n                }\n            }\n        }\n        onOpenChange(false, (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isReactEvent)(event) ? event.nativeEvent : event, \"escape-key\");\n    });\n    const closeOnEscapeKeyDownCapture = useEffectEvent((event)=>{\n        var _getTarget2;\n        const callback = ()=>{\n            var _getTarget;\n            closeOnEscapeKeyDown(event);\n            (_getTarget = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event)) == null || _getTarget.removeEventListener(\"keydown\", callback);\n        };\n        (_getTarget2 = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event)) == null || _getTarget2.addEventListener(\"keydown\", callback);\n    });\n    const closeOnPressOutside = useEffectEvent((event)=>{\n        // Given developers can stop the propagation of the synthetic event,\n        // we can only be confident with a positive value.\n        const insideReactTree = insideReactTreeRef.current;\n        insideReactTreeRef.current = false;\n        // When click outside is lazy (`click` event), handle dragging.\n        // Don't close if:\n        // - The click started inside the floating element.\n        // - The click ended inside the floating element.\n        const endedOrStartedInside = endedOrStartedInsideRef.current;\n        endedOrStartedInsideRef.current = false;\n        if (outsidePressEvent === \"click\" && endedOrStartedInside) {\n            return;\n        }\n        if (insideReactTree) {\n            return;\n        }\n        if (typeof outsidePress === \"function\" && !outsidePress(event)) {\n            return;\n        }\n        const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event);\n        const inertSelector = \"[\" + createAttribute(\"inert\") + \"]\";\n        const markers = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating).querySelectorAll(inertSelector);\n        let targetRootAncestor = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(target) ? target : null;\n        while(targetRootAncestor && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isLastTraversableNode)(targetRootAncestor)){\n            const nextParent = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getParentNode)(targetRootAncestor);\n            if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isLastTraversableNode)(nextParent) || !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(nextParent)) {\n                break;\n            } else {\n                targetRootAncestor = nextParent;\n            }\n        }\n        // Check if the click occurred on a third-party element injected after the\n        // floating element rendered.\n        if (markers.length && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(target) && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isRootElement)(target) && // Clicked on a direct ancestor (e.g. FloatingOverlay).\n        !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(target, floating) && // If the target root element contains none of the markers, then the\n        // element was injected after the floating element rendered.\n        Array.from(markers).every((marker)=>!(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(targetRootAncestor, marker))) {\n            return;\n        }\n        // Check if the click occurred on the scrollbar\n        if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(target) && floating) {\n            // In Firefox, `target.scrollWidth > target.clientWidth` for inline\n            // elements.\n            const canScrollX = target.clientWidth > 0 && target.scrollWidth > target.clientWidth;\n            const canScrollY = target.clientHeight > 0 && target.scrollHeight > target.clientHeight;\n            let xCond = canScrollY && event.offsetX > target.clientWidth;\n            // In some browsers it is possible to change the <body> (or window)\n            // scrollbar to the left side, but is very rare and is difficult to\n            // check for. Plus, for modal dialogs with backdrops, it is more\n            // important that the backdrop is checked but not so much the window.\n            if (canScrollY) {\n                const isRTL = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getComputedStyle)(target).direction === \"rtl\";\n                if (isRTL) {\n                    xCond = event.offsetX <= target.offsetWidth - target.clientWidth;\n                }\n            }\n            if (xCond || canScrollX && event.offsetY > target.clientHeight) {\n                return;\n            }\n        }\n        const targetIsInsideChildren = tree && getChildren(tree.nodesRef.current, nodeId).some((node)=>{\n            var _node$context;\n            return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isEventTargetWithin)(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);\n        });\n        if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isEventTargetWithin)(event, floating) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isEventTargetWithin)(event, domReference) || targetIsInsideChildren) {\n            return;\n        }\n        const children = tree ? getChildren(tree.nodesRef.current, nodeId) : [];\n        if (children.length > 0) {\n            let shouldDismiss = true;\n            children.forEach((child)=>{\n                var _child$context2;\n                if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {\n                    shouldDismiss = false;\n                    return;\n                }\n            });\n            if (!shouldDismiss) {\n                return;\n            }\n        }\n        onOpenChange(false, event, \"outside-press\");\n    });\n    const closeOnPressOutsideCapture = useEffectEvent((event)=>{\n        var _getTarget4;\n        const callback = ()=>{\n            var _getTarget3;\n            closeOnPressOutside(event);\n            (_getTarget3 = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event)) == null || _getTarget3.removeEventListener(outsidePressEvent, callback);\n        };\n        (_getTarget4 = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event)) == null || _getTarget4.addEventListener(outsidePressEvent, callback);\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!open || !enabled) {\n            return;\n        }\n        dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;\n        dataRef.current.__outsidePressBubbles = outsidePressBubbles;\n        function onScroll(event) {\n            onOpenChange(false, event, \"ancestor-scroll\");\n        }\n        const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating);\n        escapeKey && doc.addEventListener(\"keydown\", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);\n        outsidePress && doc.addEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n        let ancestors = [];\n        if (ancestorScroll) {\n            if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(domReference)) {\n                ancestors = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getOverflowAncestors)(domReference);\n            }\n            if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(floating)) {\n                ancestors = ancestors.concat((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getOverflowAncestors)(floating));\n            }\n            if (!(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(reference) && reference && reference.contextElement) {\n                ancestors = ancestors.concat((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getOverflowAncestors)(reference.contextElement));\n            }\n        }\n        // Ignore the visual viewport for scrolling dismissal (allow pinch-zoom)\n        ancestors = ancestors.filter((ancestor)=>{\n            var _doc$defaultView;\n            return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);\n        });\n        ancestors.forEach((ancestor)=>{\n            ancestor.addEventListener(\"scroll\", onScroll, {\n                passive: true\n            });\n        });\n        return ()=>{\n            escapeKey && doc.removeEventListener(\"keydown\", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);\n            outsidePress && doc.removeEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n            ancestors.forEach((ancestor)=>{\n                ancestor.removeEventListener(\"scroll\", onScroll);\n            });\n        };\n    }, [\n        dataRef,\n        floating,\n        domReference,\n        reference,\n        escapeKey,\n        outsidePress,\n        outsidePressEvent,\n        open,\n        onOpenChange,\n        ancestorScroll,\n        enabled,\n        escapeKeyBubbles,\n        outsidePressBubbles,\n        closeOnEscapeKeyDown,\n        escapeKeyCapture,\n        closeOnEscapeKeyDownCapture,\n        closeOnPressOutside,\n        outsidePressCapture,\n        closeOnPressOutsideCapture\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        insideReactTreeRef.current = false;\n    }, [\n        outsidePress,\n        outsidePressEvent\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) {\n            return {};\n        }\n        return {\n            reference: {\n                onKeyDown: closeOnEscapeKeyDown,\n                [bubbleHandlerKeys[referencePressEvent]]: (event)=>{\n                    if (referencePress) {\n                        onOpenChange(false, event.nativeEvent, \"reference-press\");\n                    }\n                }\n            },\n            floating: {\n                onKeyDown: closeOnEscapeKeyDown,\n                onMouseDown () {\n                    endedOrStartedInsideRef.current = true;\n                },\n                onMouseUp () {\n                    endedOrStartedInsideRef.current = true;\n                },\n                [captureHandlerKeys[outsidePressEvent]]: ()=>{\n                    insideReactTreeRef.current = true;\n                }\n            }\n        };\n    }, [\n        enabled,\n        referencePress,\n        outsidePressEvent,\n        referencePressEvent,\n        onOpenChange,\n        closeOnEscapeKeyDown\n    ]);\n}\nlet devMessageSet;\nif (true) {\n    devMessageSet = /*#__PURE__*/ new Set();\n}\n/**\n * Provides data to position a floating element and context to add interactions.\n * @see https://floating-ui.com/docs/useFloating\n */ function useFloating(options) {\n    var _options$elements2;\n    if (options === void 0) {\n        options = {};\n    }\n    const { open = false, onOpenChange: unstable_onOpenChange, nodeId } = options;\n    if (true) {\n        var _options$elements;\n        const err = \"Floating UI: Cannot pass a virtual element to the \" + \"`elements.reference` option, as it must be a real DOM element. \" + \"Use `refs.setPositionReference` instead.\";\n        if ((_options$elements = options.elements) != null && _options$elements.reference && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(options.elements.reference)) {\n            var _devMessageSet;\n            if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(err))) {\n                var _devMessageSet2;\n                (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(err);\n                console.error(err);\n            }\n        }\n    }\n    const [_domReference, setDomReference] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const domReference = ((_options$elements2 = options.elements) == null ? void 0 : _options$elements2.reference) || _domReference;\n    const position = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_1__.useFloating)(options);\n    const tree = useFloatingTree();\n    const nested = useFloatingParentNodeId() != null;\n    const onOpenChange = useEffectEvent((open, event, reason)=>{\n        if (open) {\n            dataRef.current.openEvent = event;\n        }\n        events.emit(\"openchange\", {\n            open,\n            event,\n            reason,\n            nested\n        });\n        unstable_onOpenChange == null || unstable_onOpenChange(open, event, reason);\n    });\n    const domReferenceRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const dataRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef({});\n    const events = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>createPubSub())[0];\n    const floatingId = useId();\n    const setPositionReference = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        const positionReference = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(node) ? {\n            getBoundingClientRect: ()=>node.getBoundingClientRect(),\n            contextElement: node\n        } : node;\n        position.refs.setReference(positionReference);\n    }, [\n        position.refs\n    ]);\n    const setReference = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(node) || node === null) {\n            domReferenceRef.current = node;\n            setDomReference(node);\n        }\n        // Backwards-compatibility for passing a virtual element to `reference`\n        // after it has set the DOM reference.\n        if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(position.refs.reference.current) || position.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to\n        // `null` to support `positionReference` + an unstable `reference`\n        // callback ref.\n        node !== null && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(node)) {\n            position.refs.setReference(node);\n        }\n    }, [\n        position.refs\n    ]);\n    const refs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            ...position.refs,\n            setReference,\n            setPositionReference,\n            domReference: domReferenceRef\n        }), [\n        position.refs,\n        setReference,\n        setPositionReference\n    ]);\n    const elements = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            ...position.elements,\n            domReference: domReference\n        }), [\n        position.elements,\n        domReference\n    ]);\n    const context = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            ...position,\n            refs,\n            elements,\n            dataRef,\n            nodeId,\n            floatingId,\n            events,\n            open,\n            onOpenChange\n        }), [\n        position,\n        nodeId,\n        floatingId,\n        events,\n        open,\n        onOpenChange,\n        refs,\n        elements\n    ]);\n    index(()=>{\n        const node = tree == null ? void 0 : tree.nodesRef.current.find((node)=>node.id === nodeId);\n        if (node) {\n            node.context = context;\n        }\n    });\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            ...position,\n            context,\n            refs,\n            elements\n        }), [\n        position,\n        refs,\n        elements,\n        context\n    ]);\n}\n/**\n * Opens the floating element while the reference element has focus, like CSS\n * `:focus`.\n * @see https://floating-ui.com/docs/useFocus\n */ function useFocus(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, onOpenChange, events, refs, elements: { floating, domReference } } = context;\n    const { enabled = true, visibleOnly = true } = props;\n    const blockFocusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const timeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const keyboardModalityRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled) {\n            return;\n        }\n        const win = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.getWindow)(domReference);\n        // If the reference was focused and the user left the tab/window, and the\n        // floating element was not open, the focus should be blocked when they\n        // return to the tab/window.\n        function onBlur() {\n            if (!open && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(domReference) && domReference === (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(domReference))) {\n                blockFocusRef.current = true;\n            }\n        }\n        function onKeyDown() {\n            keyboardModalityRef.current = true;\n        }\n        win.addEventListener(\"blur\", onBlur);\n        win.addEventListener(\"keydown\", onKeyDown, true);\n        return ()=>{\n            win.removeEventListener(\"blur\", onBlur);\n            win.removeEventListener(\"keydown\", onKeyDown, true);\n        };\n    }, [\n        floating,\n        domReference,\n        open,\n        enabled\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled) {\n            return;\n        }\n        function onOpenChange(_ref) {\n            let { reason } = _ref;\n            if (reason === \"reference-press\" || reason === \"escape-key\") {\n                blockFocusRef.current = true;\n            }\n        }\n        events.on(\"openchange\", onOpenChange);\n        return ()=>{\n            events.off(\"openchange\", onOpenChange);\n        };\n    }, [\n        events,\n        enabled\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        return ()=>{\n            clearTimeout(timeoutRef.current);\n        };\n    }, []);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) {\n            return {};\n        }\n        return {\n            reference: {\n                onPointerDown (event) {\n                    if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isVirtualPointerEvent)(event.nativeEvent)) return;\n                    keyboardModalityRef.current = false;\n                },\n                onMouseLeave () {\n                    blockFocusRef.current = false;\n                },\n                onFocus (event) {\n                    if (blockFocusRef.current) return;\n                    const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event.nativeEvent);\n                    if (visibleOnly && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(target)) {\n                        try {\n                            // Mac Safari unreliably matches `:focus-visible` on the reference\n                            // if focus was outside the page initially - use the fallback\n                            // instead.\n                            if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isSafari)() && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMac)()) throw Error();\n                            if (!target.matches(\":focus-visible\")) return;\n                        } catch (e) {\n                            // Old browsers will throw an error when using `:focus-visible`.\n                            if (!keyboardModalityRef.current && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isTypeableElement)(target)) {\n                                return;\n                            }\n                        }\n                    }\n                    onOpenChange(true, event.nativeEvent, \"focus\");\n                },\n                onBlur (event) {\n                    blockFocusRef.current = false;\n                    const relatedTarget = event.relatedTarget;\n                    // Hit the non-modal focus management portal guard. Focus will be\n                    // moved into the floating element immediately after.\n                    const movedToFocusGuard = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(relatedTarget) && relatedTarget.hasAttribute(createAttribute(\"focus-guard\")) && relatedTarget.getAttribute(\"data-type\") === \"outside\";\n                    // Wait for the window blur listener to fire.\n                    timeoutRef.current = window.setTimeout(()=>{\n                        const activeEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)(domReference ? domReference.ownerDocument : document);\n                        // Focus left the page, keep it open.\n                        if (!relatedTarget && activeEl === domReference) return;\n                        // When focusing the reference element (e.g. regular click), then\n                        // clicking into the floating element, prevent it from hiding.\n                        // Note: it must be focusable, e.g. `tabindex=\"-1\"`.\n                        if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(refs.floating.current, relatedTarget) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(domReference, relatedTarget) || movedToFocusGuard) {\n                            return;\n                        }\n                        onOpenChange(false, event.nativeEvent, \"focus\");\n                    });\n                }\n            }\n        };\n    }, [\n        enabled,\n        visibleOnly,\n        domReference,\n        refs,\n        onOpenChange\n    ]);\n}\nconst ACTIVE_KEY = \"active\";\nconst SELECTED_KEY = \"selected\";\nfunction mergeProps(userProps, propsList, elementKey) {\n    const map = new Map();\n    const isItem = elementKey === \"item\";\n    let domUserProps = userProps;\n    if (isItem && userProps) {\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { [ACTIVE_KEY]: _, [SELECTED_KEY]: __, ...validProps } = userProps;\n        domUserProps = validProps;\n    }\n    return {\n        ...elementKey === \"floating\" && {\n            tabIndex: -1\n        },\n        ...domUserProps,\n        ...propsList.map((value)=>{\n            const propsOrGetProps = value ? value[elementKey] : null;\n            if (typeof propsOrGetProps === \"function\") {\n                return userProps ? propsOrGetProps(userProps) : null;\n            }\n            return propsOrGetProps;\n        }).concat(userProps).reduce((acc, props)=>{\n            if (!props) {\n                return acc;\n            }\n            Object.entries(props).forEach((_ref)=>{\n                let [key, value] = _ref;\n                if (isItem && [\n                    ACTIVE_KEY,\n                    SELECTED_KEY\n                ].includes(key)) {\n                    return;\n                }\n                if (key.indexOf(\"on\") === 0) {\n                    if (!map.has(key)) {\n                        map.set(key, []);\n                    }\n                    if (typeof value === \"function\") {\n                        var _map$get;\n                        (_map$get = map.get(key)) == null || _map$get.push(value);\n                        acc[key] = function() {\n                            var _map$get2;\n                            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                                args[_key] = arguments[_key];\n                            }\n                            return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map((fn)=>fn(...args)).find((val)=>val !== undefined);\n                        };\n                    }\n                } else {\n                    acc[key] = value;\n                }\n            });\n            return acc;\n        }, {})\n    };\n}\n/**\n * Merges an array of interaction hooks' props into prop getters, allowing\n * event handler functions to be composed together without overwriting one\n * another.\n * @see https://floating-ui.com/docs/useInteractions\n */ function useInteractions(propsList) {\n    if (propsList === void 0) {\n        propsList = [];\n    }\n    // The dependencies are a dynamic array, so we can't use the linter's\n    // suggestion to add it to the deps array.\n    const deps = propsList;\n    const getReferenceProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((userProps)=>mergeProps(userProps, propsList, \"reference\"), // eslint-disable-next-line react-hooks/exhaustive-deps\n    deps);\n    const getFloatingProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((userProps)=>mergeProps(userProps, propsList, \"floating\"), // eslint-disable-next-line react-hooks/exhaustive-deps\n    deps);\n    const getItemProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((userProps)=>mergeProps(userProps, propsList, \"item\"), // Granularly check for `item` changes, because the `getItemProps` getter\n    // should be as referentially stable as possible since it may be passed as\n    // a prop to many components. All `item` key values must therefore be\n    // memoized.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    propsList.map((key)=>key == null ? void 0 : key.item));\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            getReferenceProps,\n            getFloatingProps,\n            getItemProps\n        }), [\n        getReferenceProps,\n        getFloatingProps,\n        getItemProps\n    ]);\n}\nlet isPreventScrollSupported = false;\nfunction doSwitch(orientation, vertical, horizontal) {\n    switch(orientation){\n        case \"vertical\":\n            return vertical;\n        case \"horizontal\":\n            return horizontal;\n        default:\n            return vertical || horizontal;\n    }\n}\nfunction isMainOrientationKey(key, orientation) {\n    const vertical = key === ARROW_UP || key === ARROW_DOWN;\n    const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;\n    return doSwitch(orientation, vertical, horizontal);\n}\nfunction isMainOrientationToEndKey(key, orientation, rtl) {\n    const vertical = key === ARROW_DOWN;\n    const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n    return doSwitch(orientation, vertical, horizontal) || key === \"Enter\" || key == \" \" || key === \"\";\n}\nfunction isCrossOrientationOpenKey(key, orientation, rtl) {\n    const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n    const horizontal = key === ARROW_DOWN;\n    return doSwitch(orientation, vertical, horizontal);\n}\nfunction isCrossOrientationCloseKey(key, orientation, rtl) {\n    const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;\n    const horizontal = key === ARROW_UP;\n    return doSwitch(orientation, vertical, horizontal);\n}\n/**\n * Adds arrow key-based navigation of a list of items, either using real DOM\n * focus or virtual focus.\n * @see https://floating-ui.com/docs/useListNavigation\n */ function useListNavigation(context, props) {\n    const { open, onOpenChange, refs, elements: { domReference, floating } } = context;\n    const { listRef, activeIndex, onNavigate: unstable_onNavigate = ()=>{}, enabled = true, selectedIndex = null, allowEscape = false, loop = false, nested = false, rtl = false, virtual = false, focusItemOnOpen = \"auto\", focusItemOnHover = true, openOnArrowKeyDown = true, disabledIndices = undefined, orientation = \"vertical\", cols = 1, scrollItemIntoView = true, virtualItemRef } = props;\n    if (true) {\n        if (allowEscape) {\n            if (!loop) {\n                console.warn([\n                    \"Floating UI: `useListNavigation` looping must be enabled to allow\",\n                    \"escaping.\"\n                ].join(\" \"));\n            }\n            if (!virtual) {\n                console.warn([\n                    \"Floating UI: `useListNavigation` must be virtual to allow\",\n                    \"escaping.\"\n                ].join(\" \"));\n            }\n        }\n        if (orientation === \"vertical\" && cols > 1) {\n            console.warn([\n                \"Floating UI: In grid list navigation mode (`cols` > 1), the\",\n                '`orientation` should be either \"horizontal\" or \"both\".'\n            ].join(\" \"));\n        }\n    }\n    const parentId = useFloatingParentNodeId();\n    const tree = useFloatingTree();\n    const onNavigate = useEffectEvent(unstable_onNavigate);\n    const focusItemOnOpenRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(focusItemOnOpen);\n    const indexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(selectedIndex != null ? selectedIndex : -1);\n    const keyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const isPointerModalityRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n    const previousOnNavigateRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(onNavigate);\n    const previousMountedRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(!!floating);\n    const forceSyncFocus = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const forceScrollIntoViewRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const disabledIndicesRef = useLatestRef(disabledIndices);\n    const latestOpenRef = useLatestRef(open);\n    const scrollItemIntoViewRef = useLatestRef(scrollItemIntoView);\n    const [activeId, setActiveId] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    const [virtualId, setVirtualId] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    const focusItem = useEffectEvent(function(listRef, indexRef, forceScrollIntoView) {\n        if (forceScrollIntoView === void 0) {\n            forceScrollIntoView = false;\n        }\n        const item = listRef.current[indexRef.current];\n        if (!item) return;\n        if (virtual) {\n            setActiveId(item.id);\n            tree == null || tree.events.emit(\"virtualfocus\", item);\n            if (virtualItemRef) {\n                virtualItemRef.current = item;\n            }\n        } else {\n            enqueueFocus(item, {\n                preventScroll: true,\n                // Mac Safari does not move the virtual cursor unless the focus call\n                // is sync. However, for the very first focus call, we need to wait\n                // for the position to be ready in order to prevent unwanted\n                // scrolling. This means the virtual cursor will not move to the first\n                // item when first opening the floating element, but will on\n                // subsequent calls. `preventScroll` is supported in modern Safari,\n                // so we can use that instead.\n                // iOS Safari must be async or the first item will not be focused.\n                sync: (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMac)() && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isSafari)() ? isPreventScrollSupported || forceSyncFocus.current : false\n            });\n        }\n        requestAnimationFrame(()=>{\n            const scrollIntoViewOptions = scrollItemIntoViewRef.current;\n            const shouldScrollIntoView = scrollIntoViewOptions && item && (forceScrollIntoView || !isPointerModalityRef.current);\n            if (shouldScrollIntoView) {\n                // JSDOM doesn't support `.scrollIntoView()` but it's widely supported\n                // by all browsers.\n                item.scrollIntoView == null || item.scrollIntoView(typeof scrollIntoViewOptions === \"boolean\" ? {\n                    block: \"nearest\",\n                    inline: \"nearest\"\n                } : scrollIntoViewOptions);\n            }\n        });\n    });\n    index(()=>{\n        document.createElement(\"div\").focus({\n            get preventScroll () {\n                isPreventScrollSupported = true;\n                return false;\n            }\n        });\n    }, []);\n    // Sync `selectedIndex` to be the `activeIndex` upon opening the floating\n    // element. Also, reset `activeIndex` upon closing the floating element.\n    index(()=>{\n        if (!enabled) {\n            return;\n        }\n        if (open && floating) {\n            if (focusItemOnOpenRef.current && selectedIndex != null) {\n                // Regardless of the pointer modality, we want to ensure the selected\n                // item comes into view when the floating element is opened.\n                forceScrollIntoViewRef.current = true;\n                onNavigate(selectedIndex);\n            }\n        } else if (previousMountedRef.current) {\n            // Since the user can specify `onNavigate` conditionally\n            // (onNavigate: open ? setActiveIndex : setSelectedIndex),\n            // we store and call the previous function.\n            indexRef.current = -1;\n            previousOnNavigateRef.current(null);\n        }\n    }, [\n        enabled,\n        open,\n        floating,\n        selectedIndex,\n        onNavigate\n    ]);\n    // Sync `activeIndex` to be the focused item while the floating element is\n    // open.\n    index(()=>{\n        if (!enabled) {\n            return;\n        }\n        if (open && floating) {\n            if (activeIndex == null) {\n                forceSyncFocus.current = false;\n                if (selectedIndex != null) {\n                    return;\n                }\n                // Reset while the floating element was open (e.g. the list changed).\n                if (previousMountedRef.current) {\n                    indexRef.current = -1;\n                    focusItem(listRef, indexRef);\n                }\n                // Initial sync.\n                if (!previousMountedRef.current && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {\n                    let runs = 0;\n                    const waitForListPopulated = ()=>{\n                        if (listRef.current[0] == null) {\n                            // Avoid letting the browser paint if possible on the first try,\n                            // otherwise use rAF. Don't try more than twice, since something\n                            // is wrong otherwise.\n                            if (runs < 2) {\n                                const scheduler = runs ? requestAnimationFrame : queueMicrotask;\n                                scheduler(waitForListPopulated);\n                            }\n                            runs++;\n                        } else {\n                            indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinIndex(listRef, disabledIndicesRef.current) : getMaxIndex(listRef, disabledIndicesRef.current);\n                            keyRef.current = null;\n                            onNavigate(indexRef.current);\n                        }\n                    };\n                    waitForListPopulated();\n                }\n            } else if (!isIndexOutOfBounds(listRef, activeIndex)) {\n                indexRef.current = activeIndex;\n                focusItem(listRef, indexRef, forceScrollIntoViewRef.current);\n                forceScrollIntoViewRef.current = false;\n            }\n        }\n    }, [\n        enabled,\n        open,\n        floating,\n        activeIndex,\n        selectedIndex,\n        nested,\n        listRef,\n        orientation,\n        rtl,\n        onNavigate,\n        focusItem,\n        disabledIndicesRef\n    ]);\n    // Ensure the parent floating element has focus when a nested child closes\n    // to allow arrow key navigation to work after the pointer leaves the child.\n    index(()=>{\n        var _nodes$find;\n        if (!enabled || floating || !tree || virtual || !previousMountedRef.current) {\n            return;\n        }\n        const nodes = tree.nodesRef.current;\n        const parent = (_nodes$find = nodes.find((node)=>node.id === parentId)) == null || (_nodes$find = _nodes$find.context) == null ? void 0 : _nodes$find.elements.floating;\n        const activeEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floating));\n        const treeContainsActiveEl = nodes.some((node)=>node.context && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(node.context.elements.floating, activeEl));\n        if (parent && !treeContainsActiveEl && isPointerModalityRef.current) {\n            parent.focus({\n                preventScroll: true\n            });\n        }\n    }, [\n        enabled,\n        floating,\n        tree,\n        parentId,\n        virtual\n    ]);\n    index(()=>{\n        if (!enabled || !tree || !virtual || parentId) return;\n        function handleVirtualFocus(item) {\n            setVirtualId(item.id);\n            if (virtualItemRef) {\n                virtualItemRef.current = item;\n            }\n        }\n        tree.events.on(\"virtualfocus\", handleVirtualFocus);\n        return ()=>{\n            tree.events.off(\"virtualfocus\", handleVirtualFocus);\n        };\n    }, [\n        enabled,\n        tree,\n        virtual,\n        parentId,\n        virtualItemRef\n    ]);\n    index(()=>{\n        previousOnNavigateRef.current = onNavigate;\n        previousMountedRef.current = !!floating;\n    });\n    index(()=>{\n        if (!open) {\n            keyRef.current = null;\n        }\n    }, [\n        open\n    ]);\n    const hasActiveIndex = activeIndex != null;\n    const item = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        function syncCurrentTarget(currentTarget) {\n            if (!open) return;\n            const index = listRef.current.indexOf(currentTarget);\n            if (index !== -1) {\n                onNavigate(index);\n            }\n        }\n        const props = {\n            onFocus (_ref) {\n                let { currentTarget } = _ref;\n                syncCurrentTarget(currentTarget);\n            },\n            onClick: (_ref2)=>{\n                let { currentTarget } = _ref2;\n                return currentTarget.focus({\n                    preventScroll: true\n                });\n            },\n            // Safari\n            ...focusItemOnHover && {\n                onMouseMove (_ref3) {\n                    let { currentTarget } = _ref3;\n                    syncCurrentTarget(currentTarget);\n                },\n                onPointerLeave (_ref4) {\n                    let { pointerType } = _ref4;\n                    if (!isPointerModalityRef.current || pointerType === \"touch\") {\n                        return;\n                    }\n                    indexRef.current = -1;\n                    focusItem(listRef, indexRef);\n                    onNavigate(null);\n                    if (!virtual) {\n                        enqueueFocus(refs.floating.current, {\n                            preventScroll: true\n                        });\n                    }\n                }\n            }\n        };\n        return props;\n    }, [\n        open,\n        refs,\n        focusItem,\n        focusItemOnHover,\n        listRef,\n        onNavigate,\n        virtual\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) {\n            return {};\n        }\n        const disabledIndices = disabledIndicesRef.current;\n        function onKeyDown(event) {\n            isPointerModalityRef.current = false;\n            forceSyncFocus.current = true;\n            // If the floating element is animating out, ignore navigation. Otherwise,\n            // the `activeIndex` gets set to 0 despite not being open so the next time\n            // the user ArrowDowns, the first item won't be focused.\n            if (!latestOpenRef.current && event.currentTarget === refs.floating.current) {\n                return;\n            }\n            if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl)) {\n                (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                onOpenChange(false, event.nativeEvent, \"list-navigation\");\n                if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(domReference) && !virtual) {\n                    domReference.focus();\n                }\n                return;\n            }\n            const currentIndex = indexRef.current;\n            const minIndex = getMinIndex(listRef, disabledIndices);\n            const maxIndex = getMaxIndex(listRef, disabledIndices);\n            if (event.key === \"Home\") {\n                (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                indexRef.current = minIndex;\n                onNavigate(indexRef.current);\n            }\n            if (event.key === \"End\") {\n                (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                indexRef.current = maxIndex;\n                onNavigate(indexRef.current);\n            }\n            // Grid navigation.\n            if (cols > 1) {\n                indexRef.current = getGridNavigatedIndex(listRef, {\n                    event,\n                    orientation,\n                    loop,\n                    cols,\n                    disabledIndices,\n                    minIndex,\n                    maxIndex,\n                    prevIndex: indexRef.current,\n                    stopEvent: true\n                });\n                onNavigate(indexRef.current);\n                if (orientation === \"both\") {\n                    return;\n                }\n            }\n            if (isMainOrientationKey(event.key, orientation)) {\n                (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                // Reset the index if no item is focused.\n                if (open && !virtual && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)(event.currentTarget.ownerDocument) === event.currentTarget) {\n                    indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;\n                    onNavigate(indexRef.current);\n                    return;\n                }\n                if (isMainOrientationToEndKey(event.key, orientation, rtl)) {\n                    if (loop) {\n                        indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledIndex(listRef, {\n                            startingIndex: currentIndex,\n                            disabledIndices\n                        });\n                    } else {\n                        indexRef.current = Math.min(maxIndex, findNonDisabledIndex(listRef, {\n                            startingIndex: currentIndex,\n                            disabledIndices\n                        }));\n                    }\n                } else {\n                    if (loop) {\n                        indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledIndex(listRef, {\n                            startingIndex: currentIndex,\n                            decrement: true,\n                            disabledIndices\n                        });\n                    } else {\n                        indexRef.current = Math.max(minIndex, findNonDisabledIndex(listRef, {\n                            startingIndex: currentIndex,\n                            decrement: true,\n                            disabledIndices\n                        }));\n                    }\n                }\n                if (isIndexOutOfBounds(listRef, indexRef.current)) {\n                    onNavigate(null);\n                } else {\n                    onNavigate(indexRef.current);\n                }\n            }\n        }\n        function checkVirtualMouse(event) {\n            if (focusItemOnOpen === \"auto\" && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isVirtualClick)(event.nativeEvent)) {\n                focusItemOnOpenRef.current = true;\n            }\n        }\n        function checkVirtualPointer(event) {\n            // `pointerdown` fires first, reset the state then perform the checks.\n            focusItemOnOpenRef.current = focusItemOnOpen;\n            if (focusItemOnOpen === \"auto\" && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isVirtualPointerEvent)(event.nativeEvent)) {\n                focusItemOnOpenRef.current = true;\n            }\n        }\n        const ariaActiveDescendantProp = virtual && open && hasActiveIndex && {\n            \"aria-activedescendant\": virtualId || activeId\n        };\n        const activeItem = listRef.current.find((item)=>(item == null ? void 0 : item.id) === activeId);\n        return {\n            reference: {\n                ...ariaActiveDescendantProp,\n                onKeyDown (event) {\n                    isPointerModalityRef.current = false;\n                    const isArrowKey = event.key.indexOf(\"Arrow\") === 0;\n                    const isCrossOpenKey = isCrossOrientationOpenKey(event.key, orientation, rtl);\n                    const isCrossCloseKey = isCrossOrientationCloseKey(event.key, orientation, rtl);\n                    const isMainKey = isMainOrientationKey(event.key, orientation);\n                    const isNavigationKey = (nested ? isCrossOpenKey : isMainKey) || event.key === \"Enter\" || event.key.trim() === \"\";\n                    if (virtual && open) {\n                        const rootNode = tree == null ? void 0 : tree.nodesRef.current.find((node)=>node.parentId == null);\n                        const deepestNode = tree && rootNode ? getDeepestNode(tree.nodesRef.current, rootNode.id) : null;\n                        if (isArrowKey && deepestNode && virtualItemRef) {\n                            const eventObject = new KeyboardEvent(\"keydown\", {\n                                key: event.key,\n                                bubbles: true\n                            });\n                            if (isCrossOpenKey || isCrossCloseKey) {\n                                var _deepestNode$context, _deepestNode$context2;\n                                const isCurrentTarget = ((_deepestNode$context = deepestNode.context) == null ? void 0 : _deepestNode$context.elements.domReference) === event.currentTarget;\n                                const dispatchItem = isCrossCloseKey && !isCurrentTarget ? (_deepestNode$context2 = deepestNode.context) == null ? void 0 : _deepestNode$context2.elements.domReference : isCrossOpenKey ? activeItem : null;\n                                if (dispatchItem) {\n                                    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                                    dispatchItem.dispatchEvent(eventObject);\n                                    setVirtualId(undefined);\n                                }\n                            }\n                            if (isMainKey && deepestNode.context) {\n                                if (deepestNode.context.open && deepestNode.parentId && event.currentTarget !== deepestNode.context.elements.domReference) {\n                                    var _deepestNode$context$;\n                                    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                                    (_deepestNode$context$ = deepestNode.context.elements.domReference) == null || _deepestNode$context$.dispatchEvent(eventObject);\n                                    return;\n                                }\n                            }\n                        }\n                        return onKeyDown(event);\n                    }\n                    // If a floating element should not open on arrow key down, avoid\n                    // setting `activeIndex` while it's closed.\n                    if (!open && !openOnArrowKeyDown && isArrowKey) {\n                        return;\n                    }\n                    if (isNavigationKey) {\n                        keyRef.current = nested && isMainKey ? null : event.key;\n                    }\n                    if (nested) {\n                        if (isCrossOpenKey) {\n                            (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                            if (open) {\n                                indexRef.current = getMinIndex(listRef, disabledIndices);\n                                onNavigate(indexRef.current);\n                            } else {\n                                onOpenChange(true, event.nativeEvent, \"list-navigation\");\n                            }\n                        }\n                        return;\n                    }\n                    if (isMainKey) {\n                        if (selectedIndex != null) {\n                            indexRef.current = selectedIndex;\n                        }\n                        (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                        if (!open && openOnArrowKeyDown) {\n                            onOpenChange(true, event.nativeEvent, \"list-navigation\");\n                        } else {\n                            onKeyDown(event);\n                        }\n                        if (open) {\n                            onNavigate(indexRef.current);\n                        }\n                    }\n                },\n                onFocus () {\n                    if (open) {\n                        onNavigate(null);\n                    }\n                },\n                onPointerDown: checkVirtualPointer,\n                onMouseDown: checkVirtualMouse,\n                onClick: checkVirtualMouse\n            },\n            floating: {\n                \"aria-orientation\": orientation === \"both\" ? undefined : orientation,\n                ...!(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isTypeableCombobox)(domReference) && ariaActiveDescendantProp,\n                onKeyDown,\n                onPointerMove () {\n                    isPointerModalityRef.current = true;\n                }\n            },\n            item\n        };\n    }, [\n        domReference,\n        refs,\n        activeId,\n        virtualId,\n        disabledIndicesRef,\n        latestOpenRef,\n        listRef,\n        enabled,\n        orientation,\n        rtl,\n        virtual,\n        open,\n        hasActiveIndex,\n        nested,\n        selectedIndex,\n        openOnArrowKeyDown,\n        allowEscape,\n        cols,\n        loop,\n        focusItemOnOpen,\n        onNavigate,\n        onOpenChange,\n        item,\n        tree,\n        virtualItemRef\n    ]);\n}\nconst componentRoleToAriaRoleMap = /*#__PURE__*/ new Map([\n    [\n        \"select\",\n        \"listbox\"\n    ],\n    [\n        \"combobox\",\n        \"listbox\"\n    ],\n    [\n        \"label\",\n        false\n    ]\n]);\n/**\n * Adds base screen reader props to the reference and floating elements for a\n * given floating element `role`.\n * @see https://floating-ui.com/docs/useRole\n */ function useRole(context, props) {\n    var _componentRoleToAriaR;\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, floatingId } = context;\n    const { enabled = true, role = \"dialog\" } = props;\n    const ariaRole = (_componentRoleToAriaR = componentRoleToAriaRoleMap.get(role)) != null ? _componentRoleToAriaR : role;\n    const referenceId = useId();\n    const parentId = useFloatingParentNodeId();\n    const isNested = parentId != null;\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) return {};\n        const floatingProps = {\n            id: floatingId,\n            ...ariaRole && {\n                role: ariaRole\n            }\n        };\n        if (ariaRole === \"tooltip\" || role === \"label\") {\n            return {\n                reference: {\n                    [\"aria-\" + (role === \"label\" ? \"labelledby\" : \"describedby\")]: open ? floatingId : undefined\n                },\n                floating: floatingProps\n            };\n        }\n        return {\n            reference: {\n                \"aria-expanded\": open ? \"true\" : \"false\",\n                \"aria-haspopup\": ariaRole === \"alertdialog\" ? \"dialog\" : ariaRole,\n                \"aria-controls\": open ? floatingId : undefined,\n                ...ariaRole === \"listbox\" && {\n                    role: \"combobox\"\n                },\n                ...ariaRole === \"menu\" && {\n                    id: referenceId\n                },\n                ...ariaRole === \"menu\" && isNested && {\n                    role: \"menuitem\"\n                },\n                ...role === \"select\" && {\n                    \"aria-autocomplete\": \"none\"\n                },\n                ...role === \"combobox\" && {\n                    \"aria-autocomplete\": \"list\"\n                }\n            },\n            floating: {\n                ...floatingProps,\n                ...ariaRole === \"menu\" && {\n                    \"aria-labelledby\": referenceId\n                }\n            },\n            item (_ref) {\n                let { active, selected } = _ref;\n                const commonProps = {\n                    role: \"option\",\n                    ...active && {\n                        id: floatingId + \"-option\"\n                    }\n                };\n                // For `menu`, we are unable to tell if the item is a `menuitemradio`\n                // or `menuitemcheckbox`. For backwards-compatibility reasons, also\n                // avoid defaulting to `menuitem` as it may overwrite custom role props.\n                switch(role){\n                    case \"select\":\n                        return {\n                            ...commonProps,\n                            \"aria-selected\": active && selected\n                        };\n                    case \"combobox\":\n                        {\n                            return {\n                                ...commonProps,\n                                ...active && {\n                                    \"aria-selected\": true\n                                }\n                            };\n                        }\n                }\n                return {};\n            }\n        };\n    }, [\n        enabled,\n        role,\n        ariaRole,\n        open,\n        floatingId,\n        referenceId,\n        isNested\n    ]);\n}\n// Converts a JS style key like `backgroundColor` to a CSS transition-property\n// like `background-color`.\nconst camelCaseToKebabCase = (str)=>str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs)=>(ofs ? \"-\" : \"\") + $.toLowerCase());\nfunction execWithArgsOrReturn(valueOrFn, args) {\n    return typeof valueOrFn === \"function\" ? valueOrFn(args) : valueOrFn;\n}\nfunction useDelayUnmount(open, durationMs) {\n    const [isMounted, setIsMounted] = react__WEBPACK_IMPORTED_MODULE_0__.useState(open);\n    if (open && !isMounted) {\n        setIsMounted(true);\n    }\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!open) {\n            const timeout = setTimeout(()=>setIsMounted(false), durationMs);\n            return ()=>clearTimeout(timeout);\n        }\n    }, [\n        open,\n        durationMs\n    ]);\n    return isMounted;\n}\n/**\n * Provides a status string to apply CSS transitions to a floating element,\n * correctly handling placement-aware transitions.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstatus\n */ function useTransitionStatus(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { open, elements: { floating } } = context;\n    const { duration = 250 } = props;\n    const isNumberDuration = typeof duration === \"number\";\n    const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n    const [initiated, setInitiated] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const [status, setStatus] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\"unmounted\");\n    const isMounted = useDelayUnmount(open, closeDuration);\n    // `initiated` check prevents this `setState` call from breaking\n    // <FloatingPortal />. This call is necessary to ensure subsequent opens\n    // after the initial one allows the correct side animation to play when the\n    // placement has changed.\n    index(()=>{\n        if (initiated && !isMounted) {\n            setStatus(\"unmounted\");\n        }\n    }, [\n        initiated,\n        isMounted\n    ]);\n    index(()=>{\n        if (!floating) return;\n        if (open) {\n            setStatus(\"initial\");\n            const frame = requestAnimationFrame(()=>{\n                setStatus(\"open\");\n            });\n            return ()=>{\n                cancelAnimationFrame(frame);\n            };\n        } else {\n            setInitiated(true);\n            setStatus(\"close\");\n        }\n    }, [\n        open,\n        floating\n    ]);\n    return {\n        isMounted,\n        status\n    };\n}\n/**\n * Provides styles to apply CSS transitions to a floating element, correctly\n * handling placement-aware transitions. Wrapper around `useTransitionStatus`.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstyles\n */ function useTransitionStyles(context, props) {\n    if (props === void 0) {\n        props = {};\n    }\n    const { initial: unstable_initial = {\n        opacity: 0\n    }, open: unstable_open, close: unstable_close, common: unstable_common, duration = 250 } = props;\n    const placement = context.placement;\n    const side = placement.split(\"-\")[0];\n    const fnArgs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            side,\n            placement\n        }), [\n        side,\n        placement\n    ]);\n    const isNumberDuration = typeof duration === \"number\";\n    const openDuration = (isNumberDuration ? duration : duration.open) || 0;\n    const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n    const [styles, setStyles] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>({\n            ...execWithArgsOrReturn(unstable_common, fnArgs),\n            ...execWithArgsOrReturn(unstable_initial, fnArgs)\n        }));\n    const { isMounted, status } = useTransitionStatus(context, {\n        duration\n    });\n    const initialRef = useLatestRef(unstable_initial);\n    const openRef = useLatestRef(unstable_open);\n    const closeRef = useLatestRef(unstable_close);\n    const commonRef = useLatestRef(unstable_common);\n    index(()=>{\n        const initialStyles = execWithArgsOrReturn(initialRef.current, fnArgs);\n        const closeStyles = execWithArgsOrReturn(closeRef.current, fnArgs);\n        const commonStyles = execWithArgsOrReturn(commonRef.current, fnArgs);\n        const openStyles = execWithArgsOrReturn(openRef.current, fnArgs) || Object.keys(initialStyles).reduce((acc, key)=>{\n            acc[key] = \"\";\n            return acc;\n        }, {});\n        if (status === \"initial\") {\n            setStyles((styles)=>({\n                    transitionProperty: styles.transitionProperty,\n                    ...commonStyles,\n                    ...initialStyles\n                }));\n        }\n        if (status === \"open\") {\n            setStyles({\n                transitionProperty: Object.keys(openStyles).map(camelCaseToKebabCase).join(\",\"),\n                transitionDuration: openDuration + \"ms\",\n                ...commonStyles,\n                ...openStyles\n            });\n        }\n        if (status === \"close\") {\n            const styles = closeStyles || initialStyles;\n            setStyles({\n                transitionProperty: Object.keys(styles).map(camelCaseToKebabCase).join(\",\"),\n                transitionDuration: closeDuration + \"ms\",\n                ...commonStyles,\n                ...styles\n            });\n        }\n    }, [\n        closeDuration,\n        closeRef,\n        initialRef,\n        openRef,\n        commonRef,\n        openDuration,\n        status,\n        fnArgs\n    ]);\n    return {\n        isMounted,\n        styles\n    };\n}\n/**\n * Provides a matching callback that can be used to focus an item as the user\n * types, often used in tandem with `useListNavigation()`.\n * @see https://floating-ui.com/docs/useTypeahead\n */ function useTypeahead(context, props) {\n    var _ref;\n    const { open, dataRef } = context;\n    const { listRef, activeIndex, onMatch: unstable_onMatch, onTypingChange: unstable_onTypingChange, enabled = true, findMatch = null, resetMs = 750, ignoreKeys = [], selectedIndex = null } = props;\n    const timeoutIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const stringRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(\"\");\n    const prevIndexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef((_ref = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref : -1);\n    const matchIndexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const onMatch = useEffectEvent(unstable_onMatch);\n    const onTypingChange = useEffectEvent(unstable_onTypingChange);\n    const findMatchRef = useLatestRef(findMatch);\n    const ignoreKeysRef = useLatestRef(ignoreKeys);\n    index(()=>{\n        if (open) {\n            clearTimeout(timeoutIdRef.current);\n            matchIndexRef.current = null;\n            stringRef.current = \"\";\n        }\n    }, [\n        open\n    ]);\n    index(()=>{\n        // Sync arrow key navigation but not typeahead navigation.\n        if (open && stringRef.current === \"\") {\n            var _ref2;\n            prevIndexRef.current = (_ref2 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref2 : -1;\n        }\n    }, [\n        open,\n        selectedIndex,\n        activeIndex\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) {\n            return {};\n        }\n        function setTypingChange(value) {\n            if (value) {\n                if (!dataRef.current.typing) {\n                    dataRef.current.typing = value;\n                    onTypingChange(value);\n                }\n            } else {\n                if (dataRef.current.typing) {\n                    dataRef.current.typing = value;\n                    onTypingChange(value);\n                }\n            }\n        }\n        function getMatchingIndex(list, orderedList, string) {\n            const str = findMatchRef.current ? findMatchRef.current(orderedList, string) : orderedList.find((text)=>(text == null ? void 0 : text.toLocaleLowerCase().indexOf(string.toLocaleLowerCase())) === 0);\n            return str ? list.indexOf(str) : -1;\n        }\n        function onKeyDown(event) {\n            const listContent = listRef.current;\n            if (stringRef.current.length > 0 && stringRef.current[0] !== \" \") {\n                if (getMatchingIndex(listContent, listContent, stringRef.current) === -1) {\n                    setTypingChange(false);\n                } else if (event.key === \" \") {\n                    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                }\n            }\n            if (listContent == null || ignoreKeysRef.current.includes(event.key) || // Character key.\n            event.key.length !== 1 || // Modifier key.\n            event.ctrlKey || event.metaKey || event.altKey) {\n                return;\n            }\n            if (open && event.key !== \" \") {\n                (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                setTypingChange(true);\n            }\n            // Bail out if the list contains a word like \"llama\" or \"aaron\". TODO:\n            // allow it in this case, too.\n            const allowRapidSuccessionOfFirstLetter = listContent.every((text)=>{\n                var _text$, _text$2;\n                return text ? ((_text$ = text[0]) == null ? void 0 : _text$.toLocaleLowerCase()) !== ((_text$2 = text[1]) == null ? void 0 : _text$2.toLocaleLowerCase()) : true;\n            });\n            // Allows the user to cycle through items that start with the same letter\n            // in rapid succession.\n            if (allowRapidSuccessionOfFirstLetter && stringRef.current === event.key) {\n                stringRef.current = \"\";\n                prevIndexRef.current = matchIndexRef.current;\n            }\n            stringRef.current += event.key;\n            clearTimeout(timeoutIdRef.current);\n            timeoutIdRef.current = setTimeout(()=>{\n                stringRef.current = \"\";\n                prevIndexRef.current = matchIndexRef.current;\n                setTypingChange(false);\n            }, resetMs);\n            const prevIndex = prevIndexRef.current;\n            const index = getMatchingIndex(listContent, [\n                ...listContent.slice((prevIndex || 0) + 1),\n                ...listContent.slice(0, (prevIndex || 0) + 1)\n            ], stringRef.current);\n            if (index !== -1) {\n                onMatch(index);\n                matchIndexRef.current = index;\n            } else if (event.key !== \" \") {\n                stringRef.current = \"\";\n                setTypingChange(false);\n            }\n        }\n        return {\n            reference: {\n                onKeyDown\n            },\n            floating: {\n                onKeyDown,\n                onKeyUp (event) {\n                    if (event.key === \" \") {\n                        setTypingChange(false);\n                    }\n                }\n            }\n        };\n    }, [\n        enabled,\n        open,\n        dataRef,\n        listRef,\n        resetMs,\n        ignoreKeysRef,\n        findMatchRef,\n        onMatch,\n        onTypingChange\n    ]);\n}\nfunction getArgsWithCustomFloatingHeight(state, height) {\n    return {\n        ...state,\n        rects: {\n            ...state.rects,\n            floating: {\n                ...state.rects.floating,\n                height\n            }\n        }\n    };\n}\n/**\n * Positions the floating element such that an inner element inside\n * of it is anchored to the reference element.\n * @see https://floating-ui.com/docs/inner\n */ const inner = (props)=>({\n        name: \"inner\",\n        options: props,\n        async fn (state) {\n            const { listRef, overflowRef, onFallbackChange, offset: innerOffset = 0, index = 0, minItemsVisible = 4, referenceOverflowThreshold = 0, scrollRef, ...detectOverflowOptions } = props;\n            const { rects, elements: { floating } } = state;\n            const item = listRef.current[index];\n            if (true) {\n                if (!state.placement.startsWith(\"bottom\")) {\n                    console.warn([\n                        'Floating UI: `placement` side must be \"bottom\" when using the',\n                        \"`inner` middleware.\"\n                    ].join(\" \"));\n                }\n            }\n            if (!item) {\n                return {};\n            }\n            const nextArgs = {\n                ...state,\n                ...await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.offset)(-item.offsetTop - floating.clientTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state)\n            };\n            const el = (scrollRef == null ? void 0 : scrollRef.current) || floating;\n            const overflow = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.detectOverflow)(getArgsWithCustomFloatingHeight(nextArgs, el.scrollHeight), detectOverflowOptions);\n            const refOverflow = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.detectOverflow)(nextArgs, {\n                ...detectOverflowOptions,\n                elementContext: \"reference\"\n            });\n            const diffY = Math.max(0, overflow.top);\n            const nextY = nextArgs.y + diffY;\n            const maxHeight = Math.max(0, el.scrollHeight - diffY - Math.max(0, overflow.bottom));\n            el.style.maxHeight = maxHeight + \"px\";\n            el.scrollTop = diffY;\n            // There is not enough space, fallback to standard anchored positioning\n            if (onFallbackChange) {\n                if (el.offsetHeight < item.offsetHeight * Math.min(minItemsVisible, listRef.current.length - 1) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold) {\n                    (0,react_dom__WEBPACK_IMPORTED_MODULE_5__.flushSync)(()=>onFallbackChange(true));\n                } else {\n                    (0,react_dom__WEBPACK_IMPORTED_MODULE_5__.flushSync)(()=>onFallbackChange(false));\n                }\n            }\n            if (overflowRef) {\n                overflowRef.current = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_2__.detectOverflow)(getArgsWithCustomFloatingHeight({\n                    ...nextArgs,\n                    y: nextY\n                }, el.offsetHeight), detectOverflowOptions);\n            }\n            return {\n                y: nextY\n            };\n        }\n    });\n/**\n * Changes the `inner` middleware's `offset` upon a `wheel` event to\n * expand the floating element's height, revealing more list items.\n * @see https://floating-ui.com/docs/inner\n */ function useInnerOffset(context, props) {\n    const { open, elements } = context;\n    const { enabled = true, overflowRef, scrollRef, onChange: unstable_onChange } = props;\n    const onChange = useEffectEvent(unstable_onChange);\n    const controlledScrollingRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const prevScrollTopRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const initialOverflowRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!enabled) {\n            return;\n        }\n        function onWheel(e) {\n            if (e.ctrlKey || !el || overflowRef.current == null) {\n                return;\n            }\n            const dY = e.deltaY;\n            const isAtTop = overflowRef.current.top >= -0.5;\n            const isAtBottom = overflowRef.current.bottom >= -0.5;\n            const remainingScroll = el.scrollHeight - el.clientHeight;\n            const sign = dY < 0 ? -1 : 1;\n            const method = dY < 0 ? \"max\" : \"min\";\n            if (el.scrollHeight <= el.clientHeight) {\n                return;\n            }\n            if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {\n                e.preventDefault();\n                (0,react_dom__WEBPACK_IMPORTED_MODULE_5__.flushSync)(()=>{\n                    onChange((d)=>d + Math[method](dY, remainingScroll * sign));\n                });\n            } else if (/firefox/i.test((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getUserAgent)())) {\n                // Needed to propagate scrolling during momentum scrolling phase once\n                // it gets limited by the boundary. UX improvement, not critical.\n                el.scrollTop += dY;\n            }\n        }\n        const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n        if (open && el) {\n            el.addEventListener(\"wheel\", onWheel);\n            // Wait for the position to be ready.\n            requestAnimationFrame(()=>{\n                prevScrollTopRef.current = el.scrollTop;\n                if (overflowRef.current != null) {\n                    initialOverflowRef.current = {\n                        ...overflowRef.current\n                    };\n                }\n            });\n            return ()=>{\n                prevScrollTopRef.current = null;\n                initialOverflowRef.current = null;\n                el.removeEventListener(\"wheel\", onWheel);\n            };\n        }\n    }, [\n        enabled,\n        open,\n        elements.floating,\n        overflowRef,\n        scrollRef,\n        onChange\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!enabled) {\n            return {};\n        }\n        return {\n            floating: {\n                onKeyDown () {\n                    controlledScrollingRef.current = true;\n                },\n                onWheel () {\n                    controlledScrollingRef.current = false;\n                },\n                onPointerMove () {\n                    controlledScrollingRef.current = false;\n                },\n                onScroll () {\n                    const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n                    if (!overflowRef.current || !el || !controlledScrollingRef.current) {\n                        return;\n                    }\n                    if (prevScrollTopRef.current !== null) {\n                        const scrollDiff = el.scrollTop - prevScrollTopRef.current;\n                        if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {\n                            (0,react_dom__WEBPACK_IMPORTED_MODULE_5__.flushSync)(()=>onChange((d)=>d + scrollDiff));\n                        }\n                    }\n                    // [Firefox] Wait for the height change to have been applied.\n                    requestAnimationFrame(()=>{\n                        prevScrollTopRef.current = el.scrollTop;\n                    });\n                }\n            }\n        };\n    }, [\n        enabled,\n        overflowRef,\n        elements.floating,\n        scrollRef,\n        onChange\n    ]);\n}\nfunction isPointInPolygon(point, polygon) {\n    const [x, y] = point;\n    let isInside = false;\n    const length = polygon.length;\n    for(let i = 0, j = length - 1; i < length; j = i++){\n        const [xi, yi] = polygon[i] || [\n            0,\n            0\n        ];\n        const [xj, yj] = polygon[j] || [\n            0,\n            0\n        ];\n        const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;\n        if (intersect) {\n            isInside = !isInside;\n        }\n    }\n    return isInside;\n}\nfunction isInside(point, rect) {\n    return point[0] >= rect.x && point[0] <= rect.x + rect.width && point[1] >= rect.y && point[1] <= rect.y + rect.height;\n}\n/**\n * Generates a safe polygon area that the user can traverse without closing the\n * floating element once leaving the reference element.\n * @see https://floating-ui.com/docs/useHover#safePolygon\n */ function safePolygon(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { buffer = 0.5, blockPointerEvents = false, requireIntent = true } = options;\n    let timeoutId;\n    let hasLanded = false;\n    let lastX = null;\n    let lastY = null;\n    let lastCursorTime = performance.now();\n    function getCursorSpeed(x, y) {\n        const currentTime = performance.now();\n        const elapsedTime = currentTime - lastCursorTime;\n        if (lastX === null || lastY === null || elapsedTime === 0) {\n            lastX = x;\n            lastY = y;\n            lastCursorTime = currentTime;\n            return null;\n        }\n        const deltaX = x - lastX;\n        const deltaY = y - lastY;\n        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n        const speed = distance / elapsedTime; // px / ms\n        lastX = x;\n        lastY = y;\n        lastCursorTime = currentTime;\n        return speed;\n    }\n    const fn = (_ref)=>{\n        let { x, y, placement, elements, onClose, nodeId, tree } = _ref;\n        return function onMouseMove(event) {\n            function close() {\n                clearTimeout(timeoutId);\n                onClose();\n            }\n            clearTimeout(timeoutId);\n            if (!elements.domReference || !elements.floating || placement == null || x == null || y == null) {\n                return;\n            }\n            const { clientX, clientY } = event;\n            const clientPoint = [\n                clientX,\n                clientY\n            ];\n            const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event);\n            const isLeave = event.type === \"mouseleave\";\n            const isOverFloatingEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(elements.floating, target);\n            const isOverReferenceEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(elements.domReference, target);\n            const refRect = elements.domReference.getBoundingClientRect();\n            const rect = elements.floating.getBoundingClientRect();\n            const side = placement.split(\"-\")[0];\n            const cursorLeaveFromRight = x > rect.right - rect.width / 2;\n            const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2;\n            const isOverReferenceRect = isInside(clientPoint, refRect);\n            const isFloatingWider = rect.width > refRect.width;\n            const isFloatingTaller = rect.height > refRect.height;\n            const left = (isFloatingWider ? refRect : rect).left;\n            const right = (isFloatingWider ? refRect : rect).right;\n            const top = (isFloatingTaller ? refRect : rect).top;\n            const bottom = (isFloatingTaller ? refRect : rect).bottom;\n            if (isOverFloatingEl) {\n                hasLanded = true;\n                if (!isLeave) {\n                    return;\n                }\n            }\n            if (isOverReferenceEl) {\n                hasLanded = false;\n            }\n            if (isOverReferenceEl && !isLeave) {\n                hasLanded = true;\n                return;\n            }\n            // Prevent overlapping floating element from being stuck in an open-close\n            // loop: https://github.com/floating-ui/floating-ui/issues/1910\n            if (isLeave && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.isElement)(event.relatedTarget) && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(elements.floating, event.relatedTarget)) {\n                return;\n            }\n            // If any nested child is open, abort.\n            if (tree && getChildren(tree.nodesRef.current, nodeId).some((_ref2)=>{\n                let { context } = _ref2;\n                return context == null ? void 0 : context.open;\n            })) {\n                return;\n            }\n            // If the pointer is leaving from the opposite side, the \"buffer\" logic\n            // creates a point where the floating element remains open, but should be\n            // ignored.\n            // A constant of 1 handles floating point rounding errors.\n            if (side === \"top\" && y >= refRect.bottom - 1 || side === \"bottom\" && y <= refRect.top + 1 || side === \"left\" && x >= refRect.right - 1 || side === \"right\" && x <= refRect.left + 1) {\n                return close();\n            }\n            // Ignore when the cursor is within the rectangular trough between the\n            // two elements. Since the triangle is created from the cursor point,\n            // which can start beyond the ref element's edge, traversing back and\n            // forth from the ref to the floating element can cause it to close. This\n            // ensures it always remains open in that case.\n            let rectPoly = [];\n            switch(side){\n                case \"top\":\n                    rectPoly = [\n                        [\n                            left,\n                            refRect.top + 1\n                        ],\n                        [\n                            left,\n                            rect.bottom - 1\n                        ],\n                        [\n                            right,\n                            rect.bottom - 1\n                        ],\n                        [\n                            right,\n                            refRect.top + 1\n                        ]\n                    ];\n                    break;\n                case \"bottom\":\n                    rectPoly = [\n                        [\n                            left,\n                            rect.top + 1\n                        ],\n                        [\n                            left,\n                            refRect.bottom - 1\n                        ],\n                        [\n                            right,\n                            refRect.bottom - 1\n                        ],\n                        [\n                            right,\n                            rect.top + 1\n                        ]\n                    ];\n                    break;\n                case \"left\":\n                    rectPoly = [\n                        [\n                            rect.right - 1,\n                            bottom\n                        ],\n                        [\n                            rect.right - 1,\n                            top\n                        ],\n                        [\n                            refRect.left + 1,\n                            top\n                        ],\n                        [\n                            refRect.left + 1,\n                            bottom\n                        ]\n                    ];\n                    break;\n                case \"right\":\n                    rectPoly = [\n                        [\n                            refRect.right - 1,\n                            bottom\n                        ],\n                        [\n                            refRect.right - 1,\n                            top\n                        ],\n                        [\n                            rect.left + 1,\n                            top\n                        ],\n                        [\n                            rect.left + 1,\n                            bottom\n                        ]\n                    ];\n                    break;\n            }\n            function getPolygon(_ref3) {\n                let [x, y] = _ref3;\n                switch(side){\n                    case \"top\":\n                        {\n                            const cursorPointOne = [\n                                isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4,\n                                y + buffer + 1\n                            ];\n                            const cursorPointTwo = [\n                                isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4,\n                                y + buffer + 1\n                            ];\n                            const commonPoints = [\n                                [\n                                    rect.left,\n                                    cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top\n                                ],\n                                [\n                                    rect.right,\n                                    cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer\n                                ]\n                            ];\n                            return [\n                                cursorPointOne,\n                                cursorPointTwo,\n                                ...commonPoints\n                            ];\n                        }\n                    case \"bottom\":\n                        {\n                            const cursorPointOne = [\n                                isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4,\n                                y - buffer\n                            ];\n                            const cursorPointTwo = [\n                                isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4,\n                                y - buffer\n                            ];\n                            const commonPoints = [\n                                [\n                                    rect.left,\n                                    cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom\n                                ],\n                                [\n                                    rect.right,\n                                    cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer\n                                ]\n                            ];\n                            return [\n                                cursorPointOne,\n                                cursorPointTwo,\n                                ...commonPoints\n                            ];\n                        }\n                    case \"left\":\n                        {\n                            const cursorPointOne = [\n                                x + buffer + 1,\n                                isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4\n                            ];\n                            const cursorPointTwo = [\n                                x + buffer + 1,\n                                isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4\n                            ];\n                            const commonPoints = [\n                                [\n                                    cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left,\n                                    rect.top\n                                ],\n                                [\n                                    cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer,\n                                    rect.bottom\n                                ]\n                            ];\n                            return [\n                                ...commonPoints,\n                                cursorPointOne,\n                                cursorPointTwo\n                            ];\n                        }\n                    case \"right\":\n                        {\n                            const cursorPointOne = [\n                                x - buffer,\n                                isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4\n                            ];\n                            const cursorPointTwo = [\n                                x - buffer,\n                                isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4\n                            ];\n                            const commonPoints = [\n                                [\n                                    cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right,\n                                    rect.top\n                                ],\n                                [\n                                    cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer,\n                                    rect.bottom\n                                ]\n                            ];\n                            return [\n                                cursorPointOne,\n                                cursorPointTwo,\n                                ...commonPoints\n                            ];\n                        }\n                }\n            }\n            if (isPointInPolygon([\n                clientX,\n                clientY\n            ], rectPoly)) {\n                return;\n            } else if (hasLanded && !isOverReferenceRect) {\n                return close();\n            }\n            if (!isLeave && requireIntent) {\n                const cursorSpeed = getCursorSpeed(event.clientX, event.clientY);\n                const cursorSpeedThreshold = 0.1;\n                if (cursorSpeed !== null && cursorSpeed < cursorSpeedThreshold) {\n                    return close();\n                }\n            }\n            if (!isPointInPolygon([\n                clientX,\n                clientY\n            ], getPolygon([\n                x,\n                y\n            ]))) {\n                close();\n            } else if (!hasLanded && requireIntent) {\n                timeoutId = window.setTimeout(close, 40);\n            }\n        };\n    };\n    fn.__options = {\n        blockPointerEvents\n    };\n    return fn;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0L2Rpc3QvZmxvYXRpbmctdWkucmVhY3QubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDNEI7QUFDK087QUFDL1A7QUFDbUY7QUFDa0U7QUFDOUM7QUFDOUc7QUFDZ0I7QUFFcEQ7OztDQUdDLEdBQ0QsU0FBU2dELGFBQWFDLElBQUk7SUFDeEIsT0FBT2pELDBDQUFhLENBQUM7UUFDbkIsSUFBSWlELEtBQUtFLEtBQUssQ0FBQ0MsQ0FBQUEsTUFBT0EsT0FBTyxPQUFPO1lBQ2xDLE9BQU87UUFDVDtRQUNBLE9BQU9DLENBQUFBO1lBQ0xKLEtBQUtLLE9BQU8sQ0FBQ0YsQ0FBQUE7Z0JBQ1gsSUFBSSxPQUFPQSxRQUFRLFlBQVk7b0JBQzdCQSxJQUFJQztnQkFDTixPQUFPLElBQUlELE9BQU8sTUFBTTtvQkFDdEJBLElBQUlHLE9BQU8sR0FBR0Y7Z0JBQ2hCO1lBQ0Y7UUFDRjtJQUNBLHVEQUF1RDtJQUN6RCxHQUFHSjtBQUNMO0FBRUEsNkZBQTZGO0FBQzdGLE1BQU1PLHFCQUFxQnhELHlMQUFLLENBQUMsV0FBVyxHQUFFLHFCQUFxQnlELFFBQVEsR0FBRztBQUM5RSxNQUFNQyx5QkFBeUJGLHNCQUF1QkcsQ0FBQUEsQ0FBQUEsS0FBTUEsSUFBRztBQUMvRCxTQUFTQyxlQUFlQyxRQUFRO0lBQzlCLE1BQU1ULE1BQU1wRCx5Q0FBWSxDQUFDO1FBQ3ZCLElBQUk4RCxJQUFxQyxFQUFFO1lBQ3pDLE1BQU0sSUFBSUMsTUFBTTtRQUNsQjtJQUNGO0lBQ0FMLHVCQUF1QjtRQUNyQk4sSUFBSUcsT0FBTyxHQUFHTTtJQUNoQjtJQUNBLE9BQU83RCw4Q0FBaUIsQ0FBQztRQUN2QixJQUFLLElBQUlpRSxPQUFPQyxVQUFVQyxNQUFNLEVBQUVDLE9BQU8sSUFBSUMsTUFBTUosT0FBT0ssT0FBTyxH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SzNxQixLQUFLLEdBQUcycUIsS0FBSzdxQixJQUFJLEdBQUcrcUI7b0NBQVFGLEtBQUs1cUIsTUFBTTtpQ0FBQzs2QkFBQzs0QkFDbFAsT0FBTztnQ0FBQ3lzQjtnQ0FBZ0JDO21DQUFtQkM7NkJBQWE7d0JBQzFEO2dCQUNKO1lBQ0Y7WUFDQSxJQUFJekMsaUJBQWlCO2dCQUFDN2tCO2dCQUFTQzthQUFRLEVBQUVpbkIsV0FBVztnQkFDbEQ7WUFDRixPQUFPLElBQUl2QixhQUFhLENBQUNvQixxQkFBcUI7Z0JBQzVDLE9BQU8za0I7WUFDVDtZQUNBLElBQUksQ0FBQ3FrQixXQUFXZixlQUFlO2dCQUM3QixNQUFNNkIsY0FBY3RCLGVBQWU5MUIsTUFBTTZQLE9BQU8sRUFBRTdQLE1BQU04UCxPQUFPO2dCQUMvRCxNQUFNdW5CLHVCQUF1QjtnQkFDN0IsSUFBSUQsZ0JBQWdCLFFBQVFBLGNBQWNDLHNCQUFzQjtvQkFDOUQsT0FBT3BsQjtnQkFDVDtZQUNGO1lBQ0EsSUFBSSxDQUFDeWlCLGlCQUFpQjtnQkFBQzdrQjtnQkFBU0M7YUFBUSxFQUFFa25CLFdBQVc7Z0JBQUMvc0I7Z0JBQUdFO2FBQUUsSUFBSTtnQkFDN0Q4SDtZQUNGLE9BQU8sSUFBSSxDQUFDdWpCLGFBQWFELGVBQWU7Z0JBQ3RDMWQsWUFBWXpGLE9BQU9qRCxVQUFVLENBQUM4QyxPQUFPO1lBQ3ZDO1FBQ0Y7SUFDRjtJQUNBelUsR0FBRzZTLFNBQVMsR0FBRztRQUNiQztJQUNGO0lBQ0EsT0FBTzlTO0FBQ1Q7QUFFbWhCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLWFwcC8uL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvcmVhY3QvZGlzdC9mbG9hdGluZy11aS5yZWFjdC5tanM/NjZjZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QsIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgc3RvcEV2ZW50LCBnZXREb2N1bWVudCwgaXNNb3VzZUxpa2VQb2ludGVyVHlwZSwgY29udGFpbnMsIGFjdGl2ZUVsZW1lbnQsIGlzU2FmYXJpLCBpc1R5cGVhYmxlQ29tYm9ib3gsIGlzVmlydHVhbENsaWNrLCBpc1ZpcnR1YWxQb2ludGVyRXZlbnQsIGdldFRhcmdldCwgZ2V0UGxhdGZvcm0sIGlzVHlwZWFibGVFbGVtZW50LCBpc1JlYWN0RXZlbnQsIGlzUm9vdEVsZW1lbnQsIGlzRXZlbnRUYXJnZXRXaXRoaW4sIGlzTWFjLCBnZXRVc2VyQWdlbnQgfSBmcm9tICdAZmxvYXRpbmctdWkvcmVhY3QvdXRpbHMnO1xuaW1wb3J0IHsgZmxvb3IgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMnO1xuaW1wb3J0IHsgcGxhdGZvcm0sIGdldE92ZXJmbG93QW5jZXN0b3JzLCB1c2VGbG9hdGluZyBhcyB1c2VGbG9hdGluZyQxLCBvZmZzZXQsIGRldGVjdE92ZXJmbG93IH0gZnJvbSAnQGZsb2F0aW5nLXVpL3JlYWN0LWRvbSc7XG5leHBvcnQgeyBhcnJvdywgYXV0b1BsYWNlbWVudCwgYXV0b1VwZGF0ZSwgY29tcHV0ZVBvc2l0aW9uLCBkZXRlY3RPdmVyZmxvdywgZmxpcCwgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMsIGhpZGUsIGlubGluZSwgbGltaXRTaGlmdCwgb2Zmc2V0LCBwbGF0Zm9ybSwgc2hpZnQsIHNpemUgfSBmcm9tICdAZmxvYXRpbmctdWkvcmVhY3QtZG9tJztcbmltcG9ydCB7IGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCwgZ2V0Tm9kZU5hbWUsIGdldFdpbmRvdywgaXNMYXN0VHJhdmVyc2FibGVOb2RlLCBnZXRQYXJlbnROb2RlLCBnZXRDb21wdXRlZFN0eWxlIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzL2RvbSc7XG5pbXBvcnQgeyB0YWJiYWJsZSB9IGZyb20gJ3RhYmJhYmxlJztcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCwgZmx1c2hTeW5jIH0gZnJvbSAncmVhY3QtZG9tJztcblxuLyoqXG4gKiBNZXJnZXMgYW4gYXJyYXkgb2YgcmVmcyBpbnRvIGEgc2luZ2xlIG1lbW9pemVkIGNhbGxiYWNrIHJlZiBvciBgbnVsbGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlTWVyZ2VSZWZzXG4gKi9cbmZ1bmN0aW9uIHVzZU1lcmdlUmVmcyhyZWZzKSB7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAocmVmcy5ldmVyeShyZWYgPT4gcmVmID09IG51bGwpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlID0+IHtcbiAgICAgIHJlZnMuZm9yRWFjaChyZWYgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJlZih2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVmICE9IG51bGwpIHtcbiAgICAgICAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgcmVmcyk7XG59XG5cbi8vIGB0b1N0cmluZygpYCBwcmV2ZW50cyBidW5kbGVycyBmcm9tIHRyeWluZyB0byBgaW1wb3J0IHsgdXNlSW5zZXJ0aW9uRWZmZWN0IH0gZnJvbSAncmVhY3QnYFxuY29uc3QgdXNlSW5zZXJ0aW9uRWZmZWN0ID0gUmVhY3RbLyojX19QVVJFX18qLyd1c2VJbnNlcnRpb25FZmZlY3QnLnRvU3RyaW5nKCldO1xuY29uc3QgdXNlU2FmZUluc2VydGlvbkVmZmVjdCA9IHVzZUluc2VydGlvbkVmZmVjdCB8fCAoZm4gPT4gZm4oKSk7XG5mdW5jdGlvbiB1c2VFZmZlY3RFdmVudChjYWxsYmFjaykge1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYoKCkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGwgYW4gZXZlbnQgaGFuZGxlciB3aGlsZSByZW5kZXJpbmcuJyk7XG4gICAgfVxuICB9KTtcbiAgdXNlU2FmZUluc2VydGlvbkVmZmVjdCgoKSA9PiB7XG4gICAgcmVmLmN1cnJlbnQgPSBjYWxsYmFjaztcbiAgfSk7XG4gIHJldHVybiBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICByZXR1cm4gcmVmLmN1cnJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi5jdXJyZW50KC4uLmFyZ3MpO1xuICB9LCBbXSk7XG59XG5cbmNvbnN0IEFSUk9XX1VQID0gJ0Fycm93VXAnO1xuY29uc3QgQVJST1dfRE9XTiA9ICdBcnJvd0Rvd24nO1xuY29uc3QgQVJST1dfTEVGVCA9ICdBcnJvd0xlZnQnO1xuY29uc3QgQVJST1dfUklHSFQgPSAnQXJyb3dSaWdodCc7XG5mdW5jdGlvbiBpc0RpZmZlcmVudFJvdyhpbmRleCwgY29scywgcHJldlJvdykge1xuICByZXR1cm4gTWF0aC5mbG9vcihpbmRleCAvIGNvbHMpICE9PSBwcmV2Um93O1xufVxuZnVuY3Rpb24gaXNJbmRleE91dE9mQm91bmRzKGxpc3RSZWYsIGluZGV4KSB7XG4gIHJldHVybiBpbmRleCA8IDAgfHwgaW5kZXggPj0gbGlzdFJlZi5jdXJyZW50Lmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGdldE1pbkluZGV4KGxpc3RSZWYsIGRpc2FibGVkSW5kaWNlcykge1xuICByZXR1cm4gZmluZE5vbkRpc2FibGVkSW5kZXgobGlzdFJlZiwge1xuICAgIGRpc2FibGVkSW5kaWNlc1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldE1heEluZGV4KGxpc3RSZWYsIGRpc2FibGVkSW5kaWNlcykge1xuICByZXR1cm4gZmluZE5vbkRpc2FibGVkSW5kZXgobGlzdFJlZiwge1xuICAgIGRlY3JlbWVudDogdHJ1ZSxcbiAgICBzdGFydGluZ0luZGV4OiBsaXN0UmVmLmN1cnJlbnQubGVuZ3RoLFxuICAgIGRpc2FibGVkSW5kaWNlc1xuICB9KTtcbn1cbmZ1bmN0aW9uIGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIF90ZW1wKSB7XG4gIGxldCB7XG4gICAgc3RhcnRpbmdJbmRleCA9IC0xLFxuICAgIGRlY3JlbWVudCA9IGZhbHNlLFxuICAgIGRpc2FibGVkSW5kaWNlcyxcbiAgICBhbW91bnQgPSAxXG4gIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcbiAgY29uc3QgbGlzdCA9IGxpc3RSZWYuY3VycmVudDtcbiAgY29uc3QgaXNEaXNhYmxlZEluZGV4ID0gZGlzYWJsZWRJbmRpY2VzID8gaW5kZXggPT4gZGlzYWJsZWRJbmRpY2VzLmluY2x1ZGVzKGluZGV4KSA6IGluZGV4ID0+IHtcbiAgICBjb25zdCBlbGVtZW50ID0gbGlzdFtpbmRleF07XG4gICAgcmV0dXJuIGVsZW1lbnQgPT0gbnVsbCB8fCBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSB8fCBlbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcpID09PSAndHJ1ZSc7XG4gIH07XG4gIGxldCBpbmRleCA9IHN0YXJ0aW5nSW5kZXg7XG4gIGRvIHtcbiAgICBpbmRleCArPSBkZWNyZW1lbnQgPyAtYW1vdW50IDogYW1vdW50O1xuICB9IHdoaWxlIChpbmRleCA+PSAwICYmIGluZGV4IDw9IGxpc3QubGVuZ3RoIC0gMSAmJiBpc0Rpc2FibGVkSW5kZXgoaW5kZXgpKTtcbiAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gZ2V0R3JpZE5hdmlnYXRlZEluZGV4KGVsZW1lbnRzUmVmLCBfcmVmKSB7XG4gIGxldCB7XG4gICAgZXZlbnQsXG4gICAgb3JpZW50YXRpb24sXG4gICAgbG9vcCxcbiAgICBjb2xzLFxuICAgIGRpc2FibGVkSW5kaWNlcyxcbiAgICBtaW5JbmRleCxcbiAgICBtYXhJbmRleCxcbiAgICBwcmV2SW5kZXgsXG4gICAgc3RvcEV2ZW50OiBzdG9wID0gZmFsc2VcbiAgfSA9IF9yZWY7XG4gIGxldCBuZXh0SW5kZXggPSBwcmV2SW5kZXg7XG4gIGlmIChldmVudC5rZXkgPT09IEFSUk9XX1VQKSB7XG4gICAgc3RvcCAmJiBzdG9wRXZlbnQoZXZlbnQpO1xuICAgIGlmIChwcmV2SW5kZXggPT09IC0xKSB7XG4gICAgICBuZXh0SW5kZXggPSBtYXhJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dEluZGV4ID0gZmluZE5vbkRpc2FibGVkSW5kZXgoZWxlbWVudHNSZWYsIHtcbiAgICAgICAgc3RhcnRpbmdJbmRleDogbmV4dEluZGV4LFxuICAgICAgICBhbW91bnQ6IGNvbHMsXG4gICAgICAgIGRlY3JlbWVudDogdHJ1ZSxcbiAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICB9KTtcbiAgICAgIGlmIChsb29wICYmIChwcmV2SW5kZXggLSBjb2xzIDwgbWluSW5kZXggfHwgbmV4dEluZGV4IDwgMCkpIHtcbiAgICAgICAgY29uc3QgY29sID0gcHJldkluZGV4ICUgY29scztcbiAgICAgICAgY29uc3QgbWF4Q29sID0gbWF4SW5kZXggJSBjb2xzO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBtYXhJbmRleCAtIChtYXhDb2wgLSBjb2wpO1xuICAgICAgICBpZiAobWF4Q29sID09PSBjb2wpIHtcbiAgICAgICAgICBuZXh0SW5kZXggPSBtYXhJbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0SW5kZXggPSBtYXhDb2wgPiBjb2wgPyBvZmZzZXQgOiBvZmZzZXQgLSBjb2xzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0luZGV4T3V0T2ZCb3VuZHMoZWxlbWVudHNSZWYsIG5leHRJbmRleCkpIHtcbiAgICAgIG5leHRJbmRleCA9IHByZXZJbmRleDtcbiAgICB9XG4gIH1cbiAgaWYgKGV2ZW50LmtleSA9PT0gQVJST1dfRE9XTikge1xuICAgIHN0b3AgJiYgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICBpZiAocHJldkluZGV4ID09PSAtMSkge1xuICAgICAgbmV4dEluZGV4ID0gbWluSW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGVsZW1lbnRzUmVmLCB7XG4gICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCxcbiAgICAgICAgYW1vdW50OiBjb2xzLFxuICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgIH0pO1xuICAgICAgaWYgKGxvb3AgJiYgcHJldkluZGV4ICsgY29scyA+IG1heEluZGV4KSB7XG4gICAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGVsZW1lbnRzUmVmLCB7XG4gICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4ICUgY29scyAtIGNvbHMsXG4gICAgICAgICAgYW1vdW50OiBjb2xzLFxuICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzSW5kZXhPdXRPZkJvdW5kcyhlbGVtZW50c1JlZiwgbmV4dEluZGV4KSkge1xuICAgICAgbmV4dEluZGV4ID0gcHJldkluZGV4O1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbWFpbnMgb24gdGhlIHNhbWUgcm93L2NvbHVtbi5cbiAgaWYgKG9yaWVudGF0aW9uID09PSAnYm90aCcpIHtcbiAgICBjb25zdCBwcmV2Um93ID0gZmxvb3IocHJldkluZGV4IC8gY29scyk7XG4gICAgaWYgKGV2ZW50LmtleSA9PT0gQVJST1dfUklHSFQpIHtcbiAgICAgIHN0b3AgJiYgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgIGlmIChwcmV2SW5kZXggJSBjb2xzICE9PSBjb2xzIC0gMSkge1xuICAgICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRJbmRleChlbGVtZW50c1JlZiwge1xuICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCxcbiAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChsb29wICYmIGlzRGlmZmVyZW50Um93KG5leHRJbmRleCwgY29scywgcHJldlJvdykpIHtcbiAgICAgICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRJbmRleChlbGVtZW50c1JlZiwge1xuICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4IC0gcHJldkluZGV4ICUgY29scyAtIDEsXG4gICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsb29wKSB7XG4gICAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGVsZW1lbnRzUmVmLCB7XG4gICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4IC0gcHJldkluZGV4ICUgY29scyAtIDEsXG4gICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGlmZmVyZW50Um93KG5leHRJbmRleCwgY29scywgcHJldlJvdykpIHtcbiAgICAgICAgbmV4dEluZGV4ID0gcHJldkluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXZlbnQua2V5ID09PSBBUlJPV19MRUZUKSB7XG4gICAgICBzdG9wICYmIHN0b3BFdmVudChldmVudCk7XG4gICAgICBpZiAocHJldkluZGV4ICUgY29scyAhPT0gMCkge1xuICAgICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRJbmRleChlbGVtZW50c1JlZiwge1xuICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCxcbiAgICAgICAgICBkaXNhYmxlZEluZGljZXMsXG4gICAgICAgICAgZGVjcmVtZW50OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobG9vcCAmJiBpc0RpZmZlcmVudFJvdyhuZXh0SW5kZXgsIGNvbHMsIHByZXZSb3cpKSB7XG4gICAgICAgICAgbmV4dEluZGV4ID0gZmluZE5vbkRpc2FibGVkSW5kZXgoZWxlbWVudHNSZWYsIHtcbiAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCArIChjb2xzIC0gcHJldkluZGV4ICUgY29scyksXG4gICAgICAgICAgICBkZWNyZW1lbnQ6IHRydWUsXG4gICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsb29wKSB7XG4gICAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGVsZW1lbnRzUmVmLCB7XG4gICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4ICsgKGNvbHMgLSBwcmV2SW5kZXggJSBjb2xzKSxcbiAgICAgICAgICBkZWNyZW1lbnQ6IHRydWUsXG4gICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGlmZmVyZW50Um93KG5leHRJbmRleCwgY29scywgcHJldlJvdykpIHtcbiAgICAgICAgbmV4dEluZGV4ID0gcHJldkluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsYXN0Um93ID0gZmxvb3IobWF4SW5kZXggLyBjb2xzKSA9PT0gcHJldlJvdztcbiAgICBpZiAoaXNJbmRleE91dE9mQm91bmRzKGVsZW1lbnRzUmVmLCBuZXh0SW5kZXgpKSB7XG4gICAgICBpZiAobG9vcCAmJiBsYXN0Um93KSB7XG4gICAgICAgIG5leHRJbmRleCA9IGV2ZW50LmtleSA9PT0gQVJST1dfTEVGVCA/IG1heEluZGV4IDogZmluZE5vbkRpc2FibGVkSW5kZXgoZWxlbWVudHNSZWYsIHtcbiAgICAgICAgICBzdGFydGluZ0luZGV4OiBwcmV2SW5kZXggLSBwcmV2SW5kZXggJSBjb2xzIC0gMSxcbiAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0SW5kZXggPSBwcmV2SW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXh0SW5kZXg7XG59XG5cbmxldCByYWZJZCA9IDA7XG5mdW5jdGlvbiBlbnF1ZXVlRm9jdXMoZWwsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgcHJldmVudFNjcm9sbCA9IGZhbHNlLFxuICAgIGNhbmNlbFByZXZpb3VzID0gdHJ1ZSxcbiAgICBzeW5jID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGNhbmNlbFByZXZpb3VzICYmIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZklkKTtcbiAgY29uc3QgZXhlYyA9ICgpID0+IGVsID09IG51bGwgPyB2b2lkIDAgOiBlbC5mb2N1cyh7XG4gICAgcHJldmVudFNjcm9sbFxuICB9KTtcbiAgaWYgKHN5bmMpIHtcbiAgICBleGVjKCk7XG4gIH0gZWxzZSB7XG4gICAgcmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZXhlYyk7XG4gIH1cbn1cblxudmFyIGluZGV4ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcblxuZnVuY3Rpb24gc29ydEJ5RG9jdW1lbnRQb3NpdGlvbihhLCBiKSB7XG4gIGNvbnN0IHBvc2l0aW9uID0gYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKTtcbiAgaWYgKHBvc2l0aW9uICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkcgfHwgcG9zaXRpb24gJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAocG9zaXRpb24gJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORyB8fCBwb3NpdGlvbiAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTlMpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGFyZU1hcHNFcXVhbChtYXAxLCBtYXAyKSB7XG4gIGlmIChtYXAxLnNpemUgIT09IG1hcDIuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtYXAxLmVudHJpZXMoKSkge1xuICAgIGlmICh2YWx1ZSAhPT0gbWFwMi5nZXQoa2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IEZsb2F0aW5nTGlzdENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gIHJlZ2lzdGVyOiAoKSA9PiB7fSxcbiAgdW5yZWdpc3RlcjogKCkgPT4ge30sXG4gIG1hcDogLyojX19QVVJFX18qL25ldyBNYXAoKSxcbiAgZWxlbWVudHNSZWY6IHtcbiAgICBjdXJyZW50OiBbXVxuICB9XG59KTtcbi8qKlxuICogUHJvdmlkZXMgY29udGV4dCBmb3IgYSBsaXN0IG9mIGl0ZW1zIHdpdGhpbiB0aGUgZmxvYXRpbmcgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ0xpc3RcbiAqL1xuZnVuY3Rpb24gRmxvYXRpbmdMaXN0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBjaGlsZHJlbixcbiAgICBlbGVtZW50c1JlZixcbiAgICBsYWJlbHNSZWZcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IFttYXAsIHNldE1hcF0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBuZXcgTWFwKCkpO1xuICBjb25zdCByZWdpc3RlciA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIHNldE1hcChwcmV2TWFwID0+IG5ldyBNYXAocHJldk1hcCkuc2V0KG5vZGUsIG51bGwpKTtcbiAgfSwgW10pO1xuICBjb25zdCB1bnJlZ2lzdGVyID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgc2V0TWFwKHByZXZNYXAgPT4ge1xuICAgICAgY29uc3QgbWFwID0gbmV3IE1hcChwcmV2TWFwKTtcbiAgICAgIG1hcC5kZWxldGUobm9kZSk7XG4gICAgICByZXR1cm4gbWFwO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBjb25zdCBuZXdNYXAgPSBuZXcgTWFwKG1hcCk7XG4gICAgY29uc3Qgbm9kZXMgPSBBcnJheS5mcm9tKG5ld01hcC5rZXlzKCkpLnNvcnQoc29ydEJ5RG9jdW1lbnRQb3NpdGlvbik7XG4gICAgbm9kZXMuZm9yRWFjaCgobm9kZSwgaW5kZXgpID0+IHtcbiAgICAgIG5ld01hcC5zZXQobm9kZSwgaW5kZXgpO1xuICAgIH0pO1xuICAgIGlmICghYXJlTWFwc0VxdWFsKG1hcCwgbmV3TWFwKSkge1xuICAgICAgc2V0TWFwKG5ld01hcCk7XG4gICAgfVxuICB9LCBbbWFwXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGbG9hdGluZ0xpc3RDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgIHJlZ2lzdGVyLFxuICAgICAgdW5yZWdpc3RlcixcbiAgICAgIG1hcCxcbiAgICAgIGVsZW1lbnRzUmVmLFxuICAgICAgbGFiZWxzUmVmXG4gICAgfSksIFtyZWdpc3RlciwgdW5yZWdpc3RlciwgbWFwLCBlbGVtZW50c1JlZiwgbGFiZWxzUmVmXSlcbiAgfSwgY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gdXNlTGlzdEl0ZW0oX3RlbXApIHtcbiAgbGV0IHtcbiAgICBsYWJlbFxuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gIGNvbnN0IFtpbmRleCQxLCBzZXRJbmRleF0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgY29tcG9uZW50UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCB7XG4gICAgcmVnaXN0ZXIsXG4gICAgdW5yZWdpc3RlcixcbiAgICBtYXAsXG4gICAgZWxlbWVudHNSZWYsXG4gICAgbGFiZWxzUmVmXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KEZsb2F0aW5nTGlzdENvbnRleHQpO1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBjb21wb25lbnRSZWYuY3VycmVudCA9IG5vZGU7XG4gICAgaWYgKGluZGV4JDEgIT09IG51bGwpIHtcbiAgICAgIGVsZW1lbnRzUmVmLmN1cnJlbnRbaW5kZXgkMV0gPSBub2RlO1xuICAgICAgaWYgKGxhYmVsc1JlZikge1xuICAgICAgICB2YXIgX25vZGUkdGV4dENvbnRlbnQ7XG4gICAgICAgIGNvbnN0IGlzTGFiZWxEZWZpbmVkID0gbGFiZWwgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgbGFiZWxzUmVmLmN1cnJlbnRbaW5kZXgkMV0gPSBpc0xhYmVsRGVmaW5lZCA/IGxhYmVsIDogKF9ub2RlJHRleHRDb250ZW50ID0gbm9kZSA9PSBudWxsID8gdm9pZCAwIDogbm9kZS50ZXh0Q29udGVudCkgIT0gbnVsbCA/IF9ub2RlJHRleHRDb250ZW50IDogbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtpbmRleCQxLCBlbGVtZW50c1JlZiwgbGFiZWxzUmVmLCBsYWJlbF0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IGNvbXBvbmVudFJlZi5jdXJyZW50O1xuICAgIGlmIChub2RlKSB7XG4gICAgICByZWdpc3Rlcihub2RlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHVucmVnaXN0ZXIobm9kZSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW3JlZ2lzdGVyLCB1bnJlZ2lzdGVyXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBjb25zdCBpbmRleCA9IGNvbXBvbmVudFJlZi5jdXJyZW50ID8gbWFwLmdldChjb21wb25lbnRSZWYuY3VycmVudCkgOiBudWxsO1xuICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICBzZXRJbmRleChpbmRleCk7XG4gICAgfVxuICB9LCBbbWFwXSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgcmVmLFxuICAgIGluZGV4OiBpbmRleCQxID09IG51bGwgPyAtMSA6IGluZGV4JDFcbiAgfSksIFtpbmRleCQxLCByZWZdKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVySnN4KHJlbmRlciwgY29tcHV0ZWRQcm9wcykge1xuICBpZiAodHlwZW9mIHJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiByZW5kZXIoY29tcHV0ZWRQcm9wcyk7XG4gIH0gZWxzZSBpZiAocmVuZGVyKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQocmVuZGVyLCBjb21wdXRlZFByb3BzKTtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgY29tcHV0ZWRQcm9wcyk7XG59XG5jb25zdCBDb21wb3NpdGVDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICBhY3RpdmVJbmRleDogMCxcbiAgb25OYXZpZ2F0ZTogKCkgPT4ge31cbn0pO1xuY29uc3QgaG9yaXpvbnRhbEtleXMgPSBbQVJST1dfTEVGVCwgQVJST1dfUklHSFRdO1xuY29uc3QgdmVydGljYWxLZXlzID0gW0FSUk9XX1VQLCBBUlJPV19ET1dOXTtcbmNvbnN0IGFsbEtleXMgPSBbLi4uaG9yaXpvbnRhbEtleXMsIC4uLnZlcnRpY2FsS2V5c107XG5jb25zdCBDb21wb3NpdGUgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBDb21wb3NpdGUoX3JlZiwgZm9yd2FyZGVkUmVmKSB7XG4gIGxldCB7XG4gICAgcmVuZGVyLFxuICAgIG9yaWVudGF0aW9uID0gJ2JvdGgnLFxuICAgIGxvb3AgPSB0cnVlLFxuICAgIGNvbHMgPSAxLFxuICAgIGRpc2FibGVkSW5kaWNlcyxcbiAgICBhY3RpdmVJbmRleDogZXh0ZXJuYWxBY3RpdmVJbmRleCxcbiAgICBvbk5hdmlnYXRlOiBleHRlcm5hbFNldEFjdGl2ZUluZGV4LFxuICAgIC4uLnByb3BzXG4gIH0gPSBfcmVmO1xuICBjb25zdCBbaW50ZXJuYWxBY3RpdmVJbmRleCwgaW50ZXJuYWxTZXRBY3RpdmVJbmRleF0gPSBSZWFjdC51c2VTdGF0ZSgwKTtcbiAgY29uc3QgYWN0aXZlSW5kZXggPSBleHRlcm5hbEFjdGl2ZUluZGV4ICE9IG51bGwgPyBleHRlcm5hbEFjdGl2ZUluZGV4IDogaW50ZXJuYWxBY3RpdmVJbmRleDtcbiAgY29uc3Qgb25OYXZpZ2F0ZSA9IHVzZUVmZmVjdEV2ZW50KGV4dGVybmFsU2V0QWN0aXZlSW5kZXggIT0gbnVsbCA/IGV4dGVybmFsU2V0QWN0aXZlSW5kZXggOiBpbnRlcm5hbFNldEFjdGl2ZUluZGV4KTtcbiAgY29uc3QgZWxlbWVudHNSZWYgPSBSZWFjdC51c2VSZWYoW10pO1xuICBjb25zdCByZW5kZXJFbGVtZW50UHJvcHMgPSByZW5kZXIgJiYgdHlwZW9mIHJlbmRlciAhPT0gJ2Z1bmN0aW9uJyA/IHJlbmRlci5wcm9wcyA6IHt9O1xuICBjb25zdCBjb250ZXh0VmFsdWUgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgYWN0aXZlSW5kZXgsXG4gICAgb25OYXZpZ2F0ZVxuICB9KSwgW2FjdGl2ZUluZGV4LCBvbk5hdmlnYXRlXSk7XG4gIGNvbnN0IGlzR3JpZCA9IGNvbHMgPiAxO1xuICBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGV2ZW50KSB7XG4gICAgaWYgKCFhbGxLZXlzLmluY2x1ZGVzKGV2ZW50LmtleSkpIHJldHVybjtcbiAgICBjb25zdCBtaW5JbmRleCA9IGdldE1pbkluZGV4KGVsZW1lbnRzUmVmLCBkaXNhYmxlZEluZGljZXMpO1xuICAgIGNvbnN0IG1heEluZGV4ID0gZ2V0TWF4SW5kZXgoZWxlbWVudHNSZWYsIGRpc2FibGVkSW5kaWNlcyk7XG4gICAgY29uc3QgcHJldkluZGV4ID0gYWN0aXZlSW5kZXg7XG4gICAgbGV0IG5leHRJbmRleCA9IGFjdGl2ZUluZGV4O1xuICAgIGlmIChpc0dyaWQpIHtcbiAgICAgIG5leHRJbmRleCA9IGdldEdyaWROYXZpZ2F0ZWRJbmRleChlbGVtZW50c1JlZiwge1xuICAgICAgICBldmVudCxcbiAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgIGxvb3AsXG4gICAgICAgIGNvbHMsXG4gICAgICAgIGRpc2FibGVkSW5kaWNlcyxcbiAgICAgICAgbWluSW5kZXgsXG4gICAgICAgIG1heEluZGV4LFxuICAgICAgICBwcmV2SW5kZXhcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCB0b0VuZEtleXMgPSB7XG4gICAgICBob3Jpem9udGFsOiBbQVJST1dfUklHSFRdLFxuICAgICAgdmVydGljYWw6IFtBUlJPV19ET1dOXSxcbiAgICAgIGJvdGg6IFtBUlJPV19SSUdIVCwgQVJST1dfRE9XTl1cbiAgICB9W29yaWVudGF0aW9uXTtcbiAgICBjb25zdCB0b1N0YXJ0S2V5cyA9IHtcbiAgICAgIGhvcml6b250YWw6IFtBUlJPV19MRUZUXSxcbiAgICAgIHZlcnRpY2FsOiBbQVJST1dfVVBdLFxuICAgICAgYm90aDogW0FSUk9XX0xFRlQsIEFSUk9XX1VQXVxuICAgIH1bb3JpZW50YXRpb25dO1xuICAgIGNvbnN0IHByZXZlbnRlZEtleXMgPSBpc0dyaWQgPyBhbGxLZXlzIDoge1xuICAgICAgaG9yaXpvbnRhbDogaG9yaXpvbnRhbEtleXMsXG4gICAgICB2ZXJ0aWNhbDogdmVydGljYWxLZXlzLFxuICAgICAgYm90aDogYWxsS2V5c1xuICAgIH1bb3JpZW50YXRpb25dO1xuICAgIGlmIChuZXh0SW5kZXggPT09IGFjdGl2ZUluZGV4ICYmIFsuLi50b0VuZEtleXMsIC4uLnRvU3RhcnRLZXlzXS5pbmNsdWRlcyhldmVudC5rZXkpKSB7XG4gICAgICBpZiAobG9vcCAmJiBuZXh0SW5kZXggPT09IG1heEluZGV4ICYmIHRvRW5kS2V5cy5pbmNsdWRlcyhldmVudC5rZXkpKSB7XG4gICAgICAgIG5leHRJbmRleCA9IG1pbkluZGV4O1xuICAgICAgfSBlbHNlIGlmIChsb29wICYmIG5leHRJbmRleCA9PT0gbWluSW5kZXggJiYgdG9TdGFydEtleXMuaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgICAgICBuZXh0SW5kZXggPSBtYXhJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZEluZGV4KGVsZW1lbnRzUmVmLCB7XG4gICAgICAgICAgc3RhcnRpbmdJbmRleDogbmV4dEluZGV4LFxuICAgICAgICAgIGRlY3JlbWVudDogdG9TdGFydEtleXMuaW5jbHVkZXMoZXZlbnQua2V5KSxcbiAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZXh0SW5kZXggIT09IGFjdGl2ZUluZGV4ICYmICFpc0luZGV4T3V0T2ZCb3VuZHMoZWxlbWVudHNSZWYsIG5leHRJbmRleCkpIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgaWYgKHByZXZlbnRlZEtleXMuaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgb25OYXZpZ2F0ZShuZXh0SW5kZXgpO1xuXG4gICAgICAvLyBXYWl0IGZvciBGb2N1c01hbmFnZXIgYHJldHVybkZvY3VzYCB0byBleGVjdXRlLlxuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICBlbnF1ZXVlRm9jdXMoZWxlbWVudHNSZWYuY3VycmVudFtuZXh0SW5kZXhdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb25zdCBjb21wdXRlZFByb3BzID0ge1xuICAgIC4uLnByb3BzLFxuICAgIC4uLnJlbmRlckVsZW1lbnRQcm9wcyxcbiAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICAnYXJpYS1vcmllbnRhdGlvbic6IG9yaWVudGF0aW9uID09PSAnYm90aCcgPyB1bmRlZmluZWQgOiBvcmllbnRhdGlvbixcbiAgICBvbktleURvd24oZSkge1xuICAgICAgcHJvcHMub25LZXlEb3duID09IG51bGwgfHwgcHJvcHMub25LZXlEb3duKGUpO1xuICAgICAgcmVuZGVyRWxlbWVudFByb3BzLm9uS2V5RG93biA9PSBudWxsIHx8IHJlbmRlckVsZW1lbnRQcm9wcy5vbktleURvd24oZSk7XG4gICAgICBoYW5kbGVLZXlEb3duKGUpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvc2l0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFZhbHVlXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZsb2F0aW5nTGlzdCwge1xuICAgIGVsZW1lbnRzUmVmOiBlbGVtZW50c1JlZlxuICB9LCByZW5kZXJKc3gocmVuZGVyLCBjb21wdXRlZFByb3BzKSkpO1xufSk7XG5jb25zdCBDb21wb3NpdGVJdGVtID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gQ29tcG9zaXRlSXRlbShfcmVmMiwgZm9yd2FyZGVkUmVmKSB7XG4gIGxldCB7XG4gICAgcmVuZGVyLFxuICAgIC4uLnByb3BzXG4gIH0gPSBfcmVmMjtcbiAgY29uc3QgcmVuZGVyRWxlbWVudFByb3BzID0gcmVuZGVyICYmIHR5cGVvZiByZW5kZXIgIT09ICdmdW5jdGlvbicgPyByZW5kZXIucHJvcHMgOiB7fTtcbiAgY29uc3Qge1xuICAgIGFjdGl2ZUluZGV4LFxuICAgIG9uTmF2aWdhdGVcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoQ29tcG9zaXRlQ29udGV4dCk7XG4gIGNvbnN0IHtcbiAgICByZWYsXG4gICAgaW5kZXhcbiAgfSA9IHVzZUxpc3RJdGVtKCk7XG4gIGNvbnN0IG1lcmdlZFJlZiA9IHVzZU1lcmdlUmVmcyhbcmVmLCBmb3J3YXJkZWRSZWYsIHJlbmRlckVsZW1lbnRQcm9wcy5yZWZdKTtcbiAgY29uc3QgaXNBY3RpdmUgPSBhY3RpdmVJbmRleCA9PT0gaW5kZXg7XG4gIGNvbnN0IGNvbXB1dGVkUHJvcHMgPSB7XG4gICAgLi4ucHJvcHMsXG4gICAgLi4ucmVuZGVyRWxlbWVudFByb3BzLFxuICAgIHJlZjogbWVyZ2VkUmVmLFxuICAgIHRhYkluZGV4OiBpc0FjdGl2ZSA/IDAgOiAtMSxcbiAgICAnZGF0YS1hY3RpdmUnOiBpc0FjdGl2ZSA/ICcnIDogdW5kZWZpbmVkLFxuICAgIG9uRm9jdXMoZSkge1xuICAgICAgcHJvcHMub25Gb2N1cyA9PSBudWxsIHx8IHByb3BzLm9uRm9jdXMoZSk7XG4gICAgICByZW5kZXJFbGVtZW50UHJvcHMub25Gb2N1cyA9PSBudWxsIHx8IHJlbmRlckVsZW1lbnRQcm9wcy5vbkZvY3VzKGUpO1xuICAgICAgb25OYXZpZ2F0ZShpbmRleCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gcmVuZGVySnN4KHJlbmRlciwgY29tcHV0ZWRQcm9wcyk7XG59KTtcblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmxldCBzZXJ2ZXJIYW5kb2ZmQ29tcGxldGUgPSBmYWxzZTtcbmxldCBjb3VudCA9IDA7XG5jb25zdCBnZW5JZCA9ICgpID0+IFwiZmxvYXRpbmctdWktXCIgKyBjb3VudCsrO1xuZnVuY3Rpb24gdXNlRmxvYXRpbmdJZCgpIHtcbiAgY29uc3QgW2lkLCBzZXRJZF0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBzZXJ2ZXJIYW5kb2ZmQ29tcGxldGUgPyBnZW5JZCgpIDogdW5kZWZpbmVkKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChpZCA9PSBudWxsKSB7XG4gICAgICBzZXRJZChnZW5JZCgpKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFzZXJ2ZXJIYW5kb2ZmQ29tcGxldGUpIHtcbiAgICAgIHNlcnZlckhhbmRvZmZDb21wbGV0ZSA9IHRydWU7XG4gICAgfVxuICB9LCBbXSk7XG4gIHJldHVybiBpZDtcbn1cblxuLy8gYHRvU3RyaW5nKClgIHByZXZlbnRzIGJ1bmRsZXJzIGZyb20gdHJ5aW5nIHRvIGBpbXBvcnQgeyB1c2VJZCB9IGZyb20gJ3JlYWN0J2BcbmNvbnN0IHVzZVJlYWN0SWQgPSBSZWFjdFsvKiNfX1BVUkVfXyovJ3VzZUlkJy50b1N0cmluZygpXTtcblxuLyoqXG4gKiBVc2VzIFJlYWN0IDE4J3MgYnVpbHQtaW4gYHVzZUlkKClgIHdoZW4gYXZhaWxhYmxlLCBvciBmYWxscyBiYWNrIHRvIGFcbiAqIHNsaWdodGx5IGxlc3MgcGVyZm9ybWFudCAocmVxdWlyaW5nIGEgZG91YmxlIHJlbmRlcikgaW1wbGVtZW50YXRpb24gZm9yXG4gKiBlYXJsaWVyIFJlYWN0IHZlcnNpb25zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZUlkXG4gKi9cbmNvbnN0IHVzZUlkID0gdXNlUmVhY3RJZCB8fCB1c2VGbG9hdGluZ0lkO1xuXG4vKipcbiAqIFJlbmRlcnMgYSBwb2ludGluZyBhcnJvdyB0cmlhbmdsZS5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ0Fycm93XG4gKi9cbmNvbnN0IEZsb2F0aW5nQXJyb3cgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBGbG9hdGluZ0Fycm93KF9yZWYsIHJlZikge1xuICBsZXQge1xuICAgIGNvbnRleHQ6IHtcbiAgICAgIHBsYWNlbWVudCxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIGZsb2F0aW5nXG4gICAgICB9LFxuICAgICAgbWlkZGxld2FyZURhdGE6IHtcbiAgICAgICAgYXJyb3dcbiAgICAgIH1cbiAgICB9LFxuICAgIHdpZHRoID0gMTQsXG4gICAgaGVpZ2h0ID0gNyxcbiAgICB0aXBSYWRpdXMgPSAwLFxuICAgIHN0cm9rZVdpZHRoID0gMCxcbiAgICBzdGF0aWNPZmZzZXQsXG4gICAgc3Ryb2tlLFxuICAgIGQsXG4gICAgc3R5bGU6IHtcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIC4uLnJlc3RTdHlsZVxuICAgIH0gPSB7fSxcbiAgICAuLi5yZXN0XG4gIH0gPSBfcmVmO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKCFyZWYpIHtcbiAgICAgIGNvbnNvbGUud2FybignRmxvYXRpbmcgVUk6IFRoZSBgcmVmYCBwcm9wIGlzIHJlcXVpcmVkIGZvciB0aGUgYEZsb2F0aW5nQXJyb3dgJywgJ2NvbXBvbmVudC4nKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgY2xpcFBhdGhJZCA9IHVzZUlkKCk7XG4gIGlmICghZmxvYXRpbmcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIFN0cm9rZXMgbXVzdCBiZSBkb3VibGUgdGhlIGJvcmRlciB3aWR0aCwgdGhpcyBlbnN1cmVzIHRoZSBzdHJva2UncyB3aWR0aFxuICAvLyB3b3JrcyBhcyB5b3UnZCBleHBlY3QuXG4gIHN0cm9rZVdpZHRoICo9IDI7XG4gIGNvbnN0IGhhbGZTdHJva2VXaWR0aCA9IHN0cm9rZVdpZHRoIC8gMjtcbiAgY29uc3Qgc3ZnWCA9IHdpZHRoIC8gMiAqICh0aXBSYWRpdXMgLyAtOCArIDEpO1xuICBjb25zdCBzdmdZID0gaGVpZ2h0IC8gMiAqIHRpcFJhZGl1cyAvIDQ7XG4gIGNvbnN0IFtzaWRlLCBhbGlnbm1lbnRdID0gcGxhY2VtZW50LnNwbGl0KCctJyk7XG4gIGNvbnN0IGlzUlRMID0gcGxhdGZvcm0uaXNSVEwoZmxvYXRpbmcpO1xuICBjb25zdCBpc0N1c3RvbVNoYXBlID0gISFkO1xuICBjb25zdCBpc1ZlcnRpY2FsU2lkZSA9IHNpZGUgPT09ICd0b3AnIHx8IHNpZGUgPT09ICdib3R0b20nO1xuICBjb25zdCB5T2Zmc2V0UHJvcCA9IHN0YXRpY09mZnNldCAmJiBhbGlnbm1lbnQgPT09ICdlbmQnID8gJ2JvdHRvbScgOiAndG9wJztcbiAgbGV0IHhPZmZzZXRQcm9wID0gc3RhdGljT2Zmc2V0ICYmIGFsaWdubWVudCA9PT0gJ2VuZCcgPyAncmlnaHQnIDogJ2xlZnQnO1xuICBpZiAoc3RhdGljT2Zmc2V0ICYmIGlzUlRMKSB7XG4gICAgeE9mZnNldFByb3AgPSBhbGlnbm1lbnQgPT09ICdlbmQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgfVxuICBjb25zdCBhcnJvd1ggPSAoYXJyb3cgPT0gbnVsbCA/IHZvaWQgMCA6IGFycm93LngpICE9IG51bGwgPyBzdGF0aWNPZmZzZXQgfHwgYXJyb3cueCA6ICcnO1xuICBjb25zdCBhcnJvd1kgPSAoYXJyb3cgPT0gbnVsbCA/IHZvaWQgMCA6IGFycm93LnkpICE9IG51bGwgPyBzdGF0aWNPZmZzZXQgfHwgYXJyb3cueSA6ICcnO1xuICBjb25zdCBkVmFsdWUgPSBkIHx8ICdNMCwwJyArIChcIiBIXCIgKyB3aWR0aCkgKyAoXCIgTFwiICsgKHdpZHRoIC0gc3ZnWCkgKyBcIixcIiArIChoZWlnaHQgLSBzdmdZKSkgKyAoXCIgUVwiICsgd2lkdGggLyAyICsgXCIsXCIgKyBoZWlnaHQgKyBcIiBcIiArIHN2Z1ggKyBcIixcIiArIChoZWlnaHQgLSBzdmdZKSkgKyAnIFonO1xuICBjb25zdCByb3RhdGlvbiA9IHtcbiAgICB0b3A6IGlzQ3VzdG9tU2hhcGUgPyAncm90YXRlKDE4MGRlZyknIDogJycsXG4gICAgbGVmdDogaXNDdXN0b21TaGFwZSA/ICdyb3RhdGUoOTBkZWcpJyA6ICdyb3RhdGUoLTkwZGVnKScsXG4gICAgYm90dG9tOiBpc0N1c3RvbVNoYXBlID8gJycgOiAncm90YXRlKDE4MGRlZyknLFxuICAgIHJpZ2h0OiBpc0N1c3RvbVNoYXBlID8gJ3JvdGF0ZSgtOTBkZWcpJyA6ICdyb3RhdGUoOTBkZWcpJ1xuICB9W3NpZGVdO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICBcImFyaWEtaGlkZGVuXCI6IHRydWUsXG4gICAgcmVmOiByZWYsXG4gICAgd2lkdGg6IGlzQ3VzdG9tU2hhcGUgPyB3aWR0aCA6IHdpZHRoICsgc3Ryb2tlV2lkdGgsXG4gICAgaGVpZ2h0OiB3aWR0aCxcbiAgICB2aWV3Qm94OiBcIjAgMCBcIiArIHdpZHRoICsgXCIgXCIgKyAoaGVpZ2h0ID4gd2lkdGggPyBoZWlnaHQgOiB3aWR0aCksXG4gICAgc3R5bGU6IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgW3hPZmZzZXRQcm9wXTogYXJyb3dYLFxuICAgICAgW3lPZmZzZXRQcm9wXTogYXJyb3dZLFxuICAgICAgW3NpZGVdOiBpc1ZlcnRpY2FsU2lkZSB8fCBpc0N1c3RvbVNoYXBlID8gJzEwMCUnIDogXCJjYWxjKDEwMCUgLSBcIiArIHN0cm9rZVdpZHRoIC8gMiArIFwicHgpXCIsXG4gICAgICB0cmFuc2Zvcm06IFwiXCIgKyByb3RhdGlvbiArICh0cmFuc2Zvcm0gIT0gbnVsbCA/IHRyYW5zZm9ybSA6ICcnKSxcbiAgICAgIC4uLnJlc3RTdHlsZVxuICAgIH1cbiAgfSksIHN0cm9rZVdpZHRoID4gMCAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGNsaXBQYXRoOiBcInVybCgjXCIgKyBjbGlwUGF0aElkICsgXCIpXCIsXG4gICAgZmlsbDogXCJub25lXCIsXG4gICAgc3Ryb2tlOiBzdHJva2VcbiAgICAvLyBBY2NvdW50IGZvciB0aGUgc3Ryb2tlIG9uIHRoZSBmaWxsIHBhdGggcmVuZGVyZWQgYmVsb3cuXG4gICAgLFxuICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCArIChkID8gMCA6IDEpLFxuICAgIGQ6IGRWYWx1ZVxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBzdHJva2U6IHN0cm9rZVdpZHRoICYmICFkID8gcmVzdC5maWxsIDogJ25vbmUnLFxuICAgIGQ6IGRWYWx1ZVxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjbGlwUGF0aFwiLCB7XG4gICAgaWQ6IGNsaXBQYXRoSWRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIsIHtcbiAgICB4OiAtaGFsZlN0cm9rZVdpZHRoLFxuICAgIHk6IGhhbGZTdHJva2VXaWR0aCAqIChpc0N1c3RvbVNoYXBlID8gLTEgOiAxKSxcbiAgICB3aWR0aDogd2lkdGggKyBzdHJva2VXaWR0aCxcbiAgICBoZWlnaHQ6IHdpZHRoXG4gIH0pKSk7XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlUHViU3ViKCkge1xuICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gIHJldHVybiB7XG4gICAgZW1pdChldmVudCwgZGF0YSkge1xuICAgICAgdmFyIF9tYXAkZ2V0O1xuICAgICAgKF9tYXAkZ2V0ID0gbWFwLmdldChldmVudCkpID09IG51bGwgfHwgX21hcCRnZXQuZm9yRWFjaChoYW5kbGVyID0+IGhhbmRsZXIoZGF0YSkpO1xuICAgIH0sXG4gICAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICBtYXAuc2V0KGV2ZW50LCBbLi4uKG1hcC5nZXQoZXZlbnQpIHx8IFtdKSwgbGlzdGVuZXJdKTtcbiAgICB9LFxuICAgIG9mZihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBfbWFwJGdldDI7XG4gICAgICBtYXAuc2V0KGV2ZW50LCAoKF9tYXAkZ2V0MiA9IG1hcC5nZXQoZXZlbnQpKSA9PSBudWxsID8gdm9pZCAwIDogX21hcCRnZXQyLmZpbHRlcihsID0+IGwgIT09IGxpc3RlbmVyKSkgfHwgW10pO1xuICAgIH1cbiAgfTtcbn1cblxuY29uc3QgRmxvYXRpbmdOb2RlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgRmxvYXRpbmdUcmVlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgdXNlRmxvYXRpbmdQYXJlbnROb2RlSWQgPSAoKSA9PiB7XG4gIHZhciBfUmVhY3QkdXNlQ29udGV4dDtcbiAgcmV0dXJuICgoX1JlYWN0JHVzZUNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KEZsb2F0aW5nTm9kZUNvbnRleHQpKSA9PSBudWxsID8gdm9pZCAwIDogX1JlYWN0JHVzZUNvbnRleHQuaWQpIHx8IG51bGw7XG59O1xuY29uc3QgdXNlRmxvYXRpbmdUcmVlID0gKCkgPT4gUmVhY3QudXNlQ29udGV4dChGbG9hdGluZ1RyZWVDb250ZXh0KTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBub2RlIGludG8gdGhlIGZsb2F0aW5nIHRyZWUsIHJldHVybmluZyBpdHMgaWQuXG4gKi9cbmZ1bmN0aW9uIHVzZUZsb2F0aW5nTm9kZUlkKGN1c3RvbVBhcmVudElkKSB7XG4gIGNvbnN0IGlkID0gdXNlSWQoKTtcbiAgY29uc3QgdHJlZSA9IHVzZUZsb2F0aW5nVHJlZSgpO1xuICBjb25zdCByZWFjdFBhcmVudElkID0gdXNlRmxvYXRpbmdQYXJlbnROb2RlSWQoKTtcbiAgY29uc3QgcGFyZW50SWQgPSBjdXN0b21QYXJlbnRJZCB8fCByZWFjdFBhcmVudElkO1xuICBpbmRleCgoKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIGlkLFxuICAgICAgcGFyZW50SWRcbiAgICB9O1xuICAgIHRyZWUgPT0gbnVsbCB8fCB0cmVlLmFkZE5vZGUobm9kZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRyZWUgPT0gbnVsbCB8fCB0cmVlLnJlbW92ZU5vZGUobm9kZSk7XG4gICAgfTtcbiAgfSwgW3RyZWUsIGlkLCBwYXJlbnRJZF0pO1xuICByZXR1cm4gaWQ7XG59XG5cbi8qKlxuICogUHJvdmlkZXMgcGFyZW50IG5vZGUgY29udGV4dCBmb3IgbmVzdGVkIGZsb2F0aW5nIGVsZW1lbnRzLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nVHJlZVxuICovXG5mdW5jdGlvbiBGbG9hdGluZ05vZGUoX3JlZikge1xuICBsZXQge1xuICAgIGNoaWxkcmVuLFxuICAgIGlkXG4gIH0gPSBfcmVmO1xuICBjb25zdCBwYXJlbnRJZCA9IHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkKCk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGbG9hdGluZ05vZGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgIGlkLFxuICAgICAgcGFyZW50SWRcbiAgICB9KSwgW2lkLCBwYXJlbnRJZF0pXG4gIH0sIGNoaWxkcmVuKTtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBjb250ZXh0IGZvciBuZXN0ZWQgZmxvYXRpbmcgZWxlbWVudHMgd2hlbiB0aGV5IGFyZSBub3QgY2hpbGRyZW4gb2ZcbiAqIGVhY2ggb3RoZXIgb24gdGhlIERPTSAoaS5lLiBwb3J0YWxsZWQgdG8gYSBjb21tb24gbm9kZSwgcmF0aGVyIHRoYW4gdGhlaXJcbiAqIHJlc3BlY3RpdmUgcGFyZW50KS5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ1RyZWVcbiAqL1xuZnVuY3Rpb24gRmxvYXRpbmdUcmVlKF9yZWYyKSB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW5cbiAgfSA9IF9yZWYyO1xuICBjb25zdCBub2Rlc1JlZiA9IFJlYWN0LnVzZVJlZihbXSk7XG4gIGNvbnN0IGFkZE5vZGUgPSBSZWFjdC51c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBub2Rlc1JlZi5jdXJyZW50ID0gWy4uLm5vZGVzUmVmLmN1cnJlbnQsIG5vZGVdO1xuICB9LCBbXSk7XG4gIGNvbnN0IHJlbW92ZU5vZGUgPSBSZWFjdC51c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBub2Rlc1JlZi5jdXJyZW50ID0gbm9kZXNSZWYuY3VycmVudC5maWx0ZXIobiA9PiBuICE9PSBub2RlKTtcbiAgfSwgW10pO1xuICBjb25zdCBldmVudHMgPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBjcmVhdGVQdWJTdWIoKSlbMF07XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGbG9hdGluZ1RyZWVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgIG5vZGVzUmVmLFxuICAgICAgYWRkTm9kZSxcbiAgICAgIHJlbW92ZU5vZGUsXG4gICAgICBldmVudHNcbiAgICB9KSwgW25vZGVzUmVmLCBhZGROb2RlLCByZW1vdmVOb2RlLCBldmVudHNdKVxuICB9LCBjaGlsZHJlbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUF0dHJpYnV0ZShuYW1lKSB7XG4gIHJldHVybiBcImRhdGEtZmxvYXRpbmctdWktXCIgKyBuYW1lO1xufVxuXG5mdW5jdGlvbiB1c2VMYXRlc3RSZWYodmFsdWUpIHtcbiAgY29uc3QgcmVmID0gdXNlUmVmKHZhbHVlKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVmO1xufVxuXG5jb25zdCBzYWZlUG9seWdvbklkZW50aWZpZXIgPSAvKiNfX1BVUkVfXyovY3JlYXRlQXR0cmlidXRlKCdzYWZlLXBvbHlnb24nKTtcbmZ1bmN0aW9uIGdldERlbGF5KHZhbHVlLCBwcm9wLCBwb2ludGVyVHlwZSkge1xuICBpZiAocG9pbnRlclR5cGUgJiYgIWlzTW91c2VMaWtlUG9pbnRlclR5cGUocG9pbnRlclR5cGUpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyB2b2lkIDAgOiB2YWx1ZVtwcm9wXTtcbn1cbi8qKlxuICogT3BlbnMgdGhlIGZsb2F0aW5nIGVsZW1lbnQgd2hpbGUgaG92ZXJpbmcgb3ZlciB0aGUgcmVmZXJlbmNlIGVsZW1lbnQsIGxpa2VcbiAqIENTUyBgOmhvdmVyYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VIb3ZlclxuICovXG5mdW5jdGlvbiB1c2VIb3Zlcihjb250ZXh0LCBwcm9wcykge1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgb25PcGVuQ2hhbmdlLFxuICAgIGRhdGFSZWYsXG4gICAgZXZlbnRzLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICBkb21SZWZlcmVuY2UsXG4gICAgICBmbG9hdGluZ1xuICAgIH0sXG4gICAgcmVmc1xuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIGRlbGF5ID0gMCxcbiAgICBoYW5kbGVDbG9zZSA9IG51bGwsXG4gICAgbW91c2VPbmx5ID0gZmFsc2UsXG4gICAgcmVzdE1zID0gMCxcbiAgICBtb3ZlID0gdHJ1ZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHRyZWUgPSB1c2VGbG9hdGluZ1RyZWUoKTtcbiAgY29uc3QgcGFyZW50SWQgPSB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCgpO1xuICBjb25zdCBoYW5kbGVDbG9zZVJlZiA9IHVzZUxhdGVzdFJlZihoYW5kbGVDbG9zZSk7XG4gIGNvbnN0IGRlbGF5UmVmID0gdXNlTGF0ZXN0UmVmKGRlbGF5KTtcbiAgY29uc3QgcG9pbnRlclR5cGVSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgY29uc3QgdGltZW91dFJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCBoYW5kbGVyUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGNvbnN0IHJlc3RUaW1lb3V0UmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGNvbnN0IGJsb2NrTW91c2VNb3ZlUmVmID0gUmVhY3QudXNlUmVmKHRydWUpO1xuICBjb25zdCBwZXJmb3JtZWRQb2ludGVyRXZlbnRzTXV0YXRpb25SZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCB1bmJpbmRNb3VzZU1vdmVSZWYgPSBSZWFjdC51c2VSZWYoKCkgPT4ge30pO1xuICBjb25zdCBpc0hvdmVyT3BlbiA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICB2YXIgX2RhdGFSZWYkY3VycmVudCRvcGVuO1xuICAgIGNvbnN0IHR5cGUgPSAoX2RhdGFSZWYkY3VycmVudCRvcGVuID0gZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhUmVmJGN1cnJlbnQkb3Blbi50eXBlO1xuICAgIHJldHVybiAodHlwZSA9PSBudWxsID8gdm9pZCAwIDogdHlwZS5pbmNsdWRlcygnbW91c2UnKSkgJiYgdHlwZSAhPT0gJ21vdXNlZG93bic7XG4gIH0sIFtkYXRhUmVmXSk7XG5cbiAgLy8gV2hlbiBjbG9zaW5nIGJlZm9yZSBvcGVuaW5nLCBjbGVhciB0aGUgZGVsYXkgdGltZW91dHMgdG8gY2FuY2VsIGl0XG4gIC8vIGZyb20gc2hvd2luZy5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25PcGVuQ2hhbmdlKF9yZWYpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIG9wZW5cbiAgICAgIH0gPSBfcmVmO1xuICAgICAgaWYgKCFvcGVuKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgICBjbGVhclRpbWVvdXQocmVzdFRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICAgIGJsb2NrTW91c2VNb3ZlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBldmVudHMub24oJ29wZW5jaGFuZ2UnLCBvbk9wZW5DaGFuZ2UpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBldmVudHMub2ZmKCdvcGVuY2hhbmdlJywgb25PcGVuQ2hhbmdlKTtcbiAgICB9O1xuICB9LCBbZW5hYmxlZCwgZXZlbnRzXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkIHx8ICFoYW5kbGVDbG9zZVJlZi5jdXJyZW50IHx8ICFvcGVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTGVhdmUoZXZlbnQpIHtcbiAgICAgIGlmIChpc0hvdmVyT3BlbigpKSB7XG4gICAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQsICdob3ZlcicpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBodG1sID0gZ2V0RG9jdW1lbnQoZmxvYXRpbmcpLmRvY3VtZW50RWxlbWVudDtcbiAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvbkxlYXZlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaHRtbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25MZWF2ZSk7XG4gICAgfTtcbiAgfSwgW2Zsb2F0aW5nLCBvcGVuLCBvbk9wZW5DaGFuZ2UsIGVuYWJsZWQsIGhhbmRsZUNsb3NlUmVmLCBkYXRhUmVmLCBpc0hvdmVyT3Blbl0pO1xuICBjb25zdCBjbG9zZVdpdGhEZWxheSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChldmVudCwgcnVuRWxzZUJyYW5jaCwgcmVhc29uKSB7XG4gICAgaWYgKHJ1bkVsc2VCcmFuY2ggPT09IHZvaWQgMCkge1xuICAgICAgcnVuRWxzZUJyYW5jaCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChyZWFzb24gPT09IHZvaWQgMCkge1xuICAgICAgcmVhc29uID0gJ2hvdmVyJztcbiAgICB9XG4gICAgY29uc3QgY2xvc2VEZWxheSA9IGdldERlbGF5KGRlbGF5UmVmLmN1cnJlbnQsICdjbG9zZScsIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQpO1xuICAgIGlmIChjbG9zZURlbGF5ICYmICFoYW5kbGVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgdGltZW91dFJlZi5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50LCByZWFzb24pLCBjbG9zZURlbGF5KTtcbiAgICB9IGVsc2UgaWYgKHJ1bkVsc2VCcmFuY2gpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudCwgcmVhc29uKTtcbiAgICB9XG4gIH0sIFtkZWxheVJlZiwgb25PcGVuQ2hhbmdlXSk7XG4gIGNvbnN0IGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHVuYmluZE1vdXNlTW92ZVJlZi5jdXJyZW50KCk7XG4gICAgaGFuZGxlclJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICB9LCBbXSk7XG4gIGNvbnN0IGNsZWFyUG9pbnRlckV2ZW50cyA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAocGVyZm9ybWVkUG9pbnRlckV2ZW50c011dGF0aW9uUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbnN0IGJvZHkgPSBnZXREb2N1bWVudChyZWZzLmZsb2F0aW5nLmN1cnJlbnQpLmJvZHk7XG4gICAgICBib2R5LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgICAgIGJvZHkucmVtb3ZlQXR0cmlidXRlKHNhZmVQb2x5Z29uSWRlbnRpZmllcik7XG4gICAgICBwZXJmb3JtZWRQb2ludGVyRXZlbnRzTXV0YXRpb25SZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIH1cbiAgfSwgW3JlZnNdKTtcblxuICAvLyBSZWdpc3RlcmluZyB0aGUgbW91c2UgZXZlbnRzIG9uIHRoZSByZWZlcmVuY2UgZGlyZWN0bHkgdG8gYnlwYXNzIFJlYWN0J3NcbiAgLy8gZGVsZWdhdGlvbiBzeXN0ZW0uIElmIHRoZSBjdXJzb3Igd2FzIG9uIGEgZGlzYWJsZWQgZWxlbWVudCBhbmQgdGhlbiBlbnRlcmVkXG4gIC8vIHRoZSByZWZlcmVuY2UgKG5vIGdhcCksIGBtb3VzZWVudGVyYCBkb2Vzbid0IGZpcmUgaW4gdGhlIGRlbGVnYXRpb24gc3lzdGVtLlxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0NsaWNrTGlrZU9wZW5FdmVudCgpIHtcbiAgICAgIHJldHVybiBkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50ID8gWydjbGljaycsICdtb3VzZWRvd24nXS5pbmNsdWRlcyhkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50LnR5cGUpIDogZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VFbnRlcihldmVudCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICBibG9ja01vdXNlTW92ZVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBpZiAobW91c2VPbmx5ICYmICFpc01vdXNlTGlrZVBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQpIHx8IHJlc3RNcyA+IDAgJiYgZ2V0RGVsYXkoZGVsYXlSZWYuY3VycmVudCwgJ29wZW4nKSA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBvcGVuRGVsYXkgPSBnZXREZWxheShkZWxheVJlZi5jdXJyZW50LCAnb3BlbicsIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQpO1xuICAgICAgaWYgKG9wZW5EZWxheSkge1xuICAgICAgICB0aW1lb3V0UmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSwgZXZlbnQsICdob3ZlcicpO1xuICAgICAgICB9LCBvcGVuRGVsYXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50LCAnaG92ZXInKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25Nb3VzZUxlYXZlKGV2ZW50KSB7XG4gICAgICBpZiAoaXNDbGlja0xpa2VPcGVuRXZlbnQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB1bmJpbmRNb3VzZU1vdmVSZWYuY3VycmVudCgpO1xuICAgICAgY29uc3QgZG9jID0gZ2V0RG9jdW1lbnQoZmxvYXRpbmcpO1xuICAgICAgY2xlYXJUaW1lb3V0KHJlc3RUaW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgaWYgKGhhbmRsZUNsb3NlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgLy8gUHJldmVudCBjbGVhcmluZyBgb25TY3JvbGxNb3VzZUxlYXZlYCB0aW1lb3V0LlxuICAgICAgICBpZiAoIW9wZW4pIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVyUmVmLmN1cnJlbnQgPSBoYW5kbGVDbG9zZVJlZi5jdXJyZW50KHtcbiAgICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICAgIHRyZWUsXG4gICAgICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgICAgICB5OiBldmVudC5jbGllbnRZLFxuICAgICAgICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgICAgICBjbGVhclBvaW50ZXJFdmVudHMoKTtcbiAgICAgICAgICAgIGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyKCk7XG4gICAgICAgICAgICBjbG9zZVdpdGhEZWxheShldmVudCwgdHJ1ZSwgJ3NhZmUtcG9seWdvbicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyUmVmLmN1cnJlbnQ7XG4gICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVyKTtcbiAgICAgICAgdW5iaW5kTW91c2VNb3ZlUmVmLmN1cnJlbnQgPSAoKSA9PiB7XG4gICAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEFsbG93IGludGVyYWN0aXZpdHkgd2l0aG91dCBgc2FmZVBvbHlnb25gIG9uIHRvdWNoIGRldmljZXMuIFdpdGggYVxuICAgICAgLy8gcG9pbnRlciwgYSBzaG9ydCBjbG9zZSBkZWxheSBpcyBhbiBhbHRlcm5hdGl2ZSwgc28gaXQgc2hvdWxkIHdvcmtcbiAgICAgIC8vIGNvbnNpc3RlbnRseS5cbiAgICAgIGNvbnN0IHNob3VsZENsb3NlID0gcG9pbnRlclR5cGVSZWYuY3VycmVudCA9PT0gJ3RvdWNoJyA/ICFjb250YWlucyhmbG9hdGluZywgZXZlbnQucmVsYXRlZFRhcmdldCkgOiB0cnVlO1xuICAgICAgaWYgKHNob3VsZENsb3NlKSB7XG4gICAgICAgIGNsb3NlV2l0aERlbGF5KGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgY2xvc2VzIGFmdGVyIHNjcm9sbGluZyBldmVuIGlmIHRoZSBwb2ludGVyXG4gICAgLy8gZGlkIG5vdCBtb3ZlLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9kaXNjdXNzaW9ucy8xNjkyXG4gICAgZnVuY3Rpb24gb25TY3JvbGxNb3VzZUxlYXZlKGV2ZW50KSB7XG4gICAgICBpZiAoaXNDbGlja0xpa2VPcGVuRXZlbnQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBoYW5kbGVDbG9zZVJlZi5jdXJyZW50ID09IG51bGwgfHwgaGFuZGxlQ2xvc2VSZWYuY3VycmVudCh7XG4gICAgICAgIC4uLmNvbnRleHQsXG4gICAgICAgIHRyZWUsXG4gICAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgIHk6IGV2ZW50LmNsaWVudFksXG4gICAgICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgICAgY2xlYXJQb2ludGVyRXZlbnRzKCk7XG4gICAgICAgICAgY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIoKTtcbiAgICAgICAgICBjbG9zZVdpdGhEZWxheShldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pKGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGlzRWxlbWVudChkb21SZWZlcmVuY2UpKSB7XG4gICAgICBjb25zdCByZWYgPSBkb21SZWZlcmVuY2U7XG4gICAgICBvcGVuICYmIHJlZi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25TY3JvbGxNb3VzZUxlYXZlKTtcbiAgICAgIGZsb2F0aW5nID09IG51bGwgfHwgZmxvYXRpbmcuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uU2Nyb2xsTW91c2VMZWF2ZSk7XG4gICAgICBtb3ZlICYmIHJlZi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlRW50ZXIsIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZWYuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIG9uTW91c2VFbnRlcik7XG4gICAgICByZWYuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uTW91c2VMZWF2ZSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBvcGVuICYmIHJlZi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25TY3JvbGxNb3VzZUxlYXZlKTtcbiAgICAgICAgZmxvYXRpbmcgPT0gbnVsbCB8fCBmbG9hdGluZy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25TY3JvbGxNb3VzZUxlYXZlKTtcbiAgICAgICAgbW92ZSAmJiByZWYucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZUVudGVyKTtcbiAgICAgICAgcmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBvbk1vdXNlRW50ZXIpO1xuICAgICAgICByZWYucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uTW91c2VMZWF2ZSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW2RvbVJlZmVyZW5jZSwgZmxvYXRpbmcsIGVuYWJsZWQsIGNvbnRleHQsIG1vdXNlT25seSwgcmVzdE1zLCBtb3ZlLCBjbG9zZVdpdGhEZWxheSwgY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIsIGNsZWFyUG9pbnRlckV2ZW50cywgb25PcGVuQ2hhbmdlLCBvcGVuLCB0cmVlLCBkZWxheVJlZiwgaGFuZGxlQ2xvc2VSZWYsIGRhdGFSZWZdKTtcblxuICAvLyBCbG9jayBwb2ludGVyLWV2ZW50cyBvZiBldmVyeSBlbGVtZW50IG90aGVyIHRoYW4gdGhlIHJlZmVyZW5jZSBhbmQgZmxvYXRpbmdcbiAgLy8gd2hpbGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXMgb3BlbiBhbmQgaGFzIGEgYGhhbmRsZUNsb3NlYCBoYW5kbGVyLiBBbHNvXG4gIC8vIGhhbmRsZXMgbmVzdGVkIGZsb2F0aW5nIGVsZW1lbnRzLlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzE3MjJcbiAgaW5kZXgoKCkgPT4ge1xuICAgIHZhciBfaGFuZGxlQ2xvc2VSZWYkY3VycmU7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvcGVuICYmIChfaGFuZGxlQ2xvc2VSZWYkY3VycmUgPSBoYW5kbGVDbG9zZVJlZi5jdXJyZW50KSAhPSBudWxsICYmIF9oYW5kbGVDbG9zZVJlZiRjdXJyZS5fX29wdGlvbnMuYmxvY2tQb2ludGVyRXZlbnRzICYmIGlzSG92ZXJPcGVuKCkpIHtcbiAgICAgIGNvbnN0IGJvZHkgPSBnZXREb2N1bWVudChmbG9hdGluZykuYm9keTtcbiAgICAgIGJvZHkuc2V0QXR0cmlidXRlKHNhZmVQb2x5Z29uSWRlbnRpZmllciwgJycpO1xuICAgICAgYm9keS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgcGVyZm9ybWVkUG9pbnRlckV2ZW50c011dGF0aW9uUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgaWYgKGlzRWxlbWVudChkb21SZWZlcmVuY2UpICYmIGZsb2F0aW5nKSB7XG4gICAgICAgIHZhciBfdHJlZSRub2Rlc1JlZiRjdXJyZW47XG4gICAgICAgIGNvbnN0IHJlZiA9IGRvbVJlZmVyZW5jZTtcbiAgICAgICAgY29uc3QgcGFyZW50RmxvYXRpbmcgPSB0cmVlID09IG51bGwgfHwgKF90cmVlJG5vZGVzUmVmJGN1cnJlbiA9IHRyZWUubm9kZXNSZWYuY3VycmVudC5maW5kKG5vZGUgPT4gbm9kZS5pZCA9PT0gcGFyZW50SWQpKSA9PSBudWxsIHx8IChfdHJlZSRub2Rlc1JlZiRjdXJyZW4gPSBfdHJlZSRub2Rlc1JlZiRjdXJyZW4uY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90cmVlJG5vZGVzUmVmJGN1cnJlbi5lbGVtZW50cy5mbG9hdGluZztcbiAgICAgICAgaWYgKHBhcmVudEZsb2F0aW5nKSB7XG4gICAgICAgICAgcGFyZW50RmxvYXRpbmcuc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJlZi5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2F1dG8nO1xuICAgICAgICBmbG9hdGluZy5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2F1dG8nO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIHJlZi5zdHlsZS5wb2ludGVyRXZlbnRzID0gJyc7XG4gICAgICAgICAgZmxvYXRpbmcuc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2VuYWJsZWQsIG9wZW4sIHBhcmVudElkLCBmbG9hdGluZywgZG9tUmVmZXJlbmNlLCB0cmVlLCBoYW5kbGVDbG9zZVJlZiwgZGF0YVJlZiwgaXNIb3Zlck9wZW5dKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmICghb3Blbikge1xuICAgICAgcG9pbnRlclR5cGVSZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgIGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyKCk7XG4gICAgICBjbGVhclBvaW50ZXJFdmVudHMoKTtcbiAgICB9XG4gIH0sIFtvcGVuLCBjbGVhbnVwTW91c2VNb3ZlSGFuZGxlciwgY2xlYXJQb2ludGVyRXZlbnRzXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyKCk7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIGNsZWFyVGltZW91dChyZXN0VGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgIGNsZWFyUG9pbnRlckV2ZW50cygpO1xuICAgIH07XG4gIH0sIFtlbmFibGVkLCBkb21SZWZlcmVuY2UsIGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyLCBjbGVhclBvaW50ZXJFdmVudHNdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRQb2ludGVyUmVmKGV2ZW50KSB7XG4gICAgICBwb2ludGVyVHlwZVJlZi5jdXJyZW50ID0gZXZlbnQucG9pbnRlclR5cGU7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgb25Qb2ludGVyRG93bjogc2V0UG9pbnRlclJlZixcbiAgICAgICAgb25Qb2ludGVyRW50ZXI6IHNldFBvaW50ZXJSZWYsXG4gICAgICAgIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKG9wZW4gfHwgcmVzdE1zID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsZWFyVGltZW91dChyZXN0VGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgICAgICByZXN0VGltZW91dFJlZi5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWJsb2NrTW91c2VNb3ZlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnaG92ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZXN0TXMpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZmxvYXRpbmc6IHtcbiAgICAgICAgb25Nb3VzZUVudGVyKCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBvbk1vdXNlTGVhdmUoZXZlbnQpIHtcbiAgICAgICAgICBjbG9zZVdpdGhEZWxheShldmVudC5uYXRpdmVFdmVudCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIHJlc3RNcywgb3Blbiwgb25PcGVuQ2hhbmdlLCBjbG9zZVdpdGhEZWxheV0pO1xufVxuXG5jb25zdCBGbG9hdGluZ0RlbGF5R3JvdXBDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICBkZWxheTogMCxcbiAgaW5pdGlhbERlbGF5OiAwLFxuICB0aW1lb3V0TXM6IDAsXG4gIGN1cnJlbnRJZDogbnVsbCxcbiAgc2V0Q3VycmVudElkOiAoKSA9PiB7fSxcbiAgc2V0U3RhdGU6ICgpID0+IHt9LFxuICBpc0luc3RhbnRQaGFzZTogZmFsc2Vcbn0pO1xuY29uc3QgdXNlRGVsYXlHcm91cENvbnRleHQgPSAoKSA9PiBSZWFjdC51c2VDb250ZXh0KEZsb2F0aW5nRGVsYXlHcm91cENvbnRleHQpO1xuLyoqXG4gKiBQcm92aWRlcyBjb250ZXh0IGZvciBhIGdyb3VwIG9mIGZsb2F0aW5nIGVsZW1lbnRzIHRoYXQgc2hvdWxkIHNoYXJlIGFcbiAqIGBkZWxheWAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdEZWxheUdyb3VwXG4gKi9cbmNvbnN0IEZsb2F0aW5nRGVsYXlHcm91cCA9IF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGNoaWxkcmVuLFxuICAgIGRlbGF5LFxuICAgIHRpbWVvdXRNcyA9IDBcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gUmVhY3QudXNlUmVkdWNlcigocHJldiwgbmV4dCkgPT4gKHtcbiAgICAuLi5wcmV2LFxuICAgIC4uLm5leHRcbiAgfSksIHtcbiAgICBkZWxheSxcbiAgICB0aW1lb3V0TXMsXG4gICAgaW5pdGlhbERlbGF5OiBkZWxheSxcbiAgICBjdXJyZW50SWQ6IG51bGwsXG4gICAgaXNJbnN0YW50UGhhc2U6IGZhbHNlXG4gIH0pO1xuICBjb25zdCBpbml0aWFsQ3VycmVudElkUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBzZXRDdXJyZW50SWQgPSBSZWFjdC51c2VDYWxsYmFjayhjdXJyZW50SWQgPT4ge1xuICAgIHNldFN0YXRlKHtcbiAgICAgIGN1cnJlbnRJZFxuICAgIH0pO1xuICB9LCBbXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoc3RhdGUuY3VycmVudElkKSB7XG4gICAgICBpZiAoaW5pdGlhbEN1cnJlbnRJZFJlZi5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgIGluaXRpYWxDdXJyZW50SWRSZWYuY3VycmVudCA9IHN0YXRlLmN1cnJlbnRJZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICBpc0luc3RhbnRQaGFzZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBpc0luc3RhbnRQaGFzZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgaW5pdGlhbEN1cnJlbnRJZFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH0sIFtzdGF0ZS5jdXJyZW50SWRdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZsb2F0aW5nRGVsYXlHcm91cENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBzZXRTdGF0ZSxcbiAgICAgIHNldEN1cnJlbnRJZFxuICAgIH0pLCBbc3RhdGUsIHNldFN0YXRlLCBzZXRDdXJyZW50SWRdKVxuICB9LCBjaGlsZHJlbik7XG59O1xuY29uc3QgdXNlRGVsYXlHcm91cCA9IChfcmVmMiwgX3JlZjMpID0+IHtcbiAgbGV0IHtcbiAgICBvcGVuLFxuICAgIG9uT3BlbkNoYW5nZVxuICB9ID0gX3JlZjI7XG4gIGxldCB7XG4gICAgaWRcbiAgfSA9IF9yZWYzO1xuICBjb25zdCB7XG4gICAgY3VycmVudElkLFxuICAgIHNldEN1cnJlbnRJZCxcbiAgICBpbml0aWFsRGVsYXksXG4gICAgc2V0U3RhdGUsXG4gICAgdGltZW91dE1zXG4gIH0gPSB1c2VEZWxheUdyb3VwQ29udGV4dCgpO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKGN1cnJlbnRJZCkge1xuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBkZWxheToge1xuICAgICAgICAgIG9wZW46IDEsXG4gICAgICAgICAgY2xvc2U6IGdldERlbGF5KGluaXRpYWxEZWxheSwgJ2Nsb3NlJylcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoY3VycmVudElkICE9PSBpZCkge1xuICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2lkLCBvbk9wZW5DaGFuZ2UsIHNldFN0YXRlLCBjdXJyZW50SWQsIGluaXRpYWxEZWxheV0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgZnVuY3Rpb24gdW5zZXQoKSB7XG4gICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UpO1xuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBkZWxheTogaW5pdGlhbERlbGF5LFxuICAgICAgICBjdXJyZW50SWQ6IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIW9wZW4gJiYgY3VycmVudElkID09PSBpZCkge1xuICAgICAgaWYgKHRpbWVvdXRNcykge1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQodW5zZXQsIHRpbWVvdXRNcyk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5zZXQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtvcGVuLCBzZXRTdGF0ZSwgY3VycmVudElkLCBpZCwgb25PcGVuQ2hhbmdlLCBpbml0aWFsRGVsYXksIHRpbWVvdXRNc10pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKG9wZW4pIHtcbiAgICAgIHNldEN1cnJlbnRJZChpZCk7XG4gICAgfVxuICB9LCBbb3Blbiwgc2V0Q3VycmVudElkLCBpZF0pO1xufTtcblxuZnVuY3Rpb24gZ2V0QW5jZXN0b3JzKG5vZGVzLCBpZCkge1xuICB2YXIgX25vZGVzJGZpbmQ7XG4gIGxldCBhbGxBbmNlc3RvcnMgPSBbXTtcbiAgbGV0IGN1cnJlbnRQYXJlbnRJZCA9IChfbm9kZXMkZmluZCA9IG5vZGVzLmZpbmQobm9kZSA9PiBub2RlLmlkID09PSBpZCkpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZXMkZmluZC5wYXJlbnRJZDtcbiAgd2hpbGUgKGN1cnJlbnRQYXJlbnRJZCkge1xuICAgIGNvbnN0IGN1cnJlbnROb2RlID0gbm9kZXMuZmluZChub2RlID0+IG5vZGUuaWQgPT09IGN1cnJlbnRQYXJlbnRJZCk7XG4gICAgY3VycmVudFBhcmVudElkID0gY3VycmVudE5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IGN1cnJlbnROb2RlLnBhcmVudElkO1xuICAgIGlmIChjdXJyZW50Tm9kZSkge1xuICAgICAgYWxsQW5jZXN0b3JzID0gYWxsQW5jZXN0b3JzLmNvbmNhdChjdXJyZW50Tm9kZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhbGxBbmNlc3RvcnM7XG59XG5cbmZ1bmN0aW9uIGdldENoaWxkcmVuKG5vZGVzLCBpZCkge1xuICBsZXQgYWxsQ2hpbGRyZW4gPSBub2Rlcy5maWx0ZXIobm9kZSA9PiB7XG4gICAgdmFyIF9ub2RlJGNvbnRleHQ7XG4gICAgcmV0dXJuIG5vZGUucGFyZW50SWQgPT09IGlkICYmICgoX25vZGUkY29udGV4dCA9IG5vZGUuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGNvbnRleHQub3Blbik7XG4gIH0pO1xuICBsZXQgY3VycmVudENoaWxkcmVuID0gYWxsQ2hpbGRyZW47XG4gIHdoaWxlIChjdXJyZW50Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgY3VycmVudENoaWxkcmVuID0gbm9kZXMuZmlsdGVyKG5vZGUgPT4ge1xuICAgICAgdmFyIF9jdXJyZW50Q2hpbGRyZW47XG4gICAgICByZXR1cm4gKF9jdXJyZW50Q2hpbGRyZW4gPSBjdXJyZW50Q2hpbGRyZW4pID09IG51bGwgPyB2b2lkIDAgOiBfY3VycmVudENoaWxkcmVuLnNvbWUobiA9PiB7XG4gICAgICAgIHZhciBfbm9kZSRjb250ZXh0MjtcbiAgICAgICAgcmV0dXJuIG5vZGUucGFyZW50SWQgPT09IG4uaWQgJiYgKChfbm9kZSRjb250ZXh0MiA9IG5vZGUuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGNvbnRleHQyLm9wZW4pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgYWxsQ2hpbGRyZW4gPSBhbGxDaGlsZHJlbi5jb25jYXQoY3VycmVudENoaWxkcmVuKTtcbiAgfVxuICByZXR1cm4gYWxsQ2hpbGRyZW47XG59XG5mdW5jdGlvbiBnZXREZWVwZXN0Tm9kZShub2RlcywgaWQpIHtcbiAgbGV0IGRlZXBlc3ROb2RlSWQ7XG4gIGxldCBtYXhEZXB0aCA9IC0xO1xuICBmdW5jdGlvbiBmaW5kRGVlcGVzdChub2RlSWQsIGRlcHRoKSB7XG4gICAgaWYgKGRlcHRoID4gbWF4RGVwdGgpIHtcbiAgICAgIGRlZXBlc3ROb2RlSWQgPSBub2RlSWQ7XG4gICAgICBtYXhEZXB0aCA9IGRlcHRoO1xuICAgIH1cbiAgICBjb25zdCBjaGlsZHJlbiA9IGdldENoaWxkcmVuKG5vZGVzLCBub2RlSWQpO1xuICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgZmluZERlZXBlc3QoY2hpbGQuaWQsIGRlcHRoICsgMSk7XG4gICAgfSk7XG4gIH1cbiAgZmluZERlZXBlc3QoaWQsIDApO1xuICByZXR1cm4gbm9kZXMuZmluZChub2RlID0+IG5vZGUuaWQgPT09IGRlZXBlc3ROb2RlSWQpO1xufVxuXG4vLyBNb2RpZmllZCB0byBhZGQgY29uZGl0aW9uYWwgYGFyaWEtaGlkZGVuYCBzdXBwb3J0OlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RoZUthc2hleS9hcmlhLWhpZGRlbi9ibG9iLzkyMjBjOGY0YTRmZDM1ZjYzYmVlNTUxMGE5ZjQxYTM3MjY0MzgyZDQvc3JjL2luZGV4LnRzXG5sZXQgY291bnRlck1hcCA9IC8qI19fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xubGV0IHVuY29udHJvbGxlZEVsZW1lbnRzU2V0ID0gLyojX19QVVJFX18qL25ldyBXZWFrU2V0KCk7XG5sZXQgbWFya2VyTWFwID0ge307XG5sZXQgbG9ja0NvdW50ID0gMDtcbmNvbnN0IHN1cHBvcnRzSW5lcnQgPSAoKSA9PiB0eXBlb2YgSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmICdpbmVydCcgaW4gSFRNTEVsZW1lbnQucHJvdG90eXBlO1xuY29uc3QgdW53cmFwSG9zdCA9IG5vZGUgPT4gbm9kZSAmJiAobm9kZS5ob3N0IHx8IHVud3JhcEhvc3Qobm9kZS5wYXJlbnROb2RlKSk7XG5jb25zdCBjb3JyZWN0RWxlbWVudHMgPSAocGFyZW50LCB0YXJnZXRzKSA9PiB0YXJnZXRzLm1hcCh0YXJnZXQgPT4ge1xuICBpZiAocGFyZW50LmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGNvbnN0IGNvcnJlY3RlZFRhcmdldCA9IHVud3JhcEhvc3QodGFyZ2V0KTtcbiAgaWYgKHBhcmVudC5jb250YWlucyhjb3JyZWN0ZWRUYXJnZXQpKSB7XG4gICAgcmV0dXJuIGNvcnJlY3RlZFRhcmdldDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn0pLmZpbHRlcih4ID0+IHggIT0gbnVsbCk7XG5mdW5jdGlvbiBhcHBseUF0dHJpYnV0ZVRvT3RoZXJzKHVuY29ycmVjdGVkQXZvaWRFbGVtZW50cywgYm9keSwgYXJpYUhpZGRlbiwgaW5lcnQpIHtcbiAgY29uc3QgbWFya2VyTmFtZSA9ICdkYXRhLWZsb2F0aW5nLXVpLWluZXJ0JztcbiAgY29uc3QgY29udHJvbEF0dHJpYnV0ZSA9IGluZXJ0ID8gJ2luZXJ0JyA6IGFyaWFIaWRkZW4gPyAnYXJpYS1oaWRkZW4nIDogbnVsbDtcbiAgY29uc3QgYXZvaWRFbGVtZW50cyA9IGNvcnJlY3RFbGVtZW50cyhib2R5LCB1bmNvcnJlY3RlZEF2b2lkRWxlbWVudHMpO1xuICBjb25zdCBlbGVtZW50c1RvS2VlcCA9IG5ldyBTZXQoKTtcbiAgY29uc3QgZWxlbWVudHNUb1N0b3AgPSBuZXcgU2V0KGF2b2lkRWxlbWVudHMpO1xuICBjb25zdCBoaWRkZW5FbGVtZW50cyA9IFtdO1xuICBpZiAoIW1hcmtlck1hcFttYXJrZXJOYW1lXSkge1xuICAgIG1hcmtlck1hcFttYXJrZXJOYW1lXSA9IG5ldyBXZWFrTWFwKCk7XG4gIH1cbiAgY29uc3QgbWFya2VyQ291bnRlciA9IG1hcmtlck1hcFttYXJrZXJOYW1lXTtcbiAgYXZvaWRFbGVtZW50cy5mb3JFYWNoKGtlZXApO1xuICBkZWVwKGJvZHkpO1xuICBlbGVtZW50c1RvS2VlcC5jbGVhcigpO1xuICBmdW5jdGlvbiBrZWVwKGVsKSB7XG4gICAgaWYgKCFlbCB8fCBlbGVtZW50c1RvS2VlcC5oYXMoZWwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsZW1lbnRzVG9LZWVwLmFkZChlbCk7XG4gICAgZWwucGFyZW50Tm9kZSAmJiBrZWVwKGVsLnBhcmVudE5vZGUpO1xuICB9XG4gIGZ1bmN0aW9uIGRlZXAocGFyZW50KSB7XG4gICAgaWYgKCFwYXJlbnQgfHwgZWxlbWVudHNUb1N0b3AuaGFzKHBhcmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChwYXJlbnQuY2hpbGRyZW4sIG5vZGUgPT4ge1xuICAgICAgaWYgKGVsZW1lbnRzVG9LZWVwLmhhcyhub2RlKSkge1xuICAgICAgICBkZWVwKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYXR0ciA9IGNvbnRyb2xBdHRyaWJ1dGUgPyBub2RlLmdldEF0dHJpYnV0ZShjb250cm9sQXR0cmlidXRlKSA6IG51bGw7XG4gICAgICAgIGNvbnN0IGFscmVhZHlIaWRkZW4gPSBhdHRyICE9PSBudWxsICYmIGF0dHIgIT09ICdmYWxzZSc7XG4gICAgICAgIGNvbnN0IGNvdW50ZXJWYWx1ZSA9IChjb3VudGVyTWFwLmdldChub2RlKSB8fCAwKSArIDE7XG4gICAgICAgIGNvbnN0IG1hcmtlclZhbHVlID0gKG1hcmtlckNvdW50ZXIuZ2V0KG5vZGUpIHx8IDApICsgMTtcbiAgICAgICAgY291bnRlck1hcC5zZXQobm9kZSwgY291bnRlclZhbHVlKTtcbiAgICAgICAgbWFya2VyQ291bnRlci5zZXQobm9kZSwgbWFya2VyVmFsdWUpO1xuICAgICAgICBoaWRkZW5FbGVtZW50cy5wdXNoKG5vZGUpO1xuICAgICAgICBpZiAoY291bnRlclZhbHVlID09PSAxICYmIGFscmVhZHlIaWRkZW4pIHtcbiAgICAgICAgICB1bmNvbnRyb2xsZWRFbGVtZW50c1NldC5hZGQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtlclZhbHVlID09PSAxKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobWFya2VyTmFtZSwgJycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYWxyZWFkeUhpZGRlbiAmJiBjb250cm9sQXR0cmlidXRlKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoY29udHJvbEF0dHJpYnV0ZSwgJ3RydWUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGxvY2tDb3VudCsrO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGhpZGRlbkVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCBjb3VudGVyVmFsdWUgPSAoY291bnRlck1hcC5nZXQoZWxlbWVudCkgfHwgMCkgLSAxO1xuICAgICAgY29uc3QgbWFya2VyVmFsdWUgPSAobWFya2VyQ291bnRlci5nZXQoZWxlbWVudCkgfHwgMCkgLSAxO1xuICAgICAgY291bnRlck1hcC5zZXQoZWxlbWVudCwgY291bnRlclZhbHVlKTtcbiAgICAgIG1hcmtlckNvdW50ZXIuc2V0KGVsZW1lbnQsIG1hcmtlclZhbHVlKTtcbiAgICAgIGlmICghY291bnRlclZhbHVlKSB7XG4gICAgICAgIGlmICghdW5jb250cm9sbGVkRWxlbWVudHNTZXQuaGFzKGVsZW1lbnQpICYmIGNvbnRyb2xBdHRyaWJ1dGUpIHtcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShjb250cm9sQXR0cmlidXRlKTtcbiAgICAgICAgfVxuICAgICAgICB1bmNvbnRyb2xsZWRFbGVtZW50c1NldC5kZWxldGUoZWxlbWVudCk7XG4gICAgICB9XG4gICAgICBpZiAoIW1hcmtlclZhbHVlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG1hcmtlck5hbWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxvY2tDb3VudC0tO1xuICAgIGlmICghbG9ja0NvdW50KSB7XG4gICAgICBjb3VudGVyTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgIGNvdW50ZXJNYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgdW5jb250cm9sbGVkRWxlbWVudHNTZXQgPSBuZXcgV2Vha1NldCgpO1xuICAgICAgbWFya2VyTWFwID0ge307XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gbWFya090aGVycyhhdm9pZEVsZW1lbnRzLCBhcmlhSGlkZGVuLCBpbmVydCkge1xuICBpZiAoYXJpYUhpZGRlbiA9PT0gdm9pZCAwKSB7XG4gICAgYXJpYUhpZGRlbiA9IGZhbHNlO1xuICB9XG4gIGlmIChpbmVydCA9PT0gdm9pZCAwKSB7XG4gICAgaW5lcnQgPSBmYWxzZTtcbiAgfVxuICBjb25zdCBib2R5ID0gZ2V0RG9jdW1lbnQoYXZvaWRFbGVtZW50c1swXSkuYm9keTtcbiAgcmV0dXJuIGFwcGx5QXR0cmlidXRlVG9PdGhlcnMoYXZvaWRFbGVtZW50cy5jb25jYXQoQXJyYXkuZnJvbShib2R5LnF1ZXJ5U2VsZWN0b3JBbGwoJ1thcmlhLWxpdmVdJykpKSwgYm9keSwgYXJpYUhpZGRlbiwgaW5lcnQpO1xufVxuXG5jb25zdCBnZXRUYWJiYWJsZU9wdGlvbnMgPSAoKSA9PiAoe1xuICBnZXRTaGFkb3dSb290OiB0cnVlLFxuICBkaXNwbGF5Q2hlY2s6XG4gIC8vIEpTRE9NIGRvZXMgbm90IHN1cHBvcnQgdGhlIGB0YWJiYWJsZWAgbGlicmFyeS4gVG8gc29sdmUgdGhpcyB3ZSBjYW5cbiAgLy8gY2hlY2sgaWYgYFJlc2l6ZU9ic2VydmVyYCBpcyBhIHJlYWwgZnVuY3Rpb24gKG5vdCBwb2x5ZmlsbGVkKSwgd2hpY2hcbiAgLy8gZGV0ZXJtaW5lcyBpZiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBpcyBKU0RPTS1saWtlLlxuICB0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbicgJiYgUmVzaXplT2JzZXJ2ZXIudG9TdHJpbmcoKS5pbmNsdWRlcygnW25hdGl2ZSBjb2RlXScpID8gJ2Z1bGwnIDogJ25vbmUnXG59KTtcbmZ1bmN0aW9uIGdldFRhYmJhYmxlSW4oY29udGFpbmVyLCBkaXJlY3Rpb24pIHtcbiAgY29uc3QgYWxsVGFiYmFibGUgPSB0YWJiYWJsZShjb250YWluZXIsIGdldFRhYmJhYmxlT3B0aW9ucygpKTtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gJ3ByZXYnKSB7XG4gICAgYWxsVGFiYmFibGUucmV2ZXJzZSgpO1xuICB9XG4gIGNvbnN0IGFjdGl2ZUluZGV4ID0gYWxsVGFiYmFibGUuaW5kZXhPZihhY3RpdmVFbGVtZW50KGdldERvY3VtZW50KGNvbnRhaW5lcikpKTtcbiAgY29uc3QgbmV4dFRhYmJhYmxlRWxlbWVudHMgPSBhbGxUYWJiYWJsZS5zbGljZShhY3RpdmVJbmRleCArIDEpO1xuICByZXR1cm4gbmV4dFRhYmJhYmxlRWxlbWVudHNbMF07XG59XG5mdW5jdGlvbiBnZXROZXh0VGFiYmFibGUoKSB7XG4gIHJldHVybiBnZXRUYWJiYWJsZUluKGRvY3VtZW50LmJvZHksICduZXh0Jyk7XG59XG5mdW5jdGlvbiBnZXRQcmV2aW91c1RhYmJhYmxlKCkge1xuICByZXR1cm4gZ2V0VGFiYmFibGVJbihkb2N1bWVudC5ib2R5LCAncHJldicpO1xufVxuZnVuY3Rpb24gaXNPdXRzaWRlRXZlbnQoZXZlbnQsIGNvbnRhaW5lcikge1xuICBjb25zdCBjb250YWluZXJFbGVtZW50ID0gY29udGFpbmVyIHx8IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICByZXR1cm4gIXJlbGF0ZWRUYXJnZXQgfHwgIWNvbnRhaW5zKGNvbnRhaW5lckVsZW1lbnQsIHJlbGF0ZWRUYXJnZXQpO1xufVxuZnVuY3Rpb24gZGlzYWJsZUZvY3VzSW5zaWRlKGNvbnRhaW5lcikge1xuICBjb25zdCB0YWJiYWJsZUVsZW1lbnRzID0gdGFiYmFibGUoY29udGFpbmVyLCBnZXRUYWJiYWJsZU9wdGlvbnMoKSk7XG4gIHRhYmJhYmxlRWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICBlbGVtZW50LmRhdGFzZXQudGFiaW5kZXggPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSB8fCAnJztcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBlbmFibGVGb2N1c0luc2lkZShjb250YWluZXIpIHtcbiAgY29uc3QgZWxlbWVudHMgPSBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtdGFiaW5kZXhdJyk7XG4gIGVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgY29uc3QgdGFiaW5kZXggPSBlbGVtZW50LmRhdGFzZXQudGFiaW5kZXg7XG4gICAgZGVsZXRlIGVsZW1lbnQuZGF0YXNldC50YWJpbmRleDtcbiAgICBpZiAodGFiaW5kZXgpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIHRhYmluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gU2VlIERpZWdvIEhheidzIFNhbmRib3ggZm9yIG1ha2luZyB0aGlzIGxvZ2ljIHdvcmsgd2VsbCBvbiBTYWZhcmkvaU9TOlxuLy8gaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3RhYmJhYmxlLXBvcnRhbC1mNHRuZz9maWxlPS9zcmMvRm9jdXNUcmFwLnRzeFxuXG5jb25zdCBISURERU5fU1RZTEVTID0ge1xuICBib3JkZXI6IDAsXG4gIGNsaXA6ICdyZWN0KDAgMCAwIDApJyxcbiAgaGVpZ2h0OiAnMXB4JyxcbiAgbWFyZ2luOiAnLTFweCcsXG4gIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgcGFkZGluZzogMCxcbiAgcG9zaXRpb246ICdmaXhlZCcsXG4gIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICB3aWR0aDogJzFweCcsXG4gIHRvcDogMCxcbiAgbGVmdDogMFxufTtcbmxldCB0aW1lb3V0SWQ7XG5mdW5jdGlvbiBzZXRBY3RpdmVFbGVtZW50T25UYWIoZXZlbnQpIHtcbiAgaWYgKGV2ZW50LmtleSA9PT0gJ1RhYicpIHtcbiAgICBldmVudC50YXJnZXQ7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gIH1cbn1cbmNvbnN0IEZvY3VzR3VhcmQgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBGb2N1c0d1YXJkKHByb3BzLCByZWYpIHtcbiAgY29uc3QgW3JvbGUsIHNldFJvbGVdID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChpc1NhZmFyaSgpKSB7XG4gICAgICAvLyBVbmxpa2Ugb3RoZXIgc2NyZWVuIHJlYWRlcnMgc3VjaCBhcyBOVkRBIGFuZCBKQVdTLCB0aGUgdmlydHVhbCBjdXJzb3JcbiAgICAgIC8vIG9uIFZvaWNlT3ZlciBkb2VzIHRyaWdnZXIgdGhlIG9uRm9jdXMgZXZlbnQsIHNvIHdlIGNhbiB1c2UgdGhlIGZvY3VzXG4gICAgICAvLyB0cmFwIGVsZW1lbnQuIE9uIFNhZmFyaSwgb25seSBidXR0b25zIHRyaWdnZXIgdGhlIG9uRm9jdXMgZXZlbnQuXG4gICAgICAvLyBOQjogXCJncm91cFwiIHJvbGUgaW4gdGhlIFNhbmRib3ggbm8gbG9uZ2VyIGFwcGVhcnMgdG8gd29yaywgbXVzdCBiZSBhXG4gICAgICAvLyBidXR0b24gcm9sZS5cbiAgICAgIHNldFJvbGUoJ2J1dHRvbicpO1xuICAgIH1cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgc2V0QWN0aXZlRWxlbWVudE9uVGFiKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHNldEFjdGl2ZUVsZW1lbnRPblRhYik7XG4gICAgfTtcbiAgfSwgW10pO1xuICBjb25zdCByZXN0UHJvcHMgPSB7XG4gICAgcmVmLFxuICAgIHRhYkluZGV4OiAwLFxuICAgIC8vIFJvbGUgaXMgb25seSBmb3IgVm9pY2VPdmVyXG4gICAgcm9sZSxcbiAgICAnYXJpYS1oaWRkZW4nOiByb2xlID8gdW5kZWZpbmVkIDogdHJ1ZSxcbiAgICBbY3JlYXRlQXR0cmlidXRlKCdmb2N1cy1ndWFyZCcpXTogJycsXG4gICAgc3R5bGU6IEhJRERFTl9TVFlMRVNcbiAgfTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHJlc3RQcm9wcykpO1xufSk7XG5cbmNvbnN0IFBvcnRhbENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmZ1bmN0aW9uIHVzZUZsb2F0aW5nUG9ydGFsTm9kZShfdGVtcCkge1xuICBsZXQge1xuICAgIGlkLFxuICAgIHJvb3RcbiAgfSA9IF90ZW1wID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wO1xuICBjb25zdCBbcG9ydGFsTm9kZSwgc2V0UG9ydGFsTm9kZV0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgdW5pcXVlSWQgPSB1c2VJZCgpO1xuICBjb25zdCBwb3J0YWxDb250ZXh0ID0gdXNlUG9ydGFsQ29udGV4dCgpO1xuICBjb25zdCBkYXRhID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIGlkLFxuICAgIHJvb3QsXG4gICAgcG9ydGFsQ29udGV4dCxcbiAgICB1bmlxdWVJZFxuICB9KSwgW2lkLCByb290LCBwb3J0YWxDb250ZXh0LCB1bmlxdWVJZF0pO1xuICBjb25zdCBkYXRhUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGluZGV4KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcG9ydGFsTm9kZSA9PSBudWxsIHx8IHBvcnRhbE5vZGUucmVtb3ZlKCk7XG4gICAgfTtcbiAgfSwgW3BvcnRhbE5vZGUsIGRhdGFdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChkYXRhUmVmLmN1cnJlbnQgPT09IGRhdGEpIHJldHVybjtcbiAgICBkYXRhUmVmLmN1cnJlbnQgPSBkYXRhO1xuICAgIGNvbnN0IHtcbiAgICAgIGlkLFxuICAgICAgcm9vdCxcbiAgICAgIHBvcnRhbENvbnRleHQsXG4gICAgICB1bmlxdWVJZFxuICAgIH0gPSBkYXRhO1xuICAgIGNvbnN0IGV4aXN0aW5nSWRSb290ID0gaWQgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgOiBudWxsO1xuICAgIGNvbnN0IGF0dHIgPSBjcmVhdGVBdHRyaWJ1dGUoJ3BvcnRhbCcpO1xuICAgIGlmIChleGlzdGluZ0lkUm9vdCkge1xuICAgICAgY29uc3Qgc3ViUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgc3ViUm9vdC5pZCA9IHVuaXF1ZUlkO1xuICAgICAgc3ViUm9vdC5zZXRBdHRyaWJ1dGUoYXR0ciwgJycpO1xuICAgICAgZXhpc3RpbmdJZFJvb3QuYXBwZW5kQ2hpbGQoc3ViUm9vdCk7XG4gICAgICBzZXRQb3J0YWxOb2RlKHN1YlJvb3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgY29udGFpbmVyID0gcm9vdCB8fCAocG9ydGFsQ29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogcG9ydGFsQ29udGV4dC5wb3J0YWxOb2RlKTtcbiAgICAgIGlmIChjb250YWluZXIgJiYgIWlzRWxlbWVudChjb250YWluZXIpKSBjb250YWluZXIgPSBjb250YWluZXIuY3VycmVudDtcbiAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lciB8fCBkb2N1bWVudC5ib2R5O1xuICAgICAgbGV0IGlkV3JhcHBlciA9IG51bGw7XG4gICAgICBpZiAoaWQpIHtcbiAgICAgICAgaWRXcmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGlkV3JhcHBlci5pZCA9IGlkO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaWRXcmFwcGVyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN1YlJvb3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHN1YlJvb3QuaWQgPSB1bmlxdWVJZDtcbiAgICAgIHN1YlJvb3Quc2V0QXR0cmlidXRlKGF0dHIsICcnKTtcbiAgICAgIGNvbnRhaW5lciA9IGlkV3JhcHBlciB8fCBjb250YWluZXI7XG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoc3ViUm9vdCk7XG4gICAgICBzZXRQb3J0YWxOb2RlKHN1YlJvb3QpO1xuICAgIH1cbiAgfSwgW2RhdGFdKTtcbiAgcmV0dXJuIHBvcnRhbE5vZGU7XG59XG4vKipcbiAqIFBvcnRhbHMgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaW50byBhIGdpdmVuIGNvbnRhaW5lciBlbGVtZW50IOKAlCBieSBkZWZhdWx0LFxuICogb3V0c2lkZSBvZiB0aGUgYXBwIHJvb3QgYW5kIGludG8gdGhlIGJvZHkuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdQb3J0YWxcbiAqL1xuZnVuY3Rpb24gRmxvYXRpbmdQb3J0YWwoX3JlZikge1xuICBsZXQge1xuICAgIGNoaWxkcmVuLFxuICAgIGlkLFxuICAgIHJvb3QgPSBudWxsLFxuICAgIHByZXNlcnZlVGFiT3JkZXIgPSB0cnVlXG4gIH0gPSBfcmVmO1xuICBjb25zdCBwb3J0YWxOb2RlID0gdXNlRmxvYXRpbmdQb3J0YWxOb2RlKHtcbiAgICBpZCxcbiAgICByb290XG4gIH0pO1xuICBjb25zdCBbZm9jdXNNYW5hZ2VyU3RhdGUsIHNldEZvY3VzTWFuYWdlclN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBiZWZvcmVPdXRzaWRlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBhZnRlck91dHNpZGVSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGJlZm9yZUluc2lkZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgYWZ0ZXJJbnNpZGVSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IHNob3VsZFJlbmRlckd1YXJkcyA9XG4gIC8vIFRoZSBGb2N1c01hbmFnZXIgYW5kIHRoZXJlZm9yZSBmbG9hdGluZyBlbGVtZW50IGFyZSBjdXJyZW50bHkgb3Blbi9cbiAgLy8gcmVuZGVyZWQuXG4gICEhZm9jdXNNYW5hZ2VyU3RhdGUgJiZcbiAgLy8gR3VhcmRzIGFyZSBvbmx5IGZvciBub24tbW9kYWwgZm9jdXMgbWFuYWdlbWVudC5cbiAgIWZvY3VzTWFuYWdlclN0YXRlLm1vZGFsICYmXG4gIC8vIERvbid0IHJlbmRlciBpZiB1bm1vdW50IGlzIHRyYW5zaXRpb25pbmcuXG4gIGZvY3VzTWFuYWdlclN0YXRlLm9wZW4gJiYgcHJlc2VydmVUYWJPcmRlciAmJiAhIShyb290IHx8IHBvcnRhbE5vZGUpO1xuXG4gIC8vIGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy90YWJiYWJsZS1wb3J0YWwtZjR0bmc/ZmlsZT0vc3JjL1RhYmJhYmxlUG9ydGFsLnRzeFxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghcG9ydGFsTm9kZSB8fCAhcHJlc2VydmVUYWJPcmRlciB8fCBmb2N1c01hbmFnZXJTdGF0ZSAhPSBudWxsICYmIGZvY3VzTWFuYWdlclN0YXRlLm1vZGFsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIGVsZW1lbnRzIGluc2lkZSB0aGUgcG9ydGFsIGVsZW1lbnQgYXJlIHRhYmJhYmxlIG9ubHkgd2hlbiB0aGVcbiAgICAvLyBwb3J0YWwgaGFzIGFscmVhZHkgYmVlbiBmb2N1c2VkLCBlaXRoZXIgYnkgdGFiYmluZyBpbnRvIGEgZm9jdXMgdHJhcFxuICAgIC8vIGVsZW1lbnQgb3V0c2lkZSBvciB1c2luZyB0aGUgbW91c2UuXG4gICAgZnVuY3Rpb24gb25Gb2N1cyhldmVudCkge1xuICAgICAgaWYgKHBvcnRhbE5vZGUgJiYgaXNPdXRzaWRlRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgIGNvbnN0IGZvY3VzaW5nID0gZXZlbnQudHlwZSA9PT0gJ2ZvY3VzaW4nO1xuICAgICAgICBjb25zdCBtYW5hZ2VGb2N1cyA9IGZvY3VzaW5nID8gZW5hYmxlRm9jdXNJbnNpZGUgOiBkaXNhYmxlRm9jdXNJbnNpZGU7XG4gICAgICAgIG1hbmFnZUZvY3VzKHBvcnRhbE5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBMaXN0ZW4gdG8gdGhlIGV2ZW50IG9uIHRoZSBjYXB0dXJlIHBoYXNlIHNvIHRoZXkgcnVuIGJlZm9yZSB0aGUgZm9jdXNcbiAgICAvLyB0cmFwIGVsZW1lbnRzIG9uRm9jdXMgcHJvcCBpcyBjYWxsZWQuXG4gICAgcG9ydGFsTm9kZS5hZGRFdmVudExpc3RlbmVyKCdmb2N1c2luJywgb25Gb2N1cywgdHJ1ZSk7XG4gICAgcG9ydGFsTm9kZS5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIG9uRm9jdXMsIHRydWUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBwb3J0YWxOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBvbkZvY3VzLCB0cnVlKTtcbiAgICAgIHBvcnRhbE5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBvbkZvY3VzLCB0cnVlKTtcbiAgICB9O1xuICB9LCBbcG9ydGFsTm9kZSwgcHJlc2VydmVUYWJPcmRlciwgZm9jdXNNYW5hZ2VyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGZvY3VzTWFuYWdlclN0YXRlLm1vZGFsXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQb3J0YWxDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgIHByZXNlcnZlVGFiT3JkZXIsXG4gICAgICBiZWZvcmVPdXRzaWRlUmVmLFxuICAgICAgYWZ0ZXJPdXRzaWRlUmVmLFxuICAgICAgYmVmb3JlSW5zaWRlUmVmLFxuICAgICAgYWZ0ZXJJbnNpZGVSZWYsXG4gICAgICBwb3J0YWxOb2RlLFxuICAgICAgc2V0Rm9jdXNNYW5hZ2VyU3RhdGVcbiAgICB9KSwgW3ByZXNlcnZlVGFiT3JkZXIsIHBvcnRhbE5vZGVdKVxuICB9LCBzaG91bGRSZW5kZXJHdWFyZHMgJiYgcG9ydGFsTm9kZSAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGb2N1c0d1YXJkLCB7XG4gICAgXCJkYXRhLXR5cGVcIjogXCJvdXRzaWRlXCIsXG4gICAgcmVmOiBiZWZvcmVPdXRzaWRlUmVmLFxuICAgIG9uRm9jdXM6IGV2ZW50ID0+IHtcbiAgICAgIGlmIChpc091dHNpZGVFdmVudChldmVudCwgcG9ydGFsTm9kZSkpIHtcbiAgICAgICAgdmFyIF9iZWZvcmVJbnNpZGVSZWYkY3VycjtcbiAgICAgICAgKF9iZWZvcmVJbnNpZGVSZWYkY3VyciA9IGJlZm9yZUluc2lkZVJlZi5jdXJyZW50KSA9PSBudWxsIHx8IF9iZWZvcmVJbnNpZGVSZWYkY3Vyci5mb2N1cygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcHJldlRhYmJhYmxlID0gZ2V0UHJldmlvdXNUYWJiYWJsZSgpIHx8IChmb2N1c01hbmFnZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogZm9jdXNNYW5hZ2VyU3RhdGUucmVmcy5kb21SZWZlcmVuY2UuY3VycmVudCk7XG4gICAgICAgIHByZXZUYWJiYWJsZSA9PSBudWxsIHx8IHByZXZUYWJiYWJsZS5mb2N1cygpO1xuICAgICAgfVxuICAgIH1cbiAgfSksIHNob3VsZFJlbmRlckd1YXJkcyAmJiBwb3J0YWxOb2RlICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgXCJhcmlhLW93bnNcIjogcG9ydGFsTm9kZS5pZCxcbiAgICBzdHlsZTogSElEREVOX1NUWUxFU1xuICB9KSwgcG9ydGFsTm9kZSAmJiAvKiNfX1BVUkVfXyovY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBwb3J0YWxOb2RlKSwgc2hvdWxkUmVuZGVyR3VhcmRzICYmIHBvcnRhbE5vZGUgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9jdXNHdWFyZCwge1xuICAgIFwiZGF0YS10eXBlXCI6IFwib3V0c2lkZVwiLFxuICAgIHJlZjogYWZ0ZXJPdXRzaWRlUmVmLFxuICAgIG9uRm9jdXM6IGV2ZW50ID0+IHtcbiAgICAgIGlmIChpc091dHNpZGVFdmVudChldmVudCwgcG9ydGFsTm9kZSkpIHtcbiAgICAgICAgdmFyIF9hZnRlckluc2lkZVJlZiRjdXJyZTtcbiAgICAgICAgKF9hZnRlckluc2lkZVJlZiRjdXJyZSA9IGFmdGVySW5zaWRlUmVmLmN1cnJlbnQpID09IG51bGwgfHwgX2FmdGVySW5zaWRlUmVmJGN1cnJlLmZvY3VzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBuZXh0VGFiYmFibGUgPSBnZXROZXh0VGFiYmFibGUoKSB8fCAoZm9jdXNNYW5hZ2VyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGZvY3VzTWFuYWdlclN0YXRlLnJlZnMuZG9tUmVmZXJlbmNlLmN1cnJlbnQpO1xuICAgICAgICBuZXh0VGFiYmFibGUgPT0gbnVsbCB8fCBuZXh0VGFiYmFibGUuZm9jdXMoKTtcbiAgICAgICAgKGZvY3VzTWFuYWdlclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBmb2N1c01hbmFnZXJTdGF0ZS5jbG9zZU9uRm9jdXNPdXQpICYmIChmb2N1c01hbmFnZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogZm9jdXNNYW5hZ2VyU3RhdGUub25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSkpO1xufVxuY29uc3QgdXNlUG9ydGFsQ29udGV4dCA9ICgpID0+IFJlYWN0LnVzZUNvbnRleHQoUG9ydGFsQ29udGV4dCk7XG5cbmNvbnN0IExJU1RfTElNSVQgPSAyMDtcbmxldCBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRzID0gW107XG5mdW5jdGlvbiBhZGRQcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQoZWxlbWVudCkge1xuICBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRzID0gcHJldmlvdXNseUZvY3VzZWRFbGVtZW50cy5maWx0ZXIoZWwgPT4gZWwuaXNDb25uZWN0ZWQpO1xuICBpZiAoZWxlbWVudCAmJiBnZXROb2RlTmFtZShlbGVtZW50KSAhPT0gJ2JvZHknKSB7XG4gICAgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgIGlmIChwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRzLmxlbmd0aCA+IExJU1RfTElNSVQpIHtcbiAgICAgIHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMgPSBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRzLnNsaWNlKC1MSVNUX0xJTUlUKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCgpIHtcbiAgcmV0dXJuIHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMuc2xpY2UoKS5yZXZlcnNlKCkuZmluZChlbCA9PiBlbC5pc0Nvbm5lY3RlZCk7XG59XG5jb25zdCBWaXN1YWxseUhpZGRlbkRpc21pc3MgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBWaXN1YWxseUhpZGRlbkRpc21pc3MocHJvcHMsIHJlZikge1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgdHlwZTogXCJidXR0b25cIixcbiAgICByZWY6IHJlZixcbiAgICB0YWJJbmRleDogLTEsXG4gICAgc3R5bGU6IEhJRERFTl9TVFlMRVNcbiAgfSkpO1xufSk7XG4vKipcbiAqIFByb3ZpZGVzIGZvY3VzIG1hbmFnZW1lbnQgZm9yIHRoZSBmbG9hdGluZyBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nRm9jdXNNYW5hZ2VyXG4gKi9cbmZ1bmN0aW9uIEZsb2F0aW5nRm9jdXNNYW5hZ2VyKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBjb250ZXh0LFxuICAgIGNoaWxkcmVuLFxuICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgb3JkZXIgPSBbJ2NvbnRlbnQnXSxcbiAgICBndWFyZHM6IF9ndWFyZHMgPSB0cnVlLFxuICAgIGluaXRpYWxGb2N1cyA9IDAsXG4gICAgcmV0dXJuRm9jdXMgPSB0cnVlLFxuICAgIG1vZGFsID0gdHJ1ZSxcbiAgICB2aXN1YWxseUhpZGRlbkRpc21pc3MgPSBmYWxzZSxcbiAgICBjbG9zZU9uRm9jdXNPdXQgPSB0cnVlXG4gIH0gPSBwcm9wcztcbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgcmVmcyxcbiAgICBub2RlSWQsXG4gICAgb25PcGVuQ2hhbmdlLFxuICAgIGV2ZW50cyxcbiAgICBkYXRhUmVmLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICBkb21SZWZlcmVuY2UsXG4gICAgICBmbG9hdGluZ1xuICAgIH1cbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IGlnbm9yZUluaXRpYWxGb2N1cyA9IHR5cGVvZiBpbml0aWFsRm9jdXMgPT09ICdudW1iZXInICYmIGluaXRpYWxGb2N1cyA8IDA7XG4gIC8vIElmIHRoZSByZWZlcmVuY2UgaXMgYSBjb21ib2JveCBhbmQgaXMgdHlwZWFibGUgKGUuZy4gaW5wdXQvdGV4dGFyZWEpLFxuICAvLyB0aGVyZSBhcmUgZGlmZmVyZW50IGZvY3VzIHNlbWFudGljcy4gVGhlIGd1YXJkcyBzaG91bGQgbm90IGJlIHJlbmRlcmVkLCBidXRcbiAgLy8gYXJpYS1oaWRkZW4gc2hvdWxkIGJlIGFwcGxpZWQgdG8gYWxsIG5vZGVzIHN0aWxsLiBGdXJ0aGVyLCB0aGUgdmlzdWFsbHlcbiAgLy8gaGlkZGVuIGRpc21pc3MgYnV0dG9uIHNob3VsZCBvbmx5IGFwcGVhciBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0LCBub3QgdGhlXG4gIC8vIHN0YXJ0LlxuICBjb25zdCBpc1VudHJhcHBlZFR5cGVhYmxlQ29tYm9ib3ggPSBpc1R5cGVhYmxlQ29tYm9ib3goZG9tUmVmZXJlbmNlKSAmJiBpZ25vcmVJbml0aWFsRm9jdXM7XG5cbiAgLy8gRm9yY2UgdGhlIGd1YXJkcyB0byBiZSByZW5kZXJlZCBpZiB0aGUgYGluZXJ0YCBhdHRyaWJ1dGUgaXMgbm90IHN1cHBvcnRlZC5cbiAgY29uc3QgZ3VhcmRzID0gc3VwcG9ydHNJbmVydCgpID8gX2d1YXJkcyA6IHRydWU7XG4gIGNvbnN0IG9yZGVyUmVmID0gdXNlTGF0ZXN0UmVmKG9yZGVyKTtcbiAgY29uc3QgaW5pdGlhbEZvY3VzUmVmID0gdXNlTGF0ZXN0UmVmKGluaXRpYWxGb2N1cyk7XG4gIGNvbnN0IHJldHVybkZvY3VzUmVmID0gdXNlTGF0ZXN0UmVmKHJldHVybkZvY3VzKTtcbiAgY29uc3QgdHJlZSA9IHVzZUZsb2F0aW5nVHJlZSgpO1xuICBjb25zdCBwb3J0YWxDb250ZXh0ID0gdXNlUG9ydGFsQ29udGV4dCgpO1xuICBjb25zdCBzdGFydERpc21pc3NCdXR0b25SZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGVuZERpc21pc3NCdXR0b25SZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IHByZXZlbnRSZXR1cm5Gb2N1c1JlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGlzUG9pbnRlckRvd25SZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCBpc0luc2lkZVBvcnRhbCA9IHBvcnRhbENvbnRleHQgIT0gbnVsbDtcbiAgY29uc3QgZ2V0VGFiYmFibGVDb250ZW50ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgIGlmIChjb250YWluZXIgPT09IHZvaWQgMCkge1xuICAgICAgY29udGFpbmVyID0gZmxvYXRpbmc7XG4gICAgfVxuICAgIHJldHVybiBjb250YWluZXIgPyB0YWJiYWJsZShjb250YWluZXIsIGdldFRhYmJhYmxlT3B0aW9ucygpKSA6IFtdO1xuICB9LCBbZmxvYXRpbmddKTtcbiAgY29uc3QgZ2V0VGFiYmFibGVFbGVtZW50cyA9IFJlYWN0LnVzZUNhbGxiYWNrKGNvbnRhaW5lciA9PiB7XG4gICAgY29uc3QgY29udGVudCA9IGdldFRhYmJhYmxlQ29udGVudChjb250YWluZXIpO1xuICAgIHJldHVybiBvcmRlclJlZi5jdXJyZW50Lm1hcCh0eXBlID0+IHtcbiAgICAgIGlmIChkb21SZWZlcmVuY2UgJiYgdHlwZSA9PT0gJ3JlZmVyZW5jZScpIHtcbiAgICAgICAgcmV0dXJuIGRvbVJlZmVyZW5jZTtcbiAgICAgIH1cbiAgICAgIGlmIChmbG9hdGluZyAmJiB0eXBlID09PSAnZmxvYXRpbmcnKSB7XG4gICAgICAgIHJldHVybiBmbG9hdGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmZpbHRlcihCb29sZWFuKS5mbGF0KCk7XG4gIH0sIFtkb21SZWZlcmVuY2UsIGZsb2F0aW5nLCBvcmRlclJlZiwgZ2V0VGFiYmFibGVDb250ZW50XSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkIHx8ICFtb2RhbCkgcmV0dXJuO1xuICAgIGZ1bmN0aW9uIG9uS2V5RG93bihldmVudCkge1xuICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ1RhYicpIHtcbiAgICAgICAgLy8gVGhlIGZvY3VzIGd1YXJkcyBoYXZlIG5vdGhpbmcgdG8gZm9jdXMsIHNvIHdlIG5lZWQgdG8gc3RvcCB0aGUgZXZlbnQuXG4gICAgICAgIGlmIChjb250YWlucyhmbG9hdGluZywgYWN0aXZlRWxlbWVudChnZXREb2N1bWVudChmbG9hdGluZykpKSAmJiBnZXRUYWJiYWJsZUNvbnRlbnQoKS5sZW5ndGggPT09IDAgJiYgIWlzVW50cmFwcGVkVHlwZWFibGVDb21ib2JveCkge1xuICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWxzID0gZ2V0VGFiYmFibGVFbGVtZW50cygpO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQoZXZlbnQpO1xuICAgICAgICBpZiAob3JkZXJSZWYuY3VycmVudFswXSA9PT0gJ3JlZmVyZW5jZScgJiYgdGFyZ2V0ID09PSBkb21SZWZlcmVuY2UpIHtcbiAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgZW5xdWV1ZUZvY3VzKGVsc1tlbHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbnF1ZXVlRm9jdXMoZWxzWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yZGVyUmVmLmN1cnJlbnRbMV0gPT09ICdmbG9hdGluZycgJiYgdGFyZ2V0ID09PSBmbG9hdGluZyAmJiBldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgICAgZW5xdWV1ZUZvY3VzKGVsc1swXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZG9jID0gZ2V0RG9jdW1lbnQoZmxvYXRpbmcpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgb25LZXlEb3duKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBvbktleURvd24pO1xuICAgIH07XG4gIH0sIFtkaXNhYmxlZCwgZG9tUmVmZXJlbmNlLCBmbG9hdGluZywgbW9kYWwsIG9yZGVyUmVmLCByZWZzLCBpc1VudHJhcHBlZFR5cGVhYmxlQ29tYm9ib3gsIGdldFRhYmJhYmxlQ29udGVudCwgZ2V0VGFiYmFibGVFbGVtZW50c10pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCB8fCAhY2xvc2VPbkZvY3VzT3V0KSByZXR1cm47XG5cbiAgICAvLyBJbiBTYWZhcmksIGJ1dHRvbnMgbG9zZSBmb2N1cyB3aGVuIHByZXNzaW5nIHRoZW0uXG4gICAgZnVuY3Rpb24gaGFuZGxlUG9pbnRlckRvd24oKSB7XG4gICAgICBpc1BvaW50ZXJEb3duUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlzUG9pbnRlckRvd25SZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUZvY3VzT3V0c2lkZShldmVudCkge1xuICAgICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vdmVkVG9VbnJlbGF0ZWROb2RlID0gIShjb250YWlucyhkb21SZWZlcmVuY2UsIHJlbGF0ZWRUYXJnZXQpIHx8IGNvbnRhaW5zKGZsb2F0aW5nLCByZWxhdGVkVGFyZ2V0KSB8fCBjb250YWlucyhyZWxhdGVkVGFyZ2V0LCBmbG9hdGluZykgfHwgY29udGFpbnMocG9ydGFsQ29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogcG9ydGFsQ29udGV4dC5wb3J0YWxOb2RlLCByZWxhdGVkVGFyZ2V0KSB8fCByZWxhdGVkVGFyZ2V0ICE9IG51bGwgJiYgcmVsYXRlZFRhcmdldC5oYXNBdHRyaWJ1dGUoY3JlYXRlQXR0cmlidXRlKCdmb2N1cy1ndWFyZCcpKSB8fCB0cmVlICYmIChnZXRDaGlsZHJlbih0cmVlLm5vZGVzUmVmLmN1cnJlbnQsIG5vZGVJZCkuZmluZChub2RlID0+IHtcbiAgICAgICAgICB2YXIgX25vZGUkY29udGV4dCwgX25vZGUkY29udGV4dDI7XG4gICAgICAgICAgcmV0dXJuIGNvbnRhaW5zKChfbm9kZSRjb250ZXh0ID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dC5lbGVtZW50cy5mbG9hdGluZywgcmVsYXRlZFRhcmdldCkgfHwgY29udGFpbnMoKF9ub2RlJGNvbnRleHQyID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dDIuZWxlbWVudHMuZG9tUmVmZXJlbmNlLCByZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgfSkgfHwgZ2V0QW5jZXN0b3JzKHRyZWUubm9kZXNSZWYuY3VycmVudCwgbm9kZUlkKS5maW5kKG5vZGUgPT4ge1xuICAgICAgICAgIHZhciBfbm9kZSRjb250ZXh0MywgX25vZGUkY29udGV4dDQ7XG4gICAgICAgICAgcmV0dXJuICgoX25vZGUkY29udGV4dDMgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0My5lbGVtZW50cy5mbG9hdGluZykgPT09IHJlbGF0ZWRUYXJnZXQgfHwgKChfbm9kZSRjb250ZXh0NCA9IG5vZGUuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGNvbnRleHQ0LmVsZW1lbnRzLmRvbVJlZmVyZW5jZSkgPT09IHJlbGF0ZWRUYXJnZXQ7XG4gICAgICAgIH0pKSk7XG5cbiAgICAgICAgLy8gRm9jdXMgZGlkIG5vdCBtb3ZlIGluc2lkZSB0aGUgZmxvYXRpbmcgdHJlZSwgYW5kIHRoZXJlIGFyZSBubyB0YWJiYWJsZVxuICAgICAgICAvLyBwb3J0YWwgZ3VhcmRzIHRvIGhhbmRsZSBjbG9zaW5nLlxuICAgICAgICBpZiAocmVsYXRlZFRhcmdldCAmJiBtb3ZlZFRvVW5yZWxhdGVkTm9kZSAmJiAhaXNQb2ludGVyRG93blJlZi5jdXJyZW50ICYmXG4gICAgICAgIC8vIEZpeCBSZWFjdCAxOCBTdHJpY3QgTW9kZSByZXR1cm5Gb2N1cyBkdWUgdG8gZG91YmxlIHJlbmRlcmluZy5cbiAgICAgICAgcmVsYXRlZFRhcmdldCAhPT0gZ2V0UHJldmlvdXNseUZvY3VzZWRFbGVtZW50KCkpIHtcbiAgICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZmxvYXRpbmcgJiYgaXNIVE1MRWxlbWVudChkb21SZWZlcmVuY2UpKSB7XG4gICAgICBkb21SZWZlcmVuY2UuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBoYW5kbGVGb2N1c091dHNpZGUpO1xuICAgICAgZG9tUmVmZXJlbmNlLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgaGFuZGxlUG9pbnRlckRvd24pO1xuICAgICAgIW1vZGFsICYmIGZsb2F0aW5nLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgaGFuZGxlRm9jdXNPdXRzaWRlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRvbVJlZmVyZW5jZS5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIGhhbmRsZUZvY3VzT3V0c2lkZSk7XG4gICAgICAgIGRvbVJlZmVyZW5jZS5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIGhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgICAgIW1vZGFsICYmIGZsb2F0aW5nLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgaGFuZGxlRm9jdXNPdXRzaWRlKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbZGlzYWJsZWQsIGRvbVJlZmVyZW5jZSwgZmxvYXRpbmcsIG1vZGFsLCBub2RlSWQsIHRyZWUsIHBvcnRhbENvbnRleHQsIG9uT3BlbkNoYW5nZSwgY2xvc2VPbkZvY3VzT3V0XSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdmFyIF9wb3J0YWxDb250ZXh0JHBvcnRhbDtcbiAgICBpZiAoZGlzYWJsZWQpIHJldHVybjtcblxuICAgIC8vIERvbid0IGhpZGUgcG9ydGFscyBuZXN0ZWQgd2l0aGluIHRoZSBwYXJlbnQgcG9ydGFsLlxuICAgIGNvbnN0IHBvcnRhbE5vZGVzID0gQXJyYXkuZnJvbSgocG9ydGFsQ29udGV4dCA9PSBudWxsIHx8IChfcG9ydGFsQ29udGV4dCRwb3J0YWwgPSBwb3J0YWxDb250ZXh0LnBvcnRhbE5vZGUpID09IG51bGwgPyB2b2lkIDAgOiBfcG9ydGFsQ29udGV4dCRwb3J0YWwucXVlcnlTZWxlY3RvckFsbChcIltcIiArIGNyZWF0ZUF0dHJpYnV0ZSgncG9ydGFsJykgKyBcIl1cIikpIHx8IFtdKTtcbiAgICBpZiAoZmxvYXRpbmcpIHtcbiAgICAgIGNvbnN0IGluc2lkZUVsZW1lbnRzID0gW2Zsb2F0aW5nLCAuLi5wb3J0YWxOb2Rlcywgc3RhcnREaXNtaXNzQnV0dG9uUmVmLmN1cnJlbnQsIGVuZERpc21pc3NCdXR0b25SZWYuY3VycmVudCwgb3JkZXJSZWYuY3VycmVudC5pbmNsdWRlcygncmVmZXJlbmNlJykgfHwgaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94ID8gZG9tUmVmZXJlbmNlIDogbnVsbF0uZmlsdGVyKHggPT4geCAhPSBudWxsKTtcbiAgICAgIGNvbnN0IGNsZWFudXAgPSBtb2RhbCB8fCBpc1VudHJhcHBlZFR5cGVhYmxlQ29tYm9ib3ggPyBtYXJrT3RoZXJzKGluc2lkZUVsZW1lbnRzLCBndWFyZHMsICFndWFyZHMpIDogbWFya090aGVycyhpbnNpZGVFbGVtZW50cyk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW2Rpc2FibGVkLCBkb21SZWZlcmVuY2UsIGZsb2F0aW5nLCBtb2RhbCwgb3JkZXJSZWYsIHBvcnRhbENvbnRleHQsIGlzVW50cmFwcGVkVHlwZWFibGVDb21ib2JveCwgZ3VhcmRzXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgIWZsb2F0aW5nKSByZXR1cm47XG4gICAgY29uc3QgZG9jID0gZ2V0RG9jdW1lbnQoZmxvYXRpbmcpO1xuICAgIGNvbnN0IHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQoZG9jKTtcblxuICAgIC8vIFdhaXQgZm9yIGFueSBsYXlvdXQgZWZmZWN0IHN0YXRlIHNldHRlcnMgdG8gZXhlY3V0ZSB0byBzZXQgYHRhYkluZGV4YC5cbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICBjb25zdCBmb2N1c2FibGVFbGVtZW50cyA9IGdldFRhYmJhYmxlRWxlbWVudHMoZmxvYXRpbmcpO1xuICAgICAgY29uc3QgaW5pdGlhbEZvY3VzVmFsdWUgPSBpbml0aWFsRm9jdXNSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IGVsVG9Gb2N1cyA9ICh0eXBlb2YgaW5pdGlhbEZvY3VzVmFsdWUgPT09ICdudW1iZXInID8gZm9jdXNhYmxlRWxlbWVudHNbaW5pdGlhbEZvY3VzVmFsdWVdIDogaW5pdGlhbEZvY3VzVmFsdWUuY3VycmVudCkgfHwgZmxvYXRpbmc7XG4gICAgICBjb25zdCBmb2N1c0FscmVhZHlJbnNpZGVGbG9hdGluZ0VsID0gY29udGFpbnMoZmxvYXRpbmcsIHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCk7XG4gICAgICBpZiAoIWlnbm9yZUluaXRpYWxGb2N1cyAmJiAhZm9jdXNBbHJlYWR5SW5zaWRlRmxvYXRpbmdFbCAmJiBvcGVuKSB7XG4gICAgICAgIGVucXVldWVGb2N1cyhlbFRvRm9jdXMsIHtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiBlbFRvRm9jdXMgPT09IGZsb2F0aW5nXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBbZGlzYWJsZWQsIG9wZW4sIGZsb2F0aW5nLCBpZ25vcmVJbml0aWFsRm9jdXMsIGdldFRhYmJhYmxlRWxlbWVudHMsIGluaXRpYWxGb2N1c1JlZl0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkIHx8ICFmbG9hdGluZykgcmV0dXJuO1xuICAgIGxldCBwcmV2ZW50UmV0dXJuRm9jdXNTY3JvbGwgPSBmYWxzZTtcbiAgICBjb25zdCBkb2MgPSBnZXREb2N1bWVudChmbG9hdGluZyk7XG4gICAgY29uc3QgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50ID0gYWN0aXZlRWxlbWVudChkb2MpO1xuICAgIGNvbnN0IGNvbnRleHREYXRhID0gZGF0YVJlZi5jdXJyZW50O1xuICAgIGFkZFByZXZpb3VzbHlGb2N1c2VkRWxlbWVudChwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQpO1xuXG4gICAgLy8gRGlzbWlzc2luZyB2aWEgb3V0c2lkZSBwcmVzcyBzaG91bGQgYWx3YXlzIGlnbm9yZSBgcmV0dXJuRm9jdXNgIHRvXG4gICAgLy8gcHJldmVudCB1bndhbnRlZCBzY3JvbGxpbmcuXG4gICAgZnVuY3Rpb24gb25PcGVuQ2hhbmdlKF9yZWYpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIHJlYXNvbixcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIG5lc3RlZFxuICAgICAgfSA9IF9yZWY7XG4gICAgICBpZiAocmVhc29uID09PSAnZXNjYXBlLWtleScgJiYgcmVmcy5kb21SZWZlcmVuY2UuY3VycmVudCkge1xuICAgICAgICBhZGRQcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQocmVmcy5kb21SZWZlcmVuY2UuY3VycmVudCk7XG4gICAgICB9XG4gICAgICBpZiAocmVhc29uID09PSAnaG92ZXInICYmIGV2ZW50LnR5cGUgPT09ICdtb3VzZWxlYXZlJykge1xuICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocmVhc29uICE9PSAnb3V0c2lkZS1wcmVzcycpIHJldHVybjtcbiAgICAgIGlmIChuZXN0ZWQpIHtcbiAgICAgICAgcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgcHJldmVudFJldHVybkZvY3VzU2Nyb2xsID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXZlbnRSZXR1cm5Gb2N1c1JlZi5jdXJyZW50ID0gIShpc1ZpcnR1YWxDbGljayhldmVudCkgfHwgaXNWaXJ0dWFsUG9pbnRlckV2ZW50KGV2ZW50KSk7XG4gICAgICB9XG4gICAgfVxuICAgIGV2ZW50cy5vbignb3BlbmNoYW5nZScsIG9uT3BlbkNoYW5nZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGV2ZW50cy5vZmYoJ29wZW5jaGFuZ2UnLCBvbk9wZW5DaGFuZ2UpO1xuICAgICAgY29uc3QgYWN0aXZlRWwgPSBhY3RpdmVFbGVtZW50KGRvYyk7XG4gICAgICBjb25zdCBpc0ZvY3VzSW5zaWRlRmxvYXRpbmdUcmVlID0gY29udGFpbnMoZmxvYXRpbmcsIGFjdGl2ZUVsKSB8fCB0cmVlICYmIGdldENoaWxkcmVuKHRyZWUubm9kZXNSZWYuY3VycmVudCwgbm9kZUlkKS5zb21lKG5vZGUgPT4ge1xuICAgICAgICB2YXIgX25vZGUkY29udGV4dDU7XG4gICAgICAgIHJldHVybiBjb250YWlucygoX25vZGUkY29udGV4dDUgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0NS5lbGVtZW50cy5mbG9hdGluZywgYWN0aXZlRWwpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBzaG91bGRGb2N1c1JlZmVyZW5jZSA9IGlzRm9jdXNJbnNpZGVGbG9hdGluZ1RyZWUgfHwgY29udGV4dERhdGEub3BlbkV2ZW50ICYmIFsnY2xpY2snLCAnbW91c2Vkb3duJ10uaW5jbHVkZXMoY29udGV4dERhdGEub3BlbkV2ZW50LnR5cGUpO1xuICAgICAgaWYgKHNob3VsZEZvY3VzUmVmZXJlbmNlICYmIHJlZnMuZG9tUmVmZXJlbmNlLmN1cnJlbnQpIHtcbiAgICAgICAgYWRkUHJldmlvdXNseUZvY3VzZWRFbGVtZW50KHJlZnMuZG9tUmVmZXJlbmNlLmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmV0dXJuRWxlbWVudCA9IGdldFByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCgpO1xuICAgICAgaWYgKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgICAgcmV0dXJuRm9jdXNSZWYuY3VycmVudCAmJiAhcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgJiYgaXNIVE1MRWxlbWVudChyZXR1cm5FbGVtZW50KSAmJiAoXG4gICAgICAvLyBJZiB0aGUgZm9jdXMgbW92ZWQgc29tZXdoZXJlIGVsc2UgYWZ0ZXIgbW91bnQsIGF2b2lkIHJldHVybmluZyBmb2N1c1xuICAgICAgLy8gc2luY2UgaXQgbGlrZWx5IGVudGVyZWQgYSBkaWZmZXJlbnQgZWxlbWVudCB3aGljaCBzaG91bGQgYmVcbiAgICAgIC8vIHJlc3BlY3RlZDogaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8yNjA3XG4gICAgICByZXR1cm5FbGVtZW50ICE9PSBhY3RpdmVFbCAmJiBhY3RpdmVFbCAhPT0gZG9jLmJvZHkgPyBpc0ZvY3VzSW5zaWRlRmxvYXRpbmdUcmVlIDogdHJ1ZSkpIHtcbiAgICAgICAgZW5xdWV1ZUZvY3VzKHJldHVybkVsZW1lbnQsIHtcbiAgICAgICAgICAvLyBXaGVuIGRpc21pc3NpbmcgbmVzdGVkIGZsb2F0aW5nIGVsZW1lbnRzLCBieSB0aGUgdGltZSB0aGUgckFGIGhhc1xuICAgICAgICAgIC8vIGV4ZWN1dGVkLCB0aGUgbWVudXMgd2lsbCBhbGwgaGF2ZSBiZWVuIHVubW91bnRlZC4gV2hlbiB0aGV5IHRyeVxuICAgICAgICAgIC8vIHRvIGdldCBmb2N1c2VkLCB0aGUgY2FsbHMgZ2V0IGlnbm9yZWQg4oCUIGxlYXZpbmcgdGhlIHJvb3RcbiAgICAgICAgICAvLyByZWZlcmVuY2UgZm9jdXNlZCBhcyBkZXNpcmVkLlxuICAgICAgICAgIGNhbmNlbFByZXZpb3VzOiBmYWxzZSxcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiBwcmV2ZW50UmV0dXJuRm9jdXNTY3JvbGxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2Rpc2FibGVkLCBmbG9hdGluZywgcmV0dXJuRm9jdXNSZWYsIGRhdGFSZWYsIHJlZnMsIGV2ZW50cywgdHJlZSwgbm9kZUlkXSk7XG5cbiAgLy8gU3luY2hyb25pemUgdGhlIGBjb250ZXh0YCAmIGBtb2RhbGAgdmFsdWUgdG8gdGhlIEZsb2F0aW5nUG9ydGFsIGNvbnRleHQuXG4gIC8vIEl0IHdpbGwgZGVjaWRlIHdoZXRoZXIgb3Igbm90IGl0IG5lZWRzIHRvIHJlbmRlciBpdHMgb3duIGd1YXJkcy5cbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCB8fCAhcG9ydGFsQ29udGV4dCkgcmV0dXJuO1xuICAgIHBvcnRhbENvbnRleHQuc2V0Rm9jdXNNYW5hZ2VyU3RhdGUoe1xuICAgICAgbW9kYWwsXG4gICAgICBjbG9zZU9uRm9jdXNPdXQsXG4gICAgICBvcGVuLFxuICAgICAgb25PcGVuQ2hhbmdlLFxuICAgICAgcmVmc1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBwb3J0YWxDb250ZXh0LnNldEZvY3VzTWFuYWdlclN0YXRlKG51bGwpO1xuICAgIH07XG4gIH0sIFtkaXNhYmxlZCwgcG9ydGFsQ29udGV4dCwgbW9kYWwsIG9wZW4sIG9uT3BlbkNoYW5nZSwgcmVmcywgY2xvc2VPbkZvY3VzT3V0XSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgIWZsb2F0aW5nIHx8IHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAnZnVuY3Rpb24nIHx8IGlnbm9yZUluaXRpYWxGb2N1cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVNdXRhdGlvbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHRhYkluZGV4ID0gZmxvYXRpbmcuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgICAgaWYgKG9yZGVyUmVmLmN1cnJlbnQuaW5jbHVkZXMoJ2Zsb2F0aW5nJykgfHwgYWN0aXZlRWxlbWVudChnZXREb2N1bWVudChmbG9hdGluZykpICE9PSByZWZzLmRvbVJlZmVyZW5jZS5jdXJyZW50ICYmIGdldFRhYmJhYmxlQ29udGVudCgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAodGFiSW5kZXggIT09ICcwJykge1xuICAgICAgICAgIGZsb2F0aW5nLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnMCcpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRhYkluZGV4ICE9PSAnLTEnKSB7XG4gICAgICAgIGZsb2F0aW5nLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGhhbmRsZU11dGF0aW9uKCk7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihoYW5kbGVNdXRhdGlvbik7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShmbG9hdGluZywge1xuICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgIGF0dHJpYnV0ZXM6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH07XG4gIH0sIFtkaXNhYmxlZCwgZmxvYXRpbmcsIHJlZnMsIG9yZGVyUmVmLCBnZXRUYWJiYWJsZUNvbnRlbnQsIGlnbm9yZUluaXRpYWxGb2N1c10pO1xuICBmdW5jdGlvbiByZW5kZXJEaXNtaXNzQnV0dG9uKGxvY2F0aW9uKSB7XG4gICAgaWYgKGRpc2FibGVkIHx8ICF2aXN1YWxseUhpZGRlbkRpc21pc3MgfHwgIW1vZGFsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFZpc3VhbGx5SGlkZGVuRGlzbWlzcywge1xuICAgICAgcmVmOiBsb2NhdGlvbiA9PT0gJ3N0YXJ0JyA/IHN0YXJ0RGlzbWlzc0J1dHRvblJlZiA6IGVuZERpc21pc3NCdXR0b25SZWYsXG4gICAgICBvbkNsaWNrOiBldmVudCA9PiBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50KVxuICAgIH0sIHR5cGVvZiB2aXN1YWxseUhpZGRlbkRpc21pc3MgPT09ICdzdHJpbmcnID8gdmlzdWFsbHlIaWRkZW5EaXNtaXNzIDogJ0Rpc21pc3MnKTtcbiAgfVxuICBjb25zdCBzaG91bGRSZW5kZXJHdWFyZHMgPSAhZGlzYWJsZWQgJiYgZ3VhcmRzICYmIChpc0luc2lkZVBvcnRhbCB8fCBtb2RhbCk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgc2hvdWxkUmVuZGVyR3VhcmRzICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvY3VzR3VhcmQsIHtcbiAgICBcImRhdGEtdHlwZVwiOiBcImluc2lkZVwiLFxuICAgIHJlZjogcG9ydGFsQ29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogcG9ydGFsQ29udGV4dC5iZWZvcmVJbnNpZGVSZWYsXG4gICAgb25Gb2N1czogZXZlbnQgPT4ge1xuICAgICAgaWYgKG1vZGFsKSB7XG4gICAgICAgIGNvbnN0IGVscyA9IGdldFRhYmJhYmxlRWxlbWVudHMoKTtcbiAgICAgICAgZW5xdWV1ZUZvY3VzKG9yZGVyWzBdID09PSAncmVmZXJlbmNlJyA/IGVsc1swXSA6IGVsc1tlbHMubGVuZ3RoIC0gMV0pO1xuICAgICAgfSBlbHNlIGlmIChwb3J0YWxDb250ZXh0ICE9IG51bGwgJiYgcG9ydGFsQ29udGV4dC5wcmVzZXJ2ZVRhYk9yZGVyICYmIHBvcnRhbENvbnRleHQucG9ydGFsTm9kZSkge1xuICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBpZiAoaXNPdXRzaWRlRXZlbnQoZXZlbnQsIHBvcnRhbENvbnRleHQucG9ydGFsTm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBuZXh0VGFiYmFibGUgPSBnZXROZXh0VGFiYmFibGUoKSB8fCBkb21SZWZlcmVuY2U7XG4gICAgICAgICAgbmV4dFRhYmJhYmxlID09IG51bGwgfHwgbmV4dFRhYmJhYmxlLmZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9wb3J0YWxDb250ZXh0JGJlZm9yZTtcbiAgICAgICAgICAoX3BvcnRhbENvbnRleHQkYmVmb3JlID0gcG9ydGFsQ29udGV4dC5iZWZvcmVPdXRzaWRlUmVmLmN1cnJlbnQpID09IG51bGwgfHwgX3BvcnRhbENvbnRleHQkYmVmb3JlLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pLCAhaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94ICYmIHJlbmRlckRpc21pc3NCdXR0b24oJ3N0YXJ0JyksIGNoaWxkcmVuLCByZW5kZXJEaXNtaXNzQnV0dG9uKCdlbmQnKSwgc2hvdWxkUmVuZGVyR3VhcmRzICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvY3VzR3VhcmQsIHtcbiAgICBcImRhdGEtdHlwZVwiOiBcImluc2lkZVwiLFxuICAgIHJlZjogcG9ydGFsQ29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogcG9ydGFsQ29udGV4dC5hZnRlckluc2lkZVJlZixcbiAgICBvbkZvY3VzOiBldmVudCA9PiB7XG4gICAgICBpZiAobW9kYWwpIHtcbiAgICAgICAgZW5xdWV1ZUZvY3VzKGdldFRhYmJhYmxlRWxlbWVudHMoKVswXSk7XG4gICAgICB9IGVsc2UgaWYgKHBvcnRhbENvbnRleHQgIT0gbnVsbCAmJiBwb3J0YWxDb250ZXh0LnByZXNlcnZlVGFiT3JkZXIgJiYgcG9ydGFsQ29udGV4dC5wb3J0YWxOb2RlKSB7XG4gICAgICAgIGlmIChjbG9zZU9uRm9jdXNPdXQpIHtcbiAgICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzT3V0c2lkZUV2ZW50KGV2ZW50LCBwb3J0YWxDb250ZXh0LnBvcnRhbE5vZGUpKSB7XG4gICAgICAgICAgY29uc3QgcHJldlRhYmJhYmxlID0gZ2V0UHJldmlvdXNUYWJiYWJsZSgpIHx8IGRvbVJlZmVyZW5jZTtcbiAgICAgICAgICBwcmV2VGFiYmFibGUgPT0gbnVsbCB8fCBwcmV2VGFiYmFibGUuZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX3BvcnRhbENvbnRleHQkYWZ0ZXJPO1xuICAgICAgICAgIChfcG9ydGFsQ29udGV4dCRhZnRlck8gPSBwb3J0YWxDb250ZXh0LmFmdGVyT3V0c2lkZVJlZi5jdXJyZW50KSA9PSBudWxsIHx8IF9wb3J0YWxDb250ZXh0JGFmdGVyTy5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KSk7XG59XG5cbmNvbnN0IGFjdGl2ZUxvY2tzID0gLyojX19QVVJFX18qL25ldyBTZXQoKTtcblxuLyoqXG4gKiBQcm92aWRlcyBiYXNlIHN0eWxpbmcgZm9yIGEgZml4ZWQgb3ZlcmxheSBlbGVtZW50IHRvIGRpbSBjb250ZW50IG9yIGJsb2NrXG4gKiBwb2ludGVyIGV2ZW50cyBiZWhpbmQgYSBmbG9hdGluZyBlbGVtZW50LlxuICogSXQncyBhIHJlZ3VsYXIgYDxkaXY+YCwgc28gaXQgY2FuIGJlIHN0eWxlZCB2aWEgYW55IENTUyBzb2x1dGlvbiB5b3UgcHJlZmVyLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nT3ZlcmxheVxuICovXG5jb25zdCBGbG9hdGluZ092ZXJsYXkgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBGbG9hdGluZ092ZXJsYXkoX3JlZiwgcmVmKSB7XG4gIGxldCB7XG4gICAgbG9ja1Njcm9sbCA9IGZhbHNlLFxuICAgIC4uLnJlc3RcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGxvY2tJZCA9IHVzZUlkKCk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoIWxvY2tTY3JvbGwpIHJldHVybjtcbiAgICBhY3RpdmVMb2Nrcy5hZGQobG9ja0lkKTtcbiAgICBjb25zdCBpc0lPUyA9IC9pUChob25lfGFkfG9kKXxpT1MvLnRlc3QoZ2V0UGxhdGZvcm0oKSk7XG4gICAgY29uc3QgYm9keVN0eWxlID0gZG9jdW1lbnQuYm9keS5zdHlsZTtcbiAgICAvLyBSVEwgPGJvZHk+IHNjcm9sbGJhclxuICAgIGNvbnN0IHNjcm9sbGJhclggPSBNYXRoLnJvdW5kKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0KSArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgIGNvbnN0IHBhZGRpbmdQcm9wID0gc2Nyb2xsYmFyWCA/ICdwYWRkaW5nTGVmdCcgOiAncGFkZGluZ1JpZ2h0JztcbiAgICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgIGNvbnN0IHNjcm9sbFggPSBib2R5U3R5bGUubGVmdCA/IHBhcnNlRmxvYXQoYm9keVN0eWxlLmxlZnQpIDogd2luZG93LnBhZ2VYT2Zmc2V0O1xuICAgIGNvbnN0IHNjcm9sbFkgPSBib2R5U3R5bGUudG9wID8gcGFyc2VGbG9hdChib2R5U3R5bGUudG9wKSA6IHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICBib2R5U3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICBpZiAoc2Nyb2xsYmFyV2lkdGgpIHtcbiAgICAgIGJvZHlTdHlsZVtwYWRkaW5nUHJvcF0gPSBzY3JvbGxiYXJXaWR0aCArIFwicHhcIjtcbiAgICB9XG5cbiAgICAvLyBPbmx5IGlPUyBkb2Vzbid0IHJlc3BlY3QgYG92ZXJmbG93OiBoaWRkZW5gIG9uIGRvY3VtZW50LmJvZHksIGFuZCB0aGlzXG4gICAgLy8gdGVjaG5pcXVlIGhhcyBmZXdlciBzaWRlIGVmZmVjdHMuXG4gICAgaWYgKGlzSU9TKSB7XG4gICAgICB2YXIgX3dpbmRvdyR2aXN1YWxWaWV3cG9yLCBfd2luZG93JHZpc3VhbFZpZXdwb3IyO1xuICAgICAgLy8gaU9TIDEyIGRvZXMgbm90IHN1cHBvcnQgYHZpc3VhbFZpZXdwb3J0YC5cbiAgICAgIGNvbnN0IG9mZnNldExlZnQgPSAoKF93aW5kb3ckdmlzdWFsVmlld3BvciA9IHdpbmRvdy52aXN1YWxWaWV3cG9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3ckdmlzdWFsVmlld3Bvci5vZmZzZXRMZWZ0KSB8fCAwO1xuICAgICAgY29uc3Qgb2Zmc2V0VG9wID0gKChfd2luZG93JHZpc3VhbFZpZXdwb3IyID0gd2luZG93LnZpc3VhbFZpZXdwb3J0KSA9PSBudWxsID8gdm9pZCAwIDogX3dpbmRvdyR2aXN1YWxWaWV3cG9yMi5vZmZzZXRUb3ApIHx8IDA7XG4gICAgICBPYmplY3QuYXNzaWduKGJvZHlTdHlsZSwge1xuICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgdG9wOiAtKHNjcm9sbFkgLSBNYXRoLmZsb29yKG9mZnNldFRvcCkpICsgXCJweFwiLFxuICAgICAgICBsZWZ0OiAtKHNjcm9sbFggLSBNYXRoLmZsb29yKG9mZnNldExlZnQpKSArIFwicHhcIixcbiAgICAgICAgcmlnaHQ6ICcwJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBhY3RpdmVMb2Nrcy5kZWxldGUobG9ja0lkKTtcbiAgICAgIGlmIChhY3RpdmVMb2Nrcy5zaXplID09PSAwKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYm9keVN0eWxlLCB7XG4gICAgICAgICAgb3ZlcmZsb3c6ICcnLFxuICAgICAgICAgIFtwYWRkaW5nUHJvcF06ICcnXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNJT1MpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGJvZHlTdHlsZSwge1xuICAgICAgICAgICAgcG9zaXRpb246ICcnLFxuICAgICAgICAgICAgdG9wOiAnJyxcbiAgICAgICAgICAgIGxlZnQ6ICcnLFxuICAgICAgICAgICAgcmlnaHQ6ICcnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgd2luZG93LnNjcm9sbFRvKHNjcm9sbFgsIHNjcm9sbFkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2xvY2tJZCwgbG9ja1Njcm9sbF0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe1xuICAgIHJlZjogcmVmXG4gIH0sIHJlc3QsIHtcbiAgICBzdHlsZToge1xuICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICBvdmVyZmxvdzogJ2F1dG8nLFxuICAgICAgdG9wOiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgLi4ucmVzdC5zdHlsZVxuICAgIH1cbiAgfSkpO1xufSk7XG5cbmZ1bmN0aW9uIGlzQnV0dG9uVGFyZ2V0KGV2ZW50KSB7XG4gIHJldHVybiBpc0hUTUxFbGVtZW50KGV2ZW50LnRhcmdldCkgJiYgZXZlbnQudGFyZ2V0LnRhZ05hbWUgPT09ICdCVVRUT04nO1xufVxuZnVuY3Rpb24gaXNTcGFjZUlnbm9yZWQoZWxlbWVudCkge1xuICByZXR1cm4gaXNUeXBlYWJsZUVsZW1lbnQoZWxlbWVudCk7XG59XG4vKipcbiAqIE9wZW5zIG9yIGNsb3NlcyB0aGUgZmxvYXRpbmcgZWxlbWVudCB3aGVuIGNsaWNraW5nIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VDbGlja1xuICovXG5mdW5jdGlvbiB1c2VDbGljayhjb250ZXh0LCBwcm9wcykge1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgb25PcGVuQ2hhbmdlLFxuICAgIGRhdGFSZWYsXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIGRvbVJlZmVyZW5jZVxuICAgIH1cbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBlbmFibGVkID0gdHJ1ZSxcbiAgICBldmVudDogZXZlbnRPcHRpb24gPSAnY2xpY2snLFxuICAgIHRvZ2dsZSA9IHRydWUsXG4gICAgaWdub3JlTW91c2UgPSBmYWxzZSxcbiAgICBrZXlib2FyZEhhbmRsZXJzID0gdHJ1ZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHBvaW50ZXJUeXBlUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGNvbnN0IGRpZEtleURvd25SZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm4ge307XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICBvblBvaW50ZXJEb3duKGV2ZW50KSB7XG4gICAgICAgICAgcG9pbnRlclR5cGVSZWYuY3VycmVudCA9IGV2ZW50LnBvaW50ZXJUeXBlO1xuICAgICAgICB9LFxuICAgICAgICBvbk1vdXNlRG93bihldmVudCkge1xuICAgICAgICAgIC8vIElnbm9yZSBhbGwgYnV0dG9ucyBleGNlcHQgZm9yIHRoZSBcIm1haW5cIiBidXR0b24uXG4gICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01vdXNlRXZlbnQvYnV0dG9uXG4gICAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNNb3VzZUxpa2VQb2ludGVyVHlwZShwb2ludGVyVHlwZVJlZi5jdXJyZW50LCB0cnVlKSAmJiBpZ25vcmVNb3VzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXZlbnRPcHRpb24gPT09ICdjbGljaycpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wZW4gJiYgdG9nZ2xlICYmIChkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50ID8gZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudC50eXBlID09PSAnbW91c2Vkb3duJyA6IHRydWUpKSB7XG4gICAgICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnY2xpY2snKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUHJldmVudCBzdGVhbGluZyBmb2N1cyBmcm9tIHRoZSBmbG9hdGluZyBlbGVtZW50XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnY2xpY2snKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgICBpZiAoZXZlbnRPcHRpb24gPT09ICdtb3VzZWRvd24nICYmIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc01vdXNlTGlrZVBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQsIHRydWUpICYmIGlnbm9yZU1vdXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcGVuICYmIHRvZ2dsZSAmJiAoZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCA/IGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQudHlwZSA9PT0gJ2NsaWNrJyA6IHRydWUpKSB7XG4gICAgICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnY2xpY2snKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnY2xpY2snKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uS2V5RG93bihldmVudCkge1xuICAgICAgICAgIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgfHwgIWtleWJvYXJkSGFuZGxlcnMgfHwgaXNCdXR0b25UYXJnZXQoZXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChldmVudC5rZXkgPT09ICcgJyAmJiAhaXNTcGFjZUlnbm9yZWQoZG9tUmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgLy8gUHJldmVudCBzY3JvbGxpbmdcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBkaWRLZXlEb3duUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnRW50ZXInKSB7XG4gICAgICAgICAgICBpZiAob3BlbiAmJiB0b2dnbGUpIHtcbiAgICAgICAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudCwgJ2NsaWNrJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSwgZXZlbnQubmF0aXZlRXZlbnQsICdjbGljaycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25LZXlVcChldmVudCkge1xuICAgICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkIHx8ICFrZXlib2FyZEhhbmRsZXJzIHx8IGlzQnV0dG9uVGFyZ2V0KGV2ZW50KSB8fCBpc1NwYWNlSWdub3JlZChkb21SZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChldmVudC5rZXkgPT09ICcgJyAmJiBkaWRLZXlEb3duUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGRpZEtleURvd25SZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG9wZW4gJiYgdG9nZ2xlKSB7XG4gICAgICAgICAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQubmF0aXZlRXZlbnQsICdjbGljaycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnY2xpY2snKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZW5hYmxlZCwgZGF0YVJlZiwgZXZlbnRPcHRpb24sIGlnbm9yZU1vdXNlLCBrZXlib2FyZEhhbmRsZXJzLCBkb21SZWZlcmVuY2UsIHRvZ2dsZSwgb3Blbiwgb25PcGVuQ2hhbmdlXSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVZpcnR1YWxFbGVtZW50KGRvbVJlZiwgZGF0YSkge1xuICBsZXQgb2Zmc2V0WCA9IG51bGw7XG4gIGxldCBvZmZzZXRZID0gbnVsbDtcbiAgbGV0IGlzQXV0b1VwZGF0ZUV2ZW50ID0gZmFsc2U7XG4gIHJldHVybiB7XG4gICAgY29udGV4dEVsZW1lbnQ6IGRvbVJlZi5jdXJyZW50IHx8IHVuZGVmaW5lZCxcbiAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB7XG4gICAgICB2YXIgX2RvbVJlZiRjdXJyZW50LCBfZGF0YSRkYXRhUmVmJGN1cnJlbnQ7XG4gICAgICBjb25zdCBkb21SZWN0ID0gKChfZG9tUmVmJGN1cnJlbnQgPSBkb21SZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kb21SZWYkY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkgfHwge1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9O1xuICAgICAgY29uc3QgaXNYQXhpcyA9IGRhdGEuYXhpcyA9PT0gJ3gnIHx8IGRhdGEuYXhpcyA9PT0gJ2JvdGgnO1xuICAgICAgY29uc3QgaXNZQXhpcyA9IGRhdGEuYXhpcyA9PT0gJ3knIHx8IGRhdGEuYXhpcyA9PT0gJ2JvdGgnO1xuICAgICAgY29uc3QgY2FuVHJhY2tDdXJzb3JPbkF1dG9VcGRhdGUgPSBbJ21vdXNlZW50ZXInLCAnbW91c2Vtb3ZlJ10uaW5jbHVkZXMoKChfZGF0YSRkYXRhUmVmJGN1cnJlbnQgPSBkYXRhLmRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YSRkYXRhUmVmJGN1cnJlbnQudHlwZSkgfHwgJycpICYmIGRhdGEucG9pbnRlclR5cGUgIT09ICd0b3VjaCc7XG4gICAgICBsZXQgd2lkdGggPSBkb21SZWN0LndpZHRoO1xuICAgICAgbGV0IGhlaWdodCA9IGRvbVJlY3QuaGVpZ2h0O1xuICAgICAgbGV0IHggPSBkb21SZWN0Lng7XG4gICAgICBsZXQgeSA9IGRvbVJlY3QueTtcbiAgICAgIGlmIChvZmZzZXRYID09IG51bGwgJiYgZGF0YS54ICYmIGlzWEF4aXMpIHtcbiAgICAgICAgb2Zmc2V0WCA9IGRvbVJlY3QueCAtIGRhdGEueDtcbiAgICAgIH1cbiAgICAgIGlmIChvZmZzZXRZID09IG51bGwgJiYgZGF0YS55ICYmIGlzWUF4aXMpIHtcbiAgICAgICAgb2Zmc2V0WSA9IGRvbVJlY3QueSAtIGRhdGEueTtcbiAgICAgIH1cbiAgICAgIHggLT0gb2Zmc2V0WCB8fCAwO1xuICAgICAgeSAtPSBvZmZzZXRZIHx8IDA7XG4gICAgICB3aWR0aCA9IDA7XG4gICAgICBoZWlnaHQgPSAwO1xuICAgICAgaWYgKCFpc0F1dG9VcGRhdGVFdmVudCB8fCBjYW5UcmFja0N1cnNvck9uQXV0b1VwZGF0ZSkge1xuICAgICAgICB3aWR0aCA9IGRhdGEuYXhpcyA9PT0gJ3knID8gZG9tUmVjdC53aWR0aCA6IDA7XG4gICAgICAgIGhlaWdodCA9IGRhdGEuYXhpcyA9PT0gJ3gnID8gZG9tUmVjdC5oZWlnaHQgOiAwO1xuICAgICAgICB4ID0gaXNYQXhpcyAmJiBkYXRhLnggIT0gbnVsbCA/IGRhdGEueCA6IHg7XG4gICAgICAgIHkgPSBpc1lBeGlzICYmIGRhdGEueSAhPSBudWxsID8gZGF0YS55IDogeTtcbiAgICAgIH0gZWxzZSBpZiAoaXNBdXRvVXBkYXRlRXZlbnQgJiYgIWNhblRyYWNrQ3Vyc29yT25BdXRvVXBkYXRlKSB7XG4gICAgICAgIGhlaWdodCA9IGRhdGEuYXhpcyA9PT0gJ3gnID8gZG9tUmVjdC5oZWlnaHQgOiBoZWlnaHQ7XG4gICAgICAgIHdpZHRoID0gZGF0YS5heGlzID09PSAneScgPyBkb21SZWN0LndpZHRoIDogd2lkdGg7XG4gICAgICB9XG4gICAgICBpc0F1dG9VcGRhdGVFdmVudCA9IHRydWU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICB0b3A6IHksXG4gICAgICAgIHJpZ2h0OiB4ICsgd2lkdGgsXG4gICAgICAgIGJvdHRvbTogeSArIGhlaWdodCxcbiAgICAgICAgbGVmdDogeFxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBpc01vdXNlQmFzZWRFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQgIT0gbnVsbCAmJiBldmVudC5jbGllbnRYICE9IG51bGw7XG59XG4vKipcbiAqIFBvc2l0aW9ucyB0aGUgZmxvYXRpbmcgZWxlbWVudCByZWxhdGl2ZSB0byBhIGNsaWVudCBwb2ludCAoaW4gdGhlIHZpZXdwb3J0KSxcbiAqIHN1Y2ggYXMgdGhlIG1vdXNlIHBvc2l0aW9uLiBCeSBkZWZhdWx0LCBpdCBmb2xsb3dzIHRoZSBtb3VzZSBjdXJzb3IuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlQ2xpZW50UG9pbnRcbiAqL1xuZnVuY3Rpb24gdXNlQ2xpZW50UG9pbnQoY29udGV4dCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIHJlZnMsXG4gICAgZGF0YVJlZixcbiAgICBlbGVtZW50czoge1xuICAgICAgZmxvYXRpbmdcbiAgICB9XG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgYXhpcyA9ICdib3RoJyxcbiAgICB4ID0gbnVsbCxcbiAgICB5ID0gbnVsbFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGluaXRpYWxSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCBjbGVhbnVwTGlzdGVuZXJSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IFtwb2ludGVyVHlwZSwgc2V0UG9pbnRlclR5cGVdID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgY29uc3QgW3JlYWN0aXZlLCBzZXRSZWFjdGl2ZV0gPSBSZWFjdC51c2VTdGF0ZShbXSk7XG4gIGNvbnN0IHNldFJlZmVyZW5jZSA9IHVzZUVmZmVjdEV2ZW50KCh4LCB5KSA9PiB7XG4gICAgaWYgKGluaXRpYWxSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgLy8gUHJldmVudCBzZXR0aW5nIGlmIHRoZSBvcGVuIGV2ZW50IHdhcyBub3QgYSBtb3VzZS1saWtlIG9uZVxuICAgIC8vIChlLmcuIGZvY3VzIHRvIG9wZW4sIHRoZW4gaG92ZXIgb3ZlciB0aGUgcmVmZXJlbmNlIGVsZW1lbnQpLlxuICAgIC8vIE9ubHkgYXBwbHkgaWYgdGhlIGV2ZW50IGV4aXN0cy5cbiAgICBpZiAoZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCAmJiAhaXNNb3VzZUJhc2VkRXZlbnQoZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVmcy5zZXRQb3NpdGlvblJlZmVyZW5jZShjcmVhdGVWaXJ0dWFsRWxlbWVudChyZWZzLmRvbVJlZmVyZW5jZSwge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBheGlzLFxuICAgICAgZGF0YVJlZixcbiAgICAgIHBvaW50ZXJUeXBlXG4gICAgfSkpO1xuICB9KTtcbiAgY29uc3QgaGFuZGxlUmVmZXJlbmNlRW50ZXJPck1vdmUgPSB1c2VFZmZlY3RFdmVudChldmVudCA9PiB7XG4gICAgaWYgKHggIT0gbnVsbCB8fCB5ICE9IG51bGwpIHJldHVybjtcbiAgICBpZiAoIW9wZW4pIHtcbiAgICAgIHNldFJlZmVyZW5jZShldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICB9IGVsc2UgaWYgKCFjbGVhbnVwTGlzdGVuZXJSZWYuY3VycmVudCkge1xuICAgICAgLy8gSWYgdGhlcmUncyBubyBjbGVhbnVwLCB0aGVyZSdzIG5vIGxpc3RlbmVyLCBidXQgd2Ugd2FudCB0byBlbnN1cmVcbiAgICAgIC8vIHdlIGFkZCB0aGUgbGlzdGVuZXIgaWYgdGhlIGN1cnNvciBsYW5kZWQgb24gdGhlIGZsb2F0aW5nIGVsZW1lbnQgYW5kXG4gICAgICAvLyB0aGVuIGJhY2sgb24gdGhlIHJlZmVyZW5jZSAoaS5lLiBpdCdzIGludGVyYWN0aXZlKS5cbiAgICAgIHNldFJlYWN0aXZlKFtdKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIElmIHRoZSBwb2ludGVyIGlzIGEgbW91c2UtbGlrZSBwb2ludGVyLCB3ZSB3YW50IHRvIGNvbnRpbnVlIGZvbGxvd2luZyB0aGVcbiAgLy8gbW91c2UgZXZlbiBpZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBpcyB0cmFuc2l0aW9uaW5nIG91dC4gT24gdG91Y2hcbiAgLy8gZGV2aWNlcywgdGhpcyBpcyB1bmRlc2lyYWJsZSBiZWNhdXNlIHRoZSBmbG9hdGluZyBlbGVtZW50IHdpbGwgbW92ZSB0b1xuICAvLyB0aGUgZGlzbWlzc2FsIHRvdWNoIHBvaW50LlxuICBjb25zdCBvcGVuQ2hlY2sgPSBpc01vdXNlTGlrZVBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlKSA/IGZsb2F0aW5nIDogb3BlbjtcbiAgY29uc3QgYWRkTGlzdGVuZXIgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgLy8gRXhwbGljaXRseSBzcGVjaWZpZWQgYHhgL2B5YCBjb29yZGluYXRlcyBzaG91bGRuJ3QgYWRkIGEgbGlzdGVuZXIuXG4gICAgaWYgKCFvcGVuQ2hlY2sgfHwgIWVuYWJsZWQgfHwgeCAhPSBudWxsIHx8IHkgIT0gbnVsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhyZWZzLmZsb2F0aW5nLmN1cnJlbnQpO1xuICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZShldmVudCkge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGV2ZW50KTtcbiAgICAgIGlmICghY29udGFpbnMocmVmcy5mbG9hdGluZy5jdXJyZW50LCB0YXJnZXQpKSB7XG4gICAgICAgIHNldFJlZmVyZW5jZShldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgICBjbGVhbnVwTGlzdGVuZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCB8fCBpc01vdXNlQmFzZWRFdmVudChkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50KSkge1xuICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZU1vdXNlTW92ZSk7XG4gICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgICAgY2xlYW51cExpc3RlbmVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfTtcbiAgICAgIGNsZWFudXBMaXN0ZW5lclJlZi5jdXJyZW50ID0gY2xlYW51cDtcbiAgICAgIHJldHVybiBjbGVhbnVwO1xuICAgIH1cbiAgICByZWZzLnNldFBvc2l0aW9uUmVmZXJlbmNlKHJlZnMuZG9tUmVmZXJlbmNlLmN1cnJlbnQpO1xuICB9LCBbZGF0YVJlZiwgZW5hYmxlZCwgb3BlbkNoZWNrLCByZWZzLCBzZXRSZWZlcmVuY2UsIHgsIHldKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gYWRkTGlzdGVuZXIoKTtcbiAgfSwgW2FkZExpc3RlbmVyLCByZWFjdGl2ZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChlbmFibGVkICYmICFmbG9hdGluZykge1xuICAgICAgaW5pdGlhbFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgZmxvYXRpbmddKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQgJiYgb3Blbikge1xuICAgICAgaW5pdGlhbFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9XG4gIH0sIFtlbmFibGVkLCBvcGVuXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoZW5hYmxlZCAmJiAoeCAhPSBudWxsIHx8IHkgIT0gbnVsbCkpIHtcbiAgICAgIGluaXRpYWxSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgc2V0UmVmZXJlbmNlKHgsIHkpO1xuICAgIH1cbiAgfSwgW2VuYWJsZWQsIHgsIHksIHNldFJlZmVyZW5jZV0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm4ge307XG4gICAgZnVuY3Rpb24gc2V0UG9pbnRlclR5cGVSZWYoX3JlZikge1xuICAgICAgbGV0IHtcbiAgICAgICAgcG9pbnRlclR5cGVcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgc2V0UG9pbnRlclR5cGUocG9pbnRlclR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVmZXJlbmNlOiB7XG4gICAgICAgIG9uUG9pbnRlckRvd246IHNldFBvaW50ZXJUeXBlUmVmLFxuICAgICAgICBvblBvaW50ZXJFbnRlcjogc2V0UG9pbnRlclR5cGVSZWYsXG4gICAgICAgIG9uTW91c2VNb3ZlOiBoYW5kbGVSZWZlcmVuY2VFbnRlck9yTW92ZSxcbiAgICAgICAgb25Nb3VzZUVudGVyOiBoYW5kbGVSZWZlcmVuY2VFbnRlck9yTW92ZVxuICAgICAgfVxuICAgIH07XG4gIH0sIFtlbmFibGVkLCBoYW5kbGVSZWZlcmVuY2VFbnRlck9yTW92ZV0pO1xufVxuXG5jb25zdCBidWJibGVIYW5kbGVyS2V5cyA9IHtcbiAgcG9pbnRlcmRvd246ICdvblBvaW50ZXJEb3duJyxcbiAgbW91c2Vkb3duOiAnb25Nb3VzZURvd24nLFxuICBjbGljazogJ29uQ2xpY2snXG59O1xuY29uc3QgY2FwdHVyZUhhbmRsZXJLZXlzID0ge1xuICBwb2ludGVyZG93bjogJ29uUG9pbnRlckRvd25DYXB0dXJlJyxcbiAgbW91c2Vkb3duOiAnb25Nb3VzZURvd25DYXB0dXJlJyxcbiAgY2xpY2s6ICdvbkNsaWNrQ2FwdHVyZSdcbn07XG5jb25zdCBub3JtYWxpemVQcm9wID0gbm9ybWFsaXphYmxlID0+IHtcbiAgdmFyIF9ub3JtYWxpemFibGUkZXNjYXBlSywgX25vcm1hbGl6YWJsZSRvdXRzaWRlO1xuICByZXR1cm4ge1xuICAgIGVzY2FwZUtleTogdHlwZW9mIG5vcm1hbGl6YWJsZSA9PT0gJ2Jvb2xlYW4nID8gbm9ybWFsaXphYmxlIDogKF9ub3JtYWxpemFibGUkZXNjYXBlSyA9IG5vcm1hbGl6YWJsZSA9PSBudWxsID8gdm9pZCAwIDogbm9ybWFsaXphYmxlLmVzY2FwZUtleSkgIT0gbnVsbCA/IF9ub3JtYWxpemFibGUkZXNjYXBlSyA6IGZhbHNlLFxuICAgIG91dHNpZGVQcmVzczogdHlwZW9mIG5vcm1hbGl6YWJsZSA9PT0gJ2Jvb2xlYW4nID8gbm9ybWFsaXphYmxlIDogKF9ub3JtYWxpemFibGUkb3V0c2lkZSA9IG5vcm1hbGl6YWJsZSA9PSBudWxsID8gdm9pZCAwIDogbm9ybWFsaXphYmxlLm91dHNpZGVQcmVzcykgIT0gbnVsbCA/IF9ub3JtYWxpemFibGUkb3V0c2lkZSA6IHRydWVcbiAgfTtcbn07XG4vKipcbiAqIENsb3NlcyB0aGUgZmxvYXRpbmcgZWxlbWVudCB3aGVuIGEgZGlzbWlzc2FsIGlzIHJlcXVlc3RlZCDigJQgYnkgZGVmYXVsdCwgd2hlblxuICogdGhlIHVzZXIgcHJlc3NlcyB0aGUgYGVzY2FwZWAga2V5IG9yIG91dHNpZGUgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlRGlzbWlzc1xuICovXG5mdW5jdGlvbiB1c2VEaXNtaXNzKGNvbnRleHQsIHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBvbk9wZW5DaGFuZ2UsXG4gICAgbm9kZUlkLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICByZWZlcmVuY2UsXG4gICAgICBkb21SZWZlcmVuY2UsXG4gICAgICBmbG9hdGluZ1xuICAgIH0sXG4gICAgZGF0YVJlZlxuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIGVzY2FwZUtleSA9IHRydWUsXG4gICAgb3V0c2lkZVByZXNzOiB1bnN0YWJsZV9vdXRzaWRlUHJlc3MgPSB0cnVlLFxuICAgIG91dHNpZGVQcmVzc0V2ZW50ID0gJ3BvaW50ZXJkb3duJyxcbiAgICByZWZlcmVuY2VQcmVzcyA9IGZhbHNlLFxuICAgIHJlZmVyZW5jZVByZXNzRXZlbnQgPSAncG9pbnRlcmRvd24nLFxuICAgIGFuY2VzdG9yU2Nyb2xsID0gZmFsc2UsXG4gICAgYnViYmxlcyxcbiAgICBjYXB0dXJlXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgdHJlZSA9IHVzZUZsb2F0aW5nVHJlZSgpO1xuICBjb25zdCBvdXRzaWRlUHJlc3NGbiA9IHVzZUVmZmVjdEV2ZW50KHR5cGVvZiB1bnN0YWJsZV9vdXRzaWRlUHJlc3MgPT09ICdmdW5jdGlvbicgPyB1bnN0YWJsZV9vdXRzaWRlUHJlc3MgOiAoKSA9PiBmYWxzZSk7XG4gIGNvbnN0IG91dHNpZGVQcmVzcyA9IHR5cGVvZiB1bnN0YWJsZV9vdXRzaWRlUHJlc3MgPT09ICdmdW5jdGlvbicgPyBvdXRzaWRlUHJlc3NGbiA6IHVuc3RhYmxlX291dHNpZGVQcmVzcztcbiAgY29uc3QgaW5zaWRlUmVhY3RUcmVlUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgZW5kZWRPclN0YXJ0ZWRJbnNpZGVSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCB7XG4gICAgZXNjYXBlS2V5OiBlc2NhcGVLZXlCdWJibGVzLFxuICAgIG91dHNpZGVQcmVzczogb3V0c2lkZVByZXNzQnViYmxlc1xuICB9ID0gbm9ybWFsaXplUHJvcChidWJibGVzKTtcbiAgY29uc3Qge1xuICAgIGVzY2FwZUtleTogZXNjYXBlS2V5Q2FwdHVyZSxcbiAgICBvdXRzaWRlUHJlc3M6IG91dHNpZGVQcmVzc0NhcHR1cmVcbiAgfSA9IG5vcm1hbGl6ZVByb3AoY2FwdHVyZSk7XG4gIGNvbnN0IGNsb3NlT25Fc2NhcGVLZXlEb3duID0gdXNlRWZmZWN0RXZlbnQoZXZlbnQgPT4ge1xuICAgIGlmICghb3BlbiB8fCAhZW5hYmxlZCB8fCAhZXNjYXBlS2V5IHx8IGV2ZW50LmtleSAhPT0gJ0VzY2FwZScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0cmVlID8gZ2V0Q2hpbGRyZW4odHJlZS5ub2Rlc1JlZi5jdXJyZW50LCBub2RlSWQpIDogW107XG4gICAgaWYgKCFlc2NhcGVLZXlCdWJibGVzKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBzaG91bGREaXNtaXNzID0gdHJ1ZTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgdmFyIF9jaGlsZCRjb250ZXh0O1xuICAgICAgICAgIGlmICgoX2NoaWxkJGNvbnRleHQgPSBjaGlsZC5jb250ZXh0KSAhPSBudWxsICYmIF9jaGlsZCRjb250ZXh0Lm9wZW4gJiYgIWNoaWxkLmNvbnRleHQuZGF0YVJlZi5jdXJyZW50Ll9fZXNjYXBlS2V5QnViYmxlcykge1xuICAgICAgICAgICAgc2hvdWxkRGlzbWlzcyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghc2hvdWxkRGlzbWlzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGlzUmVhY3RFdmVudChldmVudCkgPyBldmVudC5uYXRpdmVFdmVudCA6IGV2ZW50LCAnZXNjYXBlLWtleScpO1xuICB9KTtcbiAgY29uc3QgY2xvc2VPbkVzY2FwZUtleURvd25DYXB0dXJlID0gdXNlRWZmZWN0RXZlbnQoZXZlbnQgPT4ge1xuICAgIHZhciBfZ2V0VGFyZ2V0MjtcbiAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHZhciBfZ2V0VGFyZ2V0O1xuICAgICAgY2xvc2VPbkVzY2FwZUtleURvd24oZXZlbnQpO1xuICAgICAgKF9nZXRUYXJnZXQgPSBnZXRUYXJnZXQoZXZlbnQpKSA9PSBudWxsIHx8IF9nZXRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIChfZ2V0VGFyZ2V0MiA9IGdldFRhcmdldChldmVudCkpID09IG51bGwgfHwgX2dldFRhcmdldDIuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGNhbGxiYWNrKTtcbiAgfSk7XG4gIGNvbnN0IGNsb3NlT25QcmVzc091dHNpZGUgPSB1c2VFZmZlY3RFdmVudChldmVudCA9PiB7XG4gICAgLy8gR2l2ZW4gZGV2ZWxvcGVycyBjYW4gc3RvcCB0aGUgcHJvcGFnYXRpb24gb2YgdGhlIHN5bnRoZXRpYyBldmVudCxcbiAgICAvLyB3ZSBjYW4gb25seSBiZSBjb25maWRlbnQgd2l0aCBhIHBvc2l0aXZlIHZhbHVlLlxuICAgIGNvbnN0IGluc2lkZVJlYWN0VHJlZSA9IGluc2lkZVJlYWN0VHJlZVJlZi5jdXJyZW50O1xuICAgIGluc2lkZVJlYWN0VHJlZVJlZi5jdXJyZW50ID0gZmFsc2U7XG5cbiAgICAvLyBXaGVuIGNsaWNrIG91dHNpZGUgaXMgbGF6eSAoYGNsaWNrYCBldmVudCksIGhhbmRsZSBkcmFnZ2luZy5cbiAgICAvLyBEb24ndCBjbG9zZSBpZjpcbiAgICAvLyAtIFRoZSBjbGljayBzdGFydGVkIGluc2lkZSB0aGUgZmxvYXRpbmcgZWxlbWVudC5cbiAgICAvLyAtIFRoZSBjbGljayBlbmRlZCBpbnNpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gICAgY29uc3QgZW5kZWRPclN0YXJ0ZWRJbnNpZGUgPSBlbmRlZE9yU3RhcnRlZEluc2lkZVJlZi5jdXJyZW50O1xuICAgIGVuZGVkT3JTdGFydGVkSW5zaWRlUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICBpZiAob3V0c2lkZVByZXNzRXZlbnQgPT09ICdjbGljaycgJiYgZW5kZWRPclN0YXJ0ZWRJbnNpZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGluc2lkZVJlYWN0VHJlZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG91dHNpZGVQcmVzcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhb3V0c2lkZVByZXNzKGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQoZXZlbnQpO1xuICAgIGNvbnN0IGluZXJ0U2VsZWN0b3IgPSBcIltcIiArIGNyZWF0ZUF0dHJpYnV0ZSgnaW5lcnQnKSArIFwiXVwiO1xuICAgIGNvbnN0IG1hcmtlcnMgPSBnZXREb2N1bWVudChmbG9hdGluZykucXVlcnlTZWxlY3RvckFsbChpbmVydFNlbGVjdG9yKTtcbiAgICBsZXQgdGFyZ2V0Um9vdEFuY2VzdG9yID0gaXNFbGVtZW50KHRhcmdldCkgPyB0YXJnZXQgOiBudWxsO1xuICAgIHdoaWxlICh0YXJnZXRSb290QW5jZXN0b3IgJiYgIWlzTGFzdFRyYXZlcnNhYmxlTm9kZSh0YXJnZXRSb290QW5jZXN0b3IpKSB7XG4gICAgICBjb25zdCBuZXh0UGFyZW50ID0gZ2V0UGFyZW50Tm9kZSh0YXJnZXRSb290QW5jZXN0b3IpO1xuICAgICAgaWYgKGlzTGFzdFRyYXZlcnNhYmxlTm9kZShuZXh0UGFyZW50KSB8fCAhaXNFbGVtZW50KG5leHRQYXJlbnQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0Um9vdEFuY2VzdG9yID0gbmV4dFBhcmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgY2xpY2sgb2NjdXJyZWQgb24gYSB0aGlyZC1wYXJ0eSBlbGVtZW50IGluamVjdGVkIGFmdGVyIHRoZVxuICAgIC8vIGZsb2F0aW5nIGVsZW1lbnQgcmVuZGVyZWQuXG4gICAgaWYgKG1hcmtlcnMubGVuZ3RoICYmIGlzRWxlbWVudCh0YXJnZXQpICYmICFpc1Jvb3RFbGVtZW50KHRhcmdldCkgJiZcbiAgICAvLyBDbGlja2VkIG9uIGEgZGlyZWN0IGFuY2VzdG9yIChlLmcuIEZsb2F0aW5nT3ZlcmxheSkuXG4gICAgIWNvbnRhaW5zKHRhcmdldCwgZmxvYXRpbmcpICYmXG4gICAgLy8gSWYgdGhlIHRhcmdldCByb290IGVsZW1lbnQgY29udGFpbnMgbm9uZSBvZiB0aGUgbWFya2VycywgdGhlbiB0aGVcbiAgICAvLyBlbGVtZW50IHdhcyBpbmplY3RlZCBhZnRlciB0aGUgZmxvYXRpbmcgZWxlbWVudCByZW5kZXJlZC5cbiAgICBBcnJheS5mcm9tKG1hcmtlcnMpLmV2ZXJ5KG1hcmtlciA9PiAhY29udGFpbnModGFyZ2V0Um9vdEFuY2VzdG9yLCBtYXJrZXIpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoZSBjbGljayBvY2N1cnJlZCBvbiB0aGUgc2Nyb2xsYmFyXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQodGFyZ2V0KSAmJiBmbG9hdGluZykge1xuICAgICAgLy8gSW4gRmlyZWZveCwgYHRhcmdldC5zY3JvbGxXaWR0aCA+IHRhcmdldC5jbGllbnRXaWR0aGAgZm9yIGlubGluZVxuICAgICAgLy8gZWxlbWVudHMuXG4gICAgICBjb25zdCBjYW5TY3JvbGxYID0gdGFyZ2V0LmNsaWVudFdpZHRoID4gMCAmJiB0YXJnZXQuc2Nyb2xsV2lkdGggPiB0YXJnZXQuY2xpZW50V2lkdGg7XG4gICAgICBjb25zdCBjYW5TY3JvbGxZID0gdGFyZ2V0LmNsaWVudEhlaWdodCA+IDAgJiYgdGFyZ2V0LnNjcm9sbEhlaWdodCA+IHRhcmdldC5jbGllbnRIZWlnaHQ7XG4gICAgICBsZXQgeENvbmQgPSBjYW5TY3JvbGxZICYmIGV2ZW50Lm9mZnNldFggPiB0YXJnZXQuY2xpZW50V2lkdGg7XG5cbiAgICAgIC8vIEluIHNvbWUgYnJvd3NlcnMgaXQgaXMgcG9zc2libGUgdG8gY2hhbmdlIHRoZSA8Ym9keT4gKG9yIHdpbmRvdylcbiAgICAgIC8vIHNjcm9sbGJhciB0byB0aGUgbGVmdCBzaWRlLCBidXQgaXMgdmVyeSByYXJlIGFuZCBpcyBkaWZmaWN1bHQgdG9cbiAgICAgIC8vIGNoZWNrIGZvci4gUGx1cywgZm9yIG1vZGFsIGRpYWxvZ3Mgd2l0aCBiYWNrZHJvcHMsIGl0IGlzIG1vcmVcbiAgICAgIC8vIGltcG9ydGFudCB0aGF0IHRoZSBiYWNrZHJvcCBpcyBjaGVja2VkIGJ1dCBub3Qgc28gbXVjaCB0aGUgd2luZG93LlxuICAgICAgaWYgKGNhblNjcm9sbFkpIHtcbiAgICAgICAgY29uc3QgaXNSVEwgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCkuZGlyZWN0aW9uID09PSAncnRsJztcbiAgICAgICAgaWYgKGlzUlRMKSB7XG4gICAgICAgICAgeENvbmQgPSBldmVudC5vZmZzZXRYIDw9IHRhcmdldC5vZmZzZXRXaWR0aCAtIHRhcmdldC5jbGllbnRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHhDb25kIHx8IGNhblNjcm9sbFggJiYgZXZlbnQub2Zmc2V0WSA+IHRhcmdldC5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0YXJnZXRJc0luc2lkZUNoaWxkcmVuID0gdHJlZSAmJiBnZXRDaGlsZHJlbih0cmVlLm5vZGVzUmVmLmN1cnJlbnQsIG5vZGVJZCkuc29tZShub2RlID0+IHtcbiAgICAgIHZhciBfbm9kZSRjb250ZXh0O1xuICAgICAgcmV0dXJuIGlzRXZlbnRUYXJnZXRXaXRoaW4oZXZlbnQsIChfbm9kZSRjb250ZXh0ID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dC5lbGVtZW50cy5mbG9hdGluZyk7XG4gICAgfSk7XG4gICAgaWYgKGlzRXZlbnRUYXJnZXRXaXRoaW4oZXZlbnQsIGZsb2F0aW5nKSB8fCBpc0V2ZW50VGFyZ2V0V2l0aGluKGV2ZW50LCBkb21SZWZlcmVuY2UpIHx8IHRhcmdldElzSW5zaWRlQ2hpbGRyZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0cmVlID8gZ2V0Q2hpbGRyZW4odHJlZS5ub2Rlc1JlZi5jdXJyZW50LCBub2RlSWQpIDogW107XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGxldCBzaG91bGREaXNtaXNzID0gdHJ1ZTtcbiAgICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICB2YXIgX2NoaWxkJGNvbnRleHQyO1xuICAgICAgICBpZiAoKF9jaGlsZCRjb250ZXh0MiA9IGNoaWxkLmNvbnRleHQpICE9IG51bGwgJiYgX2NoaWxkJGNvbnRleHQyLm9wZW4gJiYgIWNoaWxkLmNvbnRleHQuZGF0YVJlZi5jdXJyZW50Ll9fb3V0c2lkZVByZXNzQnViYmxlcykge1xuICAgICAgICAgIHNob3VsZERpc21pc3MgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFzaG91bGREaXNtaXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudCwgJ291dHNpZGUtcHJlc3MnKTtcbiAgfSk7XG4gIGNvbnN0IGNsb3NlT25QcmVzc091dHNpZGVDYXB0dXJlID0gdXNlRWZmZWN0RXZlbnQoZXZlbnQgPT4ge1xuICAgIHZhciBfZ2V0VGFyZ2V0NDtcbiAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHZhciBfZ2V0VGFyZ2V0MztcbiAgICAgIGNsb3NlT25QcmVzc091dHNpZGUoZXZlbnQpO1xuICAgICAgKF9nZXRUYXJnZXQzID0gZ2V0VGFyZ2V0KGV2ZW50KSkgPT0gbnVsbCB8fCBfZ2V0VGFyZ2V0My5yZW1vdmVFdmVudExpc3RlbmVyKG91dHNpZGVQcmVzc0V2ZW50LCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAoX2dldFRhcmdldDQgPSBnZXRUYXJnZXQoZXZlbnQpKSA9PSBudWxsIHx8IF9nZXRUYXJnZXQ0LmFkZEV2ZW50TGlzdGVuZXIob3V0c2lkZVByZXNzRXZlbnQsIGNhbGxiYWNrKTtcbiAgfSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFvcGVuIHx8ICFlbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRhdGFSZWYuY3VycmVudC5fX2VzY2FwZUtleUJ1YmJsZXMgPSBlc2NhcGVLZXlCdWJibGVzO1xuICAgIGRhdGFSZWYuY3VycmVudC5fX291dHNpZGVQcmVzc0J1YmJsZXMgPSBvdXRzaWRlUHJlc3NCdWJibGVzO1xuICAgIGZ1bmN0aW9uIG9uU2Nyb2xsKGV2ZW50KSB7XG4gICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50LCAnYW5jZXN0b3Itc2Nyb2xsJyk7XG4gICAgfVxuICAgIGNvbnN0IGRvYyA9IGdldERvY3VtZW50KGZsb2F0aW5nKTtcbiAgICBlc2NhcGVLZXkgJiYgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBlc2NhcGVLZXlDYXB0dXJlID8gY2xvc2VPbkVzY2FwZUtleURvd25DYXB0dXJlIDogY2xvc2VPbkVzY2FwZUtleURvd24sIGVzY2FwZUtleUNhcHR1cmUpO1xuICAgIG91dHNpZGVQcmVzcyAmJiBkb2MuYWRkRXZlbnRMaXN0ZW5lcihvdXRzaWRlUHJlc3NFdmVudCwgb3V0c2lkZVByZXNzQ2FwdHVyZSA/IGNsb3NlT25QcmVzc091dHNpZGVDYXB0dXJlIDogY2xvc2VPblByZXNzT3V0c2lkZSwgb3V0c2lkZVByZXNzQ2FwdHVyZSk7XG4gICAgbGV0IGFuY2VzdG9ycyA9IFtdO1xuICAgIGlmIChhbmNlc3RvclNjcm9sbCkge1xuICAgICAgaWYgKGlzRWxlbWVudChkb21SZWZlcmVuY2UpKSB7XG4gICAgICAgIGFuY2VzdG9ycyA9IGdldE92ZXJmbG93QW5jZXN0b3JzKGRvbVJlZmVyZW5jZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNFbGVtZW50KGZsb2F0aW5nKSkge1xuICAgICAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMuY29uY2F0KGdldE92ZXJmbG93QW5jZXN0b3JzKGZsb2F0aW5nKSk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzRWxlbWVudChyZWZlcmVuY2UpICYmIHJlZmVyZW5jZSAmJiByZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpIHtcbiAgICAgICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzLmNvbmNhdChnZXRPdmVyZmxvd0FuY2VzdG9ycyhyZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZ25vcmUgdGhlIHZpc3VhbCB2aWV3cG9ydCBmb3Igc2Nyb2xsaW5nIGRpc21pc3NhbCAoYWxsb3cgcGluY2gtem9vbSlcbiAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMuZmlsdGVyKGFuY2VzdG9yID0+IHtcbiAgICAgIHZhciBfZG9jJGRlZmF1bHRWaWV3O1xuICAgICAgcmV0dXJuIGFuY2VzdG9yICE9PSAoKF9kb2MkZGVmYXVsdFZpZXcgPSBkb2MuZGVmYXVsdFZpZXcpID09IG51bGwgPyB2b2lkIDAgOiBfZG9jJGRlZmF1bHRWaWV3LnZpc3VhbFZpZXdwb3J0KTtcbiAgICB9KTtcbiAgICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgICBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvblNjcm9sbCwge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZXNjYXBlS2V5ICYmIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZXNjYXBlS2V5Q2FwdHVyZSA/IGNsb3NlT25Fc2NhcGVLZXlEb3duQ2FwdHVyZSA6IGNsb3NlT25Fc2NhcGVLZXlEb3duLCBlc2NhcGVLZXlDYXB0dXJlKTtcbiAgICAgIG91dHNpZGVQcmVzcyAmJiBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihvdXRzaWRlUHJlc3NFdmVudCwgb3V0c2lkZVByZXNzQ2FwdHVyZSA/IGNsb3NlT25QcmVzc091dHNpZGVDYXB0dXJlIDogY2xvc2VPblByZXNzT3V0c2lkZSwgb3V0c2lkZVByZXNzQ2FwdHVyZSk7XG4gICAgICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgICAgIGFuY2VzdG9yLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uU2Nyb2xsKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0sIFtkYXRhUmVmLCBmbG9hdGluZywgZG9tUmVmZXJlbmNlLCByZWZlcmVuY2UsIGVzY2FwZUtleSwgb3V0c2lkZVByZXNzLCBvdXRzaWRlUHJlc3NFdmVudCwgb3Blbiwgb25PcGVuQ2hhbmdlLCBhbmNlc3RvclNjcm9sbCwgZW5hYmxlZCwgZXNjYXBlS2V5QnViYmxlcywgb3V0c2lkZVByZXNzQnViYmxlcywgY2xvc2VPbkVzY2FwZUtleURvd24sIGVzY2FwZUtleUNhcHR1cmUsIGNsb3NlT25Fc2NhcGVLZXlEb3duQ2FwdHVyZSwgY2xvc2VPblByZXNzT3V0c2lkZSwgb3V0c2lkZVByZXNzQ2FwdHVyZSwgY2xvc2VPblByZXNzT3V0c2lkZUNhcHR1cmVdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpbnNpZGVSZWFjdFRyZWVSZWYuY3VycmVudCA9IGZhbHNlO1xuICB9LCBbb3V0c2lkZVByZXNzLCBvdXRzaWRlUHJlc3NFdmVudF0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgb25LZXlEb3duOiBjbG9zZU9uRXNjYXBlS2V5RG93bixcbiAgICAgICAgW2J1YmJsZUhhbmRsZXJLZXlzW3JlZmVyZW5jZVByZXNzRXZlbnRdXTogZXZlbnQgPT4ge1xuICAgICAgICAgIGlmIChyZWZlcmVuY2VQcmVzcykge1xuICAgICAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudCwgJ3JlZmVyZW5jZS1wcmVzcycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGZsb2F0aW5nOiB7XG4gICAgICAgIG9uS2V5RG93bjogY2xvc2VPbkVzY2FwZUtleURvd24sXG4gICAgICAgIG9uTW91c2VEb3duKCkge1xuICAgICAgICAgIGVuZGVkT3JTdGFydGVkSW5zaWRlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBvbk1vdXNlVXAoKSB7XG4gICAgICAgICAgZW5kZWRPclN0YXJ0ZWRJbnNpZGVSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIFtjYXB0dXJlSGFuZGxlcktleXNbb3V0c2lkZVByZXNzRXZlbnRdXTogKCkgPT4ge1xuICAgICAgICAgIGluc2lkZVJlYWN0VHJlZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0sIFtlbmFibGVkLCByZWZlcmVuY2VQcmVzcywgb3V0c2lkZVByZXNzRXZlbnQsIHJlZmVyZW5jZVByZXNzRXZlbnQsIG9uT3BlbkNoYW5nZSwgY2xvc2VPbkVzY2FwZUtleURvd25dKTtcbn1cblxubGV0IGRldk1lc3NhZ2VTZXQ7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIGRldk1lc3NhZ2VTZXQgPSAvKiNfX1BVUkVfXyovbmV3IFNldCgpO1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gcG9zaXRpb24gYSBmbG9hdGluZyBlbGVtZW50IGFuZCBjb250ZXh0IHRvIGFkZCBpbnRlcmFjdGlvbnMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlRmxvYXRpbmdcbiAqL1xuZnVuY3Rpb24gdXNlRmxvYXRpbmcob3B0aW9ucykge1xuICB2YXIgX29wdGlvbnMkZWxlbWVudHMyO1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuID0gZmFsc2UsXG4gICAgb25PcGVuQ2hhbmdlOiB1bnN0YWJsZV9vbk9wZW5DaGFuZ2UsXG4gICAgbm9kZUlkXG4gIH0gPSBvcHRpb25zO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFyIF9vcHRpb25zJGVsZW1lbnRzO1xuICAgIGNvbnN0IGVyciA9ICdGbG9hdGluZyBVSTogQ2Fubm90IHBhc3MgYSB2aXJ0dWFsIGVsZW1lbnQgdG8gdGhlICcgKyAnYGVsZW1lbnRzLnJlZmVyZW5jZWAgb3B0aW9uLCBhcyBpdCBtdXN0IGJlIGEgcmVhbCBET00gZWxlbWVudC4gJyArICdVc2UgYHJlZnMuc2V0UG9zaXRpb25SZWZlcmVuY2VgIGluc3RlYWQuJztcbiAgICBpZiAoKF9vcHRpb25zJGVsZW1lbnRzID0gb3B0aW9ucy5lbGVtZW50cykgIT0gbnVsbCAmJiBfb3B0aW9ucyRlbGVtZW50cy5yZWZlcmVuY2UgJiYgIWlzRWxlbWVudChvcHRpb25zLmVsZW1lbnRzLnJlZmVyZW5jZSkpIHtcbiAgICAgIHZhciBfZGV2TWVzc2FnZVNldDtcbiAgICAgIGlmICghKChfZGV2TWVzc2FnZVNldCA9IGRldk1lc3NhZ2VTZXQpICE9IG51bGwgJiYgX2Rldk1lc3NhZ2VTZXQuaGFzKGVycikpKSB7XG4gICAgICAgIHZhciBfZGV2TWVzc2FnZVNldDI7XG4gICAgICAgIChfZGV2TWVzc2FnZVNldDIgPSBkZXZNZXNzYWdlU2V0KSA9PSBudWxsIHx8IF9kZXZNZXNzYWdlU2V0Mi5hZGQoZXJyKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBbX2RvbVJlZmVyZW5jZSwgc2V0RG9tUmVmZXJlbmNlXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBkb21SZWZlcmVuY2UgPSAoKF9vcHRpb25zJGVsZW1lbnRzMiA9IG9wdGlvbnMuZWxlbWVudHMpID09IG51bGwgPyB2b2lkIDAgOiBfb3B0aW9ucyRlbGVtZW50czIucmVmZXJlbmNlKSB8fCBfZG9tUmVmZXJlbmNlO1xuICBjb25zdCBwb3NpdGlvbiA9IHVzZUZsb2F0aW5nJDEob3B0aW9ucyk7XG4gIGNvbnN0IHRyZWUgPSB1c2VGbG9hdGluZ1RyZWUoKTtcbiAgY29uc3QgbmVzdGVkID0gdXNlRmxvYXRpbmdQYXJlbnROb2RlSWQoKSAhPSBudWxsO1xuICBjb25zdCBvbk9wZW5DaGFuZ2UgPSB1c2VFZmZlY3RFdmVudCgob3BlbiwgZXZlbnQsIHJlYXNvbikgPT4ge1xuICAgIGlmIChvcGVuKSB7XG4gICAgICBkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50ID0gZXZlbnQ7XG4gICAgfVxuICAgIGV2ZW50cy5lbWl0KCdvcGVuY2hhbmdlJywge1xuICAgICAgb3BlbixcbiAgICAgIGV2ZW50LFxuICAgICAgcmVhc29uLFxuICAgICAgbmVzdGVkXG4gICAgfSk7XG4gICAgdW5zdGFibGVfb25PcGVuQ2hhbmdlID09IG51bGwgfHwgdW5zdGFibGVfb25PcGVuQ2hhbmdlKG9wZW4sIGV2ZW50LCByZWFzb24pO1xuICB9KTtcbiAgY29uc3QgZG9tUmVmZXJlbmNlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBkYXRhUmVmID0gUmVhY3QudXNlUmVmKHt9KTtcbiAgY29uc3QgZXZlbnRzID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gY3JlYXRlUHViU3ViKCkpWzBdO1xuICBjb25zdCBmbG9hdGluZ0lkID0gdXNlSWQoKTtcbiAgY29uc3Qgc2V0UG9zaXRpb25SZWZlcmVuY2UgPSBSZWFjdC51c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBjb25zdCBwb3NpdGlvblJlZmVyZW5jZSA9IGlzRWxlbWVudChub2RlKSA/IHtcbiAgICAgIGdldEJvdW5kaW5nQ2xpZW50UmVjdDogKCkgPT4gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIGNvbnRleHRFbGVtZW50OiBub2RlXG4gICAgfSA6IG5vZGU7XG4gICAgcG9zaXRpb24ucmVmcy5zZXRSZWZlcmVuY2UocG9zaXRpb25SZWZlcmVuY2UpO1xuICB9LCBbcG9zaXRpb24ucmVmc10pO1xuICBjb25zdCBzZXRSZWZlcmVuY2UgPSBSZWFjdC51c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBpZiAoaXNFbGVtZW50KG5vZGUpIHx8IG5vZGUgPT09IG51bGwpIHtcbiAgICAgIGRvbVJlZmVyZW5jZVJlZi5jdXJyZW50ID0gbm9kZTtcbiAgICAgIHNldERvbVJlZmVyZW5jZShub2RlKTtcbiAgICB9XG5cbiAgICAvLyBCYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgcGFzc2luZyBhIHZpcnR1YWwgZWxlbWVudCB0byBgcmVmZXJlbmNlYFxuICAgIC8vIGFmdGVyIGl0IGhhcyBzZXQgdGhlIERPTSByZWZlcmVuY2UuXG4gICAgaWYgKGlzRWxlbWVudChwb3NpdGlvbi5yZWZzLnJlZmVyZW5jZS5jdXJyZW50KSB8fCBwb3NpdGlvbi5yZWZzLnJlZmVyZW5jZS5jdXJyZW50ID09PSBudWxsIHx8XG4gICAgLy8gRG9uJ3QgYWxsb3cgc2V0dGluZyB2aXJ0dWFsIGVsZW1lbnRzIHVzaW5nIHRoZSBvbGQgdGVjaG5pcXVlIGJhY2sgdG9cbiAgICAvLyBgbnVsbGAgdG8gc3VwcG9ydCBgcG9zaXRpb25SZWZlcmVuY2VgICsgYW4gdW5zdGFibGUgYHJlZmVyZW5jZWBcbiAgICAvLyBjYWxsYmFjayByZWYuXG4gICAgbm9kZSAhPT0gbnVsbCAmJiAhaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgICBwb3NpdGlvbi5yZWZzLnNldFJlZmVyZW5jZShub2RlKTtcbiAgICB9XG4gIH0sIFtwb3NpdGlvbi5yZWZzXSk7XG4gIGNvbnN0IHJlZnMgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgLi4ucG9zaXRpb24ucmVmcyxcbiAgICBzZXRSZWZlcmVuY2UsXG4gICAgc2V0UG9zaXRpb25SZWZlcmVuY2UsXG4gICAgZG9tUmVmZXJlbmNlOiBkb21SZWZlcmVuY2VSZWZcbiAgfSksIFtwb3NpdGlvbi5yZWZzLCBzZXRSZWZlcmVuY2UsIHNldFBvc2l0aW9uUmVmZXJlbmNlXSk7XG4gIGNvbnN0IGVsZW1lbnRzID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIC4uLnBvc2l0aW9uLmVsZW1lbnRzLFxuICAgIGRvbVJlZmVyZW5jZTogZG9tUmVmZXJlbmNlXG4gIH0pLCBbcG9zaXRpb24uZWxlbWVudHMsIGRvbVJlZmVyZW5jZV0pO1xuICBjb25zdCBjb250ZXh0ID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIC4uLnBvc2l0aW9uLFxuICAgIHJlZnMsXG4gICAgZWxlbWVudHMsXG4gICAgZGF0YVJlZixcbiAgICBub2RlSWQsXG4gICAgZmxvYXRpbmdJZCxcbiAgICBldmVudHMsXG4gICAgb3BlbixcbiAgICBvbk9wZW5DaGFuZ2VcbiAgfSksIFtwb3NpdGlvbiwgbm9kZUlkLCBmbG9hdGluZ0lkLCBldmVudHMsIG9wZW4sIG9uT3BlbkNoYW5nZSwgcmVmcywgZWxlbWVudHNdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSB0cmVlID09IG51bGwgPyB2b2lkIDAgOiB0cmVlLm5vZGVzUmVmLmN1cnJlbnQuZmluZChub2RlID0+IG5vZGUuaWQgPT09IG5vZGVJZCk7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIG5vZGUuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAuLi5wb3NpdGlvbixcbiAgICBjb250ZXh0LFxuICAgIHJlZnMsXG4gICAgZWxlbWVudHNcbiAgfSksIFtwb3NpdGlvbiwgcmVmcywgZWxlbWVudHMsIGNvbnRleHRdKTtcbn1cblxuLyoqXG4gKiBPcGVucyB0aGUgZmxvYXRpbmcgZWxlbWVudCB3aGlsZSB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgaGFzIGZvY3VzLCBsaWtlIENTU1xuICogYDpmb2N1c2AuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlRm9jdXNcbiAqL1xuZnVuY3Rpb24gdXNlRm9jdXMoY29udGV4dCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIG9uT3BlbkNoYW5nZSxcbiAgICBldmVudHMsXG4gICAgcmVmcyxcbiAgICBlbGVtZW50czoge1xuICAgICAgZmxvYXRpbmcsXG4gICAgICBkb21SZWZlcmVuY2VcbiAgICB9XG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgdmlzaWJsZU9ubHkgPSB0cnVlXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgYmxvY2tGb2N1c1JlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHRpbWVvdXRSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgY29uc3Qga2V5Ym9hcmRNb2RhbGl0eVJlZiA9IFJlYWN0LnVzZVJlZih0cnVlKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgd2luID0gZ2V0V2luZG93KGRvbVJlZmVyZW5jZSk7XG5cbiAgICAvLyBJZiB0aGUgcmVmZXJlbmNlIHdhcyBmb2N1c2VkIGFuZCB0aGUgdXNlciBsZWZ0IHRoZSB0YWIvd2luZG93LCBhbmQgdGhlXG4gICAgLy8gZmxvYXRpbmcgZWxlbWVudCB3YXMgbm90IG9wZW4sIHRoZSBmb2N1cyBzaG91bGQgYmUgYmxvY2tlZCB3aGVuIHRoZXlcbiAgICAvLyByZXR1cm4gdG8gdGhlIHRhYi93aW5kb3cuXG4gICAgZnVuY3Rpb24gb25CbHVyKCkge1xuICAgICAgaWYgKCFvcGVuICYmIGlzSFRNTEVsZW1lbnQoZG9tUmVmZXJlbmNlKSAmJiBkb21SZWZlcmVuY2UgPT09IGFjdGl2ZUVsZW1lbnQoZ2V0RG9jdW1lbnQoZG9tUmVmZXJlbmNlKSkpIHtcbiAgICAgICAgYmxvY2tGb2N1c1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25LZXlEb3duKCkge1xuICAgICAga2V5Ym9hcmRNb2RhbGl0eVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9XG4gICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBvbkJsdXIpO1xuICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgb25LZXlEb3duLCB0cnVlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCBvbkJsdXIpO1xuICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBvbktleURvd24sIHRydWUpO1xuICAgIH07XG4gIH0sIFtmbG9hdGluZywgZG9tUmVmZXJlbmNlLCBvcGVuLCBlbmFibGVkXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uT3BlbkNoYW5nZShfcmVmKSB7XG4gICAgICBsZXQge1xuICAgICAgICByZWFzb25cbiAgICAgIH0gPSBfcmVmO1xuICAgICAgaWYgKHJlYXNvbiA9PT0gJ3JlZmVyZW5jZS1wcmVzcycgfHwgcmVhc29uID09PSAnZXNjYXBlLWtleScpIHtcbiAgICAgICAgYmxvY2tGb2N1c1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZXZlbnRzLm9uKCdvcGVuY2hhbmdlJywgb25PcGVuQ2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZXZlbnRzLm9mZignb3BlbmNoYW5nZScsIG9uT3BlbkNoYW5nZSk7XG4gICAgfTtcbiAgfSwgW2V2ZW50cywgZW5hYmxlZF0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICBvblBvaW50ZXJEb3duKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKGlzVmlydHVhbFBvaW50ZXJFdmVudChldmVudC5uYXRpdmVFdmVudCkpIHJldHVybjtcbiAgICAgICAgICBrZXlib2FyZE1vZGFsaXR5UmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Nb3VzZUxlYXZlKCkge1xuICAgICAgICAgIGJsb2NrRm9jdXNSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBvbkZvY3VzKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKGJsb2NrRm9jdXNSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldChldmVudC5uYXRpdmVFdmVudCk7XG4gICAgICAgICAgaWYgKHZpc2libGVPbmx5ICYmIGlzRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBNYWMgU2FmYXJpIHVucmVsaWFibHkgbWF0Y2hlcyBgOmZvY3VzLXZpc2libGVgIG9uIHRoZSByZWZlcmVuY2VcbiAgICAgICAgICAgICAgLy8gaWYgZm9jdXMgd2FzIG91dHNpZGUgdGhlIHBhZ2UgaW5pdGlhbGx5IC0gdXNlIHRoZSBmYWxsYmFja1xuICAgICAgICAgICAgICAvLyBpbnN0ZWFkLlxuICAgICAgICAgICAgICBpZiAoaXNTYWZhcmkoKSAmJiBpc01hYygpKSB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICBpZiAoIXRhcmdldC5tYXRjaGVzKCc6Zm9jdXMtdmlzaWJsZScpKSByZXR1cm47XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIC8vIE9sZCBicm93c2VycyB3aWxsIHRocm93IGFuIGVycm9yIHdoZW4gdXNpbmcgYDpmb2N1cy12aXNpYmxlYC5cbiAgICAgICAgICAgICAgaWYgKCFrZXlib2FyZE1vZGFsaXR5UmVmLmN1cnJlbnQgJiYgIWlzVHlwZWFibGVFbGVtZW50KHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnZm9jdXMnKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25CbHVyKGV2ZW50KSB7XG4gICAgICAgICAgYmxvY2tGb2N1c1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG5cbiAgICAgICAgICAvLyBIaXQgdGhlIG5vbi1tb2RhbCBmb2N1cyBtYW5hZ2VtZW50IHBvcnRhbCBndWFyZC4gRm9jdXMgd2lsbCBiZVxuICAgICAgICAgIC8vIG1vdmVkIGludG8gdGhlIGZsb2F0aW5nIGVsZW1lbnQgaW1tZWRpYXRlbHkgYWZ0ZXIuXG4gICAgICAgICAgY29uc3QgbW92ZWRUb0ZvY3VzR3VhcmQgPSBpc0VsZW1lbnQocmVsYXRlZFRhcmdldCkgJiYgcmVsYXRlZFRhcmdldC5oYXNBdHRyaWJ1dGUoY3JlYXRlQXR0cmlidXRlKCdmb2N1cy1ndWFyZCcpKSAmJiByZWxhdGVkVGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS10eXBlJykgPT09ICdvdXRzaWRlJztcblxuICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSB3aW5kb3cgYmx1ciBsaXN0ZW5lciB0byBmaXJlLlxuICAgICAgICAgIHRpbWVvdXRSZWYuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZUVsID0gYWN0aXZlRWxlbWVudChkb21SZWZlcmVuY2UgPyBkb21SZWZlcmVuY2Uub3duZXJEb2N1bWVudCA6IGRvY3VtZW50KTtcblxuICAgICAgICAgICAgLy8gRm9jdXMgbGVmdCB0aGUgcGFnZSwga2VlcCBpdCBvcGVuLlxuICAgICAgICAgICAgaWYgKCFyZWxhdGVkVGFyZ2V0ICYmIGFjdGl2ZUVsID09PSBkb21SZWZlcmVuY2UpIHJldHVybjtcblxuICAgICAgICAgICAgLy8gV2hlbiBmb2N1c2luZyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgKGUuZy4gcmVndWxhciBjbGljayksIHRoZW5cbiAgICAgICAgICAgIC8vIGNsaWNraW5nIGludG8gdGhlIGZsb2F0aW5nIGVsZW1lbnQsIHByZXZlbnQgaXQgZnJvbSBoaWRpbmcuXG4gICAgICAgICAgICAvLyBOb3RlOiBpdCBtdXN0IGJlIGZvY3VzYWJsZSwgZS5nLiBgdGFiaW5kZXg9XCItMVwiYC5cbiAgICAgICAgICAgIGlmIChjb250YWlucyhyZWZzLmZsb2F0aW5nLmN1cnJlbnQsIHJlbGF0ZWRUYXJnZXQpIHx8IGNvbnRhaW5zKGRvbVJlZmVyZW5jZSwgcmVsYXRlZFRhcmdldCkgfHwgbW92ZWRUb0ZvY3VzR3VhcmQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudCwgJ2ZvY3VzJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZW5hYmxlZCwgdmlzaWJsZU9ubHksIGRvbVJlZmVyZW5jZSwgcmVmcywgb25PcGVuQ2hhbmdlXSk7XG59XG5cbmNvbnN0IEFDVElWRV9LRVkgPSAnYWN0aXZlJztcbmNvbnN0IFNFTEVDVEVEX0tFWSA9ICdzZWxlY3RlZCc7XG5mdW5jdGlvbiBtZXJnZVByb3BzKHVzZXJQcm9wcywgcHJvcHNMaXN0LCBlbGVtZW50S2V5KSB7XG4gIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgY29uc3QgaXNJdGVtID0gZWxlbWVudEtleSA9PT0gJ2l0ZW0nO1xuICBsZXQgZG9tVXNlclByb3BzID0gdXNlclByb3BzO1xuICBpZiAoaXNJdGVtICYmIHVzZXJQcm9wcykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBjb25zdCB7XG4gICAgICBbQUNUSVZFX0tFWV06IF8sXG4gICAgICBbU0VMRUNURURfS0VZXTogX18sXG4gICAgICAuLi52YWxpZFByb3BzXG4gICAgfSA9IHVzZXJQcm9wcztcbiAgICBkb21Vc2VyUHJvcHMgPSB2YWxpZFByb3BzO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uKGVsZW1lbnRLZXkgPT09ICdmbG9hdGluZycgJiYge1xuICAgICAgdGFiSW5kZXg6IC0xXG4gICAgfSksXG4gICAgLi4uZG9tVXNlclByb3BzLFxuICAgIC4uLnByb3BzTGlzdC5tYXAodmFsdWUgPT4ge1xuICAgICAgY29uc3QgcHJvcHNPckdldFByb3BzID0gdmFsdWUgPyB2YWx1ZVtlbGVtZW50S2V5XSA6IG51bGw7XG4gICAgICBpZiAodHlwZW9mIHByb3BzT3JHZXRQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdXNlclByb3BzID8gcHJvcHNPckdldFByb3BzKHVzZXJQcm9wcykgOiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3BzT3JHZXRQcm9wcztcbiAgICB9KS5jb25jYXQodXNlclByb3BzKS5yZWR1Y2UoKGFjYywgcHJvcHMpID0+IHtcbiAgICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICAgIE9iamVjdC5lbnRyaWVzKHByb3BzKS5mb3JFYWNoKF9yZWYgPT4ge1xuICAgICAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjtcbiAgICAgICAgaWYgKGlzSXRlbSAmJiBbQUNUSVZFX0tFWSwgU0VMRUNURURfS0VZXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkuaW5kZXhPZignb24nKSA9PT0gMCkge1xuICAgICAgICAgIGlmICghbWFwLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBtYXAuc2V0KGtleSwgW10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgX21hcCRnZXQ7XG4gICAgICAgICAgICAoX21hcCRnZXQgPSBtYXAuZ2V0KGtleSkpID09IG51bGwgfHwgX21hcCRnZXQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIF9tYXAkZ2V0MjtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gKF9tYXAkZ2V0MiA9IG1hcC5nZXQoa2V5KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tYXAkZ2V0Mi5tYXAoZm4gPT4gZm4oLi4uYXJncykpLmZpbmQodmFsID0+IHZhbCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFjY1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSlcbiAgfTtcbn1cblxuLyoqXG4gKiBNZXJnZXMgYW4gYXJyYXkgb2YgaW50ZXJhY3Rpb24gaG9va3MnIHByb3BzIGludG8gcHJvcCBnZXR0ZXJzLCBhbGxvd2luZ1xuICogZXZlbnQgaGFuZGxlciBmdW5jdGlvbnMgdG8gYmUgY29tcG9zZWQgdG9nZXRoZXIgd2l0aG91dCBvdmVyd3JpdGluZyBvbmVcbiAqIGFub3RoZXIuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlSW50ZXJhY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIHVzZUludGVyYWN0aW9ucyhwcm9wc0xpc3QpIHtcbiAgaWYgKHByb3BzTGlzdCA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHNMaXN0ID0gW107XG4gIH1cbiAgLy8gVGhlIGRlcGVuZGVuY2llcyBhcmUgYSBkeW5hbWljIGFycmF5LCBzbyB3ZSBjYW4ndCB1c2UgdGhlIGxpbnRlcidzXG4gIC8vIHN1Z2dlc3Rpb24gdG8gYWRkIGl0IHRvIHRoZSBkZXBzIGFycmF5LlxuICBjb25zdCBkZXBzID0gcHJvcHNMaXN0O1xuICBjb25zdCBnZXRSZWZlcmVuY2VQcm9wcyA9IFJlYWN0LnVzZUNhbGxiYWNrKHVzZXJQcm9wcyA9PiBtZXJnZVByb3BzKHVzZXJQcm9wcywgcHJvcHNMaXN0LCAncmVmZXJlbmNlJyksXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgZGVwcyk7XG4gIGNvbnN0IGdldEZsb2F0aW5nUHJvcHMgPSBSZWFjdC51c2VDYWxsYmFjayh1c2VyUHJvcHMgPT4gbWVyZ2VQcm9wcyh1c2VyUHJvcHMsIHByb3BzTGlzdCwgJ2Zsb2F0aW5nJyksXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgZGVwcyk7XG4gIGNvbnN0IGdldEl0ZW1Qcm9wcyA9IFJlYWN0LnVzZUNhbGxiYWNrKHVzZXJQcm9wcyA9PiBtZXJnZVByb3BzKHVzZXJQcm9wcywgcHJvcHNMaXN0LCAnaXRlbScpLFxuICAvLyBHcmFudWxhcmx5IGNoZWNrIGZvciBgaXRlbWAgY2hhbmdlcywgYmVjYXVzZSB0aGUgYGdldEl0ZW1Qcm9wc2AgZ2V0dGVyXG4gIC8vIHNob3VsZCBiZSBhcyByZWZlcmVudGlhbGx5IHN0YWJsZSBhcyBwb3NzaWJsZSBzaW5jZSBpdCBtYXkgYmUgcGFzc2VkIGFzXG4gIC8vIGEgcHJvcCB0byBtYW55IGNvbXBvbmVudHMuIEFsbCBgaXRlbWAga2V5IHZhbHVlcyBtdXN0IHRoZXJlZm9yZSBiZVxuICAvLyBtZW1vaXplZC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBwcm9wc0xpc3QubWFwKGtleSA9PiBrZXkgPT0gbnVsbCA/IHZvaWQgMCA6IGtleS5pdGVtKSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgZ2V0UmVmZXJlbmNlUHJvcHMsXG4gICAgZ2V0RmxvYXRpbmdQcm9wcyxcbiAgICBnZXRJdGVtUHJvcHNcbiAgfSksIFtnZXRSZWZlcmVuY2VQcm9wcywgZ2V0RmxvYXRpbmdQcm9wcywgZ2V0SXRlbVByb3BzXSk7XG59XG5cbmxldCBpc1ByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGRvU3dpdGNoKG9yaWVudGF0aW9uLCB2ZXJ0aWNhbCwgaG9yaXpvbnRhbCkge1xuICBzd2l0Y2ggKG9yaWVudGF0aW9uKSB7XG4gICAgY2FzZSAndmVydGljYWwnOlxuICAgICAgcmV0dXJuIHZlcnRpY2FsO1xuICAgIGNhc2UgJ2hvcml6b250YWwnOlxuICAgICAgcmV0dXJuIGhvcml6b250YWw7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB2ZXJ0aWNhbCB8fCBob3Jpem9udGFsO1xuICB9XG59XG5mdW5jdGlvbiBpc01haW5PcmllbnRhdGlvbktleShrZXksIG9yaWVudGF0aW9uKSB7XG4gIGNvbnN0IHZlcnRpY2FsID0ga2V5ID09PSBBUlJPV19VUCB8fCBrZXkgPT09IEFSUk9XX0RPV047XG4gIGNvbnN0IGhvcml6b250YWwgPSBrZXkgPT09IEFSUk9XX0xFRlQgfHwga2V5ID09PSBBUlJPV19SSUdIVDtcbiAgcmV0dXJuIGRvU3dpdGNoKG9yaWVudGF0aW9uLCB2ZXJ0aWNhbCwgaG9yaXpvbnRhbCk7XG59XG5mdW5jdGlvbiBpc01haW5PcmllbnRhdGlvblRvRW5kS2V5KGtleSwgb3JpZW50YXRpb24sIHJ0bCkge1xuICBjb25zdCB2ZXJ0aWNhbCA9IGtleSA9PT0gQVJST1dfRE9XTjtcbiAgY29uc3QgaG9yaXpvbnRhbCA9IHJ0bCA/IGtleSA9PT0gQVJST1dfTEVGVCA6IGtleSA9PT0gQVJST1dfUklHSFQ7XG4gIHJldHVybiBkb1N3aXRjaChvcmllbnRhdGlvbiwgdmVydGljYWwsIGhvcml6b250YWwpIHx8IGtleSA9PT0gJ0VudGVyJyB8fCBrZXkgPT0gJyAnIHx8IGtleSA9PT0gJyc7XG59XG5mdW5jdGlvbiBpc0Nyb3NzT3JpZW50YXRpb25PcGVuS2V5KGtleSwgb3JpZW50YXRpb24sIHJ0bCkge1xuICBjb25zdCB2ZXJ0aWNhbCA9IHJ0bCA/IGtleSA9PT0gQVJST1dfTEVGVCA6IGtleSA9PT0gQVJST1dfUklHSFQ7XG4gIGNvbnN0IGhvcml6b250YWwgPSBrZXkgPT09IEFSUk9XX0RPV047XG4gIHJldHVybiBkb1N3aXRjaChvcmllbnRhdGlvbiwgdmVydGljYWwsIGhvcml6b250YWwpO1xufVxuZnVuY3Rpb24gaXNDcm9zc09yaWVudGF0aW9uQ2xvc2VLZXkoa2V5LCBvcmllbnRhdGlvbiwgcnRsKSB7XG4gIGNvbnN0IHZlcnRpY2FsID0gcnRsID8ga2V5ID09PSBBUlJPV19SSUdIVCA6IGtleSA9PT0gQVJST1dfTEVGVDtcbiAgY29uc3QgaG9yaXpvbnRhbCA9IGtleSA9PT0gQVJST1dfVVA7XG4gIHJldHVybiBkb1N3aXRjaChvcmllbnRhdGlvbiwgdmVydGljYWwsIGhvcml6b250YWwpO1xufVxuLyoqXG4gKiBBZGRzIGFycm93IGtleS1iYXNlZCBuYXZpZ2F0aW9uIG9mIGEgbGlzdCBvZiBpdGVtcywgZWl0aGVyIHVzaW5nIHJlYWwgRE9NXG4gKiBmb2N1cyBvciB2aXJ0dWFsIGZvY3VzLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZUxpc3ROYXZpZ2F0aW9uXG4gKi9cbmZ1bmN0aW9uIHVzZUxpc3ROYXZpZ2F0aW9uKGNvbnRleHQsIHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIG9uT3BlbkNoYW5nZSxcbiAgICByZWZzLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICBkb21SZWZlcmVuY2UsXG4gICAgICBmbG9hdGluZ1xuICAgIH1cbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBsaXN0UmVmLFxuICAgIGFjdGl2ZUluZGV4LFxuICAgIG9uTmF2aWdhdGU6IHVuc3RhYmxlX29uTmF2aWdhdGUgPSAoKSA9PiB7fSxcbiAgICBlbmFibGVkID0gdHJ1ZSxcbiAgICBzZWxlY3RlZEluZGV4ID0gbnVsbCxcbiAgICBhbGxvd0VzY2FwZSA9IGZhbHNlLFxuICAgIGxvb3AgPSBmYWxzZSxcbiAgICBuZXN0ZWQgPSBmYWxzZSxcbiAgICBydGwgPSBmYWxzZSxcbiAgICB2aXJ0dWFsID0gZmFsc2UsXG4gICAgZm9jdXNJdGVtT25PcGVuID0gJ2F1dG8nLFxuICAgIGZvY3VzSXRlbU9uSG92ZXIgPSB0cnVlLFxuICAgIG9wZW5PbkFycm93S2V5RG93biA9IHRydWUsXG4gICAgZGlzYWJsZWRJbmRpY2VzID0gdW5kZWZpbmVkLFxuICAgIG9yaWVudGF0aW9uID0gJ3ZlcnRpY2FsJyxcbiAgICBjb2xzID0gMSxcbiAgICBzY3JvbGxJdGVtSW50b1ZpZXcgPSB0cnVlLFxuICAgIHZpcnR1YWxJdGVtUmVmXG4gIH0gPSBwcm9wcztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmIChhbGxvd0VzY2FwZSkge1xuICAgICAgaWYgKCFsb29wKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihbJ0Zsb2F0aW5nIFVJOiBgdXNlTGlzdE5hdmlnYXRpb25gIGxvb3BpbmcgbXVzdCBiZSBlbmFibGVkIHRvIGFsbG93JywgJ2VzY2FwaW5nLiddLmpvaW4oJyAnKSk7XG4gICAgICB9XG4gICAgICBpZiAoIXZpcnR1YWwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFsnRmxvYXRpbmcgVUk6IGB1c2VMaXN0TmF2aWdhdGlvbmAgbXVzdCBiZSB2aXJ0dWFsIHRvIGFsbG93JywgJ2VzY2FwaW5nLiddLmpvaW4oJyAnKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJyAmJiBjb2xzID4gMSkge1xuICAgICAgY29uc29sZS53YXJuKFsnRmxvYXRpbmcgVUk6IEluIGdyaWQgbGlzdCBuYXZpZ2F0aW9uIG1vZGUgKGBjb2xzYCA+IDEpLCB0aGUnLCAnYG9yaWVudGF0aW9uYCBzaG91bGQgYmUgZWl0aGVyIFwiaG9yaXpvbnRhbFwiIG9yIFwiYm90aFwiLiddLmpvaW4oJyAnKSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHBhcmVudElkID0gdXNlRmxvYXRpbmdQYXJlbnROb2RlSWQoKTtcbiAgY29uc3QgdHJlZSA9IHVzZUZsb2F0aW5nVHJlZSgpO1xuICBjb25zdCBvbk5hdmlnYXRlID0gdXNlRWZmZWN0RXZlbnQodW5zdGFibGVfb25OYXZpZ2F0ZSk7XG4gIGNvbnN0IGZvY3VzSXRlbU9uT3BlblJlZiA9IFJlYWN0LnVzZVJlZihmb2N1c0l0ZW1Pbk9wZW4pO1xuICBjb25zdCBpbmRleFJlZiA9IFJlYWN0LnVzZVJlZihzZWxlY3RlZEluZGV4ICE9IG51bGwgPyBzZWxlY3RlZEluZGV4IDogLTEpO1xuICBjb25zdCBrZXlSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGlzUG9pbnRlck1vZGFsaXR5UmVmID0gUmVhY3QudXNlUmVmKHRydWUpO1xuICBjb25zdCBwcmV2aW91c09uTmF2aWdhdGVSZWYgPSBSZWFjdC51c2VSZWYob25OYXZpZ2F0ZSk7XG4gIGNvbnN0IHByZXZpb3VzTW91bnRlZFJlZiA9IFJlYWN0LnVzZVJlZighIWZsb2F0aW5nKTtcbiAgY29uc3QgZm9yY2VTeW5jRm9jdXMgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCBmb3JjZVNjcm9sbEludG9WaWV3UmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgZGlzYWJsZWRJbmRpY2VzUmVmID0gdXNlTGF0ZXN0UmVmKGRpc2FibGVkSW5kaWNlcyk7XG4gIGNvbnN0IGxhdGVzdE9wZW5SZWYgPSB1c2VMYXRlc3RSZWYob3Blbik7XG4gIGNvbnN0IHNjcm9sbEl0ZW1JbnRvVmlld1JlZiA9IHVzZUxhdGVzdFJlZihzY3JvbGxJdGVtSW50b1ZpZXcpO1xuICBjb25zdCBbYWN0aXZlSWQsIHNldEFjdGl2ZUlkXSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gIGNvbnN0IFt2aXJ0dWFsSWQsIHNldFZpcnR1YWxJZF0gPSBSZWFjdC51c2VTdGF0ZSgpO1xuICBjb25zdCBmb2N1c0l0ZW0gPSB1c2VFZmZlY3RFdmVudChmdW5jdGlvbiAobGlzdFJlZiwgaW5kZXhSZWYsIGZvcmNlU2Nyb2xsSW50b1ZpZXcpIHtcbiAgICBpZiAoZm9yY2VTY3JvbGxJbnRvVmlldyA9PT0gdm9pZCAwKSB7XG4gICAgICBmb3JjZVNjcm9sbEludG9WaWV3ID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSBsaXN0UmVmLmN1cnJlbnRbaW5kZXhSZWYuY3VycmVudF07XG4gICAgaWYgKCFpdGVtKSByZXR1cm47XG4gICAgaWYgKHZpcnR1YWwpIHtcbiAgICAgIHNldEFjdGl2ZUlkKGl0ZW0uaWQpO1xuICAgICAgdHJlZSA9PSBudWxsIHx8IHRyZWUuZXZlbnRzLmVtaXQoJ3ZpcnR1YWxmb2N1cycsIGl0ZW0pO1xuICAgICAgaWYgKHZpcnR1YWxJdGVtUmVmKSB7XG4gICAgICAgIHZpcnR1YWxJdGVtUmVmLmN1cnJlbnQgPSBpdGVtO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbnF1ZXVlRm9jdXMoaXRlbSwge1xuICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlLFxuICAgICAgICAvLyBNYWMgU2FmYXJpIGRvZXMgbm90IG1vdmUgdGhlIHZpcnR1YWwgY3Vyc29yIHVubGVzcyB0aGUgZm9jdXMgY2FsbFxuICAgICAgICAvLyBpcyBzeW5jLiBIb3dldmVyLCBmb3IgdGhlIHZlcnkgZmlyc3QgZm9jdXMgY2FsbCwgd2UgbmVlZCB0byB3YWl0XG4gICAgICAgIC8vIGZvciB0aGUgcG9zaXRpb24gdG8gYmUgcmVhZHkgaW4gb3JkZXIgdG8gcHJldmVudCB1bndhbnRlZFxuICAgICAgICAvLyBzY3JvbGxpbmcuIFRoaXMgbWVhbnMgdGhlIHZpcnR1YWwgY3Vyc29yIHdpbGwgbm90IG1vdmUgdG8gdGhlIGZpcnN0XG4gICAgICAgIC8vIGl0ZW0gd2hlbiBmaXJzdCBvcGVuaW5nIHRoZSBmbG9hdGluZyBlbGVtZW50LCBidXQgd2lsbCBvblxuICAgICAgICAvLyBzdWJzZXF1ZW50IGNhbGxzLiBgcHJldmVudFNjcm9sbGAgaXMgc3VwcG9ydGVkIGluIG1vZGVybiBTYWZhcmksXG4gICAgICAgIC8vIHNvIHdlIGNhbiB1c2UgdGhhdCBpbnN0ZWFkLlxuICAgICAgICAvLyBpT1MgU2FmYXJpIG11c3QgYmUgYXN5bmMgb3IgdGhlIGZpcnN0IGl0ZW0gd2lsbCBub3QgYmUgZm9jdXNlZC5cbiAgICAgICAgc3luYzogaXNNYWMoKSAmJiBpc1NhZmFyaSgpID8gaXNQcmV2ZW50U2Nyb2xsU3VwcG9ydGVkIHx8IGZvcmNlU3luY0ZvY3VzLmN1cnJlbnQgOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBjb25zdCBzY3JvbGxJbnRvVmlld09wdGlvbnMgPSBzY3JvbGxJdGVtSW50b1ZpZXdSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IHNob3VsZFNjcm9sbEludG9WaWV3ID0gc2Nyb2xsSW50b1ZpZXdPcHRpb25zICYmIGl0ZW0gJiYgKGZvcmNlU2Nyb2xsSW50b1ZpZXcgfHwgIWlzUG9pbnRlck1vZGFsaXR5UmVmLmN1cnJlbnQpO1xuICAgICAgaWYgKHNob3VsZFNjcm9sbEludG9WaWV3KSB7XG4gICAgICAgIC8vIEpTRE9NIGRvZXNuJ3Qgc3VwcG9ydCBgLnNjcm9sbEludG9WaWV3KClgIGJ1dCBpdCdzIHdpZGVseSBzdXBwb3J0ZWRcbiAgICAgICAgLy8gYnkgYWxsIGJyb3dzZXJzLlxuICAgICAgICBpdGVtLnNjcm9sbEludG9WaWV3ID09IG51bGwgfHwgaXRlbS5zY3JvbGxJbnRvVmlldyh0eXBlb2Ygc2Nyb2xsSW50b1ZpZXdPcHRpb25zID09PSAnYm9vbGVhbicgPyB7XG4gICAgICAgICAgYmxvY2s6ICduZWFyZXN0JyxcbiAgICAgICAgICBpbmxpbmU6ICduZWFyZXN0J1xuICAgICAgICB9IDogc2Nyb2xsSW50b1ZpZXdPcHRpb25zKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5mb2N1cyh7XG4gICAgICBnZXQgcHJldmVudFNjcm9sbCgpIHtcbiAgICAgICAgaXNQcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBbXSk7XG5cbiAgLy8gU3luYyBgc2VsZWN0ZWRJbmRleGAgdG8gYmUgdGhlIGBhY3RpdmVJbmRleGAgdXBvbiBvcGVuaW5nIHRoZSBmbG9hdGluZ1xuICAvLyBlbGVtZW50LiBBbHNvLCByZXNldCBgYWN0aXZlSW5kZXhgIHVwb24gY2xvc2luZyB0aGUgZmxvYXRpbmcgZWxlbWVudC5cbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3BlbiAmJiBmbG9hdGluZykge1xuICAgICAgaWYgKGZvY3VzSXRlbU9uT3BlblJlZi5jdXJyZW50ICYmIHNlbGVjdGVkSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAvLyBSZWdhcmRsZXNzIG9mIHRoZSBwb2ludGVyIG1vZGFsaXR5LCB3ZSB3YW50IHRvIGVuc3VyZSB0aGUgc2VsZWN0ZWRcbiAgICAgICAgLy8gaXRlbSBjb21lcyBpbnRvIHZpZXcgd2hlbiB0aGUgZmxvYXRpbmcgZWxlbWVudCBpcyBvcGVuZWQuXG4gICAgICAgIGZvcmNlU2Nyb2xsSW50b1ZpZXdSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIG9uTmF2aWdhdGUoc2VsZWN0ZWRJbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcmV2aW91c01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgLy8gU2luY2UgdGhlIHVzZXIgY2FuIHNwZWNpZnkgYG9uTmF2aWdhdGVgIGNvbmRpdGlvbmFsbHlcbiAgICAgIC8vIChvbk5hdmlnYXRlOiBvcGVuID8gc2V0QWN0aXZlSW5kZXggOiBzZXRTZWxlY3RlZEluZGV4KSxcbiAgICAgIC8vIHdlIHN0b3JlIGFuZCBjYWxsIHRoZSBwcmV2aW91cyBmdW5jdGlvbi5cbiAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSAtMTtcbiAgICAgIHByZXZpb3VzT25OYXZpZ2F0ZVJlZi5jdXJyZW50KG51bGwpO1xuICAgIH1cbiAgfSwgW2VuYWJsZWQsIG9wZW4sIGZsb2F0aW5nLCBzZWxlY3RlZEluZGV4LCBvbk5hdmlnYXRlXSk7XG5cbiAgLy8gU3luYyBgYWN0aXZlSW5kZXhgIHRvIGJlIHRoZSBmb2N1c2VkIGl0ZW0gd2hpbGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXNcbiAgLy8gb3Blbi5cbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3BlbiAmJiBmbG9hdGluZykge1xuICAgICAgaWYgKGFjdGl2ZUluZGV4ID09IG51bGwpIHtcbiAgICAgICAgZm9yY2VTeW5jRm9jdXMuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBpZiAoc2VsZWN0ZWRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzZXQgd2hpbGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgd2FzIG9wZW4gKGUuZy4gdGhlIGxpc3QgY2hhbmdlZCkuXG4gICAgICAgIGlmIChwcmV2aW91c01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSAtMTtcbiAgICAgICAgICBmb2N1c0l0ZW0obGlzdFJlZiwgaW5kZXhSZWYpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5pdGlhbCBzeW5jLlxuICAgICAgICBpZiAoIXByZXZpb3VzTW91bnRlZFJlZi5jdXJyZW50ICYmIGZvY3VzSXRlbU9uT3BlblJlZi5jdXJyZW50ICYmIChrZXlSZWYuY3VycmVudCAhPSBudWxsIHx8IGZvY3VzSXRlbU9uT3BlblJlZi5jdXJyZW50ID09PSB0cnVlICYmIGtleVJlZi5jdXJyZW50ID09IG51bGwpKSB7XG4gICAgICAgICAgbGV0IHJ1bnMgPSAwO1xuICAgICAgICAgIGNvbnN0IHdhaXRGb3JMaXN0UG9wdWxhdGVkID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGxpc3RSZWYuY3VycmVudFswXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIEF2b2lkIGxldHRpbmcgdGhlIGJyb3dzZXIgcGFpbnQgaWYgcG9zc2libGUgb24gdGhlIGZpcnN0IHRyeSxcbiAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHVzZSByQUYuIERvbid0IHRyeSBtb3JlIHRoYW4gdHdpY2UsIHNpbmNlIHNvbWV0aGluZ1xuICAgICAgICAgICAgICAvLyBpcyB3cm9uZyBvdGhlcndpc2UuXG4gICAgICAgICAgICAgIGlmIChydW5zIDwgMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVkdWxlciA9IHJ1bnMgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiBxdWV1ZU1pY3JvdGFzaztcbiAgICAgICAgICAgICAgICBzY2hlZHVsZXIod2FpdEZvckxpc3RQb3B1bGF0ZWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJ1bnMrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBrZXlSZWYuY3VycmVudCA9PSBudWxsIHx8IGlzTWFpbk9yaWVudGF0aW9uVG9FbmRLZXkoa2V5UmVmLmN1cnJlbnQsIG9yaWVudGF0aW9uLCBydGwpIHx8IG5lc3RlZCA/IGdldE1pbkluZGV4KGxpc3RSZWYsIGRpc2FibGVkSW5kaWNlc1JlZi5jdXJyZW50KSA6IGdldE1heEluZGV4KGxpc3RSZWYsIGRpc2FibGVkSW5kaWNlc1JlZi5jdXJyZW50KTtcbiAgICAgICAgICAgICAga2V5UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgICBvbk5hdmlnYXRlKGluZGV4UmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgd2FpdEZvckxpc3RQb3B1bGF0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghaXNJbmRleE91dE9mQm91bmRzKGxpc3RSZWYsIGFjdGl2ZUluZGV4KSkge1xuICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gYWN0aXZlSW5kZXg7XG4gICAgICAgIGZvY3VzSXRlbShsaXN0UmVmLCBpbmRleFJlZiwgZm9yY2VTY3JvbGxJbnRvVmlld1JlZi5jdXJyZW50KTtcbiAgICAgICAgZm9yY2VTY3JvbGxJbnRvVmlld1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgb3BlbiwgZmxvYXRpbmcsIGFjdGl2ZUluZGV4LCBzZWxlY3RlZEluZGV4LCBuZXN0ZWQsIGxpc3RSZWYsIG9yaWVudGF0aW9uLCBydGwsIG9uTmF2aWdhdGUsIGZvY3VzSXRlbSwgZGlzYWJsZWRJbmRpY2VzUmVmXSk7XG5cbiAgLy8gRW5zdXJlIHRoZSBwYXJlbnQgZmxvYXRpbmcgZWxlbWVudCBoYXMgZm9jdXMgd2hlbiBhIG5lc3RlZCBjaGlsZCBjbG9zZXNcbiAgLy8gdG8gYWxsb3cgYXJyb3cga2V5IG5hdmlnYXRpb24gdG8gd29yayBhZnRlciB0aGUgcG9pbnRlciBsZWF2ZXMgdGhlIGNoaWxkLlxuICBpbmRleCgoKSA9PiB7XG4gICAgdmFyIF9ub2RlcyRmaW5kO1xuICAgIGlmICghZW5hYmxlZCB8fCBmbG9hdGluZyB8fCAhdHJlZSB8fCB2aXJ0dWFsIHx8ICFwcmV2aW91c01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub2RlcyA9IHRyZWUubm9kZXNSZWYuY3VycmVudDtcbiAgICBjb25zdCBwYXJlbnQgPSAoX25vZGVzJGZpbmQgPSBub2Rlcy5maW5kKG5vZGUgPT4gbm9kZS5pZCA9PT0gcGFyZW50SWQpKSA9PSBudWxsIHx8IChfbm9kZXMkZmluZCA9IF9ub2RlcyRmaW5kLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZXMkZmluZC5lbGVtZW50cy5mbG9hdGluZztcbiAgICBjb25zdCBhY3RpdmVFbCA9IGFjdGl2ZUVsZW1lbnQoZ2V0RG9jdW1lbnQoZmxvYXRpbmcpKTtcbiAgICBjb25zdCB0cmVlQ29udGFpbnNBY3RpdmVFbCA9IG5vZGVzLnNvbWUobm9kZSA9PiBub2RlLmNvbnRleHQgJiYgY29udGFpbnMobm9kZS5jb250ZXh0LmVsZW1lbnRzLmZsb2F0aW5nLCBhY3RpdmVFbCkpO1xuICAgIGlmIChwYXJlbnQgJiYgIXRyZWVDb250YWluc0FjdGl2ZUVsICYmIGlzUG9pbnRlck1vZGFsaXR5UmVmLmN1cnJlbnQpIHtcbiAgICAgIHBhcmVudC5mb2N1cyh7XG4gICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2VuYWJsZWQsIGZsb2F0aW5nLCB0cmVlLCBwYXJlbnRJZCwgdmlydHVhbF0pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkIHx8ICF0cmVlIHx8ICF2aXJ0dWFsIHx8IHBhcmVudElkKSByZXR1cm47XG4gICAgZnVuY3Rpb24gaGFuZGxlVmlydHVhbEZvY3VzKGl0ZW0pIHtcbiAgICAgIHNldFZpcnR1YWxJZChpdGVtLmlkKTtcbiAgICAgIGlmICh2aXJ0dWFsSXRlbVJlZikge1xuICAgICAgICB2aXJ0dWFsSXRlbVJlZi5jdXJyZW50ID0gaXRlbTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJlZS5ldmVudHMub24oJ3ZpcnR1YWxmb2N1cycsIGhhbmRsZVZpcnR1YWxGb2N1cyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRyZWUuZXZlbnRzLm9mZigndmlydHVhbGZvY3VzJywgaGFuZGxlVmlydHVhbEZvY3VzKTtcbiAgICB9O1xuICB9LCBbZW5hYmxlZCwgdHJlZSwgdmlydHVhbCwgcGFyZW50SWQsIHZpcnR1YWxJdGVtUmVmXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBwcmV2aW91c09uTmF2aWdhdGVSZWYuY3VycmVudCA9IG9uTmF2aWdhdGU7XG4gICAgcHJldmlvdXNNb3VudGVkUmVmLmN1cnJlbnQgPSAhIWZsb2F0aW5nO1xuICB9KTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmICghb3Blbikge1xuICAgICAga2V5UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfSwgW29wZW5dKTtcbiAgY29uc3QgaGFzQWN0aXZlSW5kZXggPSBhY3RpdmVJbmRleCAhPSBudWxsO1xuICBjb25zdCBpdGVtID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgZnVuY3Rpb24gc3luY0N1cnJlbnRUYXJnZXQoY3VycmVudFRhcmdldCkge1xuICAgICAgaWYgKCFvcGVuKSByZXR1cm47XG4gICAgICBjb25zdCBpbmRleCA9IGxpc3RSZWYuY3VycmVudC5pbmRleE9mKGN1cnJlbnRUYXJnZXQpO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICBvbk5hdmlnYXRlKGluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICBvbkZvY3VzKF9yZWYpIHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBjdXJyZW50VGFyZ2V0XG4gICAgICAgIH0gPSBfcmVmO1xuICAgICAgICBzeW5jQ3VycmVudFRhcmdldChjdXJyZW50VGFyZ2V0KTtcbiAgICAgIH0sXG4gICAgICBvbkNsaWNrOiBfcmVmMiA9PiB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgY3VycmVudFRhcmdldFxuICAgICAgICB9ID0gX3JlZjI7XG4gICAgICAgIHJldHVybiBjdXJyZW50VGFyZ2V0LmZvY3VzKHtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIC8vIFNhZmFyaVxuICAgICAgLi4uKGZvY3VzSXRlbU9uSG92ZXIgJiYge1xuICAgICAgICBvbk1vdXNlTW92ZShfcmVmMykge1xuICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICBjdXJyZW50VGFyZ2V0XG4gICAgICAgICAgfSA9IF9yZWYzO1xuICAgICAgICAgIHN5bmNDdXJyZW50VGFyZ2V0KGN1cnJlbnRUYXJnZXQpO1xuICAgICAgICB9LFxuICAgICAgICBvblBvaW50ZXJMZWF2ZShfcmVmNCkge1xuICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICBwb2ludGVyVHlwZVxuICAgICAgICAgIH0gPSBfcmVmNDtcbiAgICAgICAgICBpZiAoIWlzUG9pbnRlck1vZGFsaXR5UmVmLmN1cnJlbnQgfHwgcG9pbnRlclR5cGUgPT09ICd0b3VjaCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IC0xO1xuICAgICAgICAgIGZvY3VzSXRlbShsaXN0UmVmLCBpbmRleFJlZik7XG4gICAgICAgICAgb25OYXZpZ2F0ZShudWxsKTtcbiAgICAgICAgICBpZiAoIXZpcnR1YWwpIHtcbiAgICAgICAgICAgIGVucXVldWVGb2N1cyhyZWZzLmZsb2F0aW5nLmN1cnJlbnQsIHtcbiAgICAgICAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH07XG4gICAgcmV0dXJuIHByb3BzO1xuICB9LCBbb3BlbiwgcmVmcywgZm9jdXNJdGVtLCBmb2N1c0l0ZW1PbkhvdmVyLCBsaXN0UmVmLCBvbk5hdmlnYXRlLCB2aXJ0dWFsXSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgZGlzYWJsZWRJbmRpY2VzID0gZGlzYWJsZWRJbmRpY2VzUmVmLmN1cnJlbnQ7XG4gICAgZnVuY3Rpb24gb25LZXlEb3duKGV2ZW50KSB7XG4gICAgICBpc1BvaW50ZXJNb2RhbGl0eVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBmb3JjZVN5bmNGb2N1cy5jdXJyZW50ID0gdHJ1ZTtcblxuICAgICAgLy8gSWYgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXMgYW5pbWF0aW5nIG91dCwgaWdub3JlIG5hdmlnYXRpb24uIE90aGVyd2lzZSxcbiAgICAgIC8vIHRoZSBgYWN0aXZlSW5kZXhgIGdldHMgc2V0IHRvIDAgZGVzcGl0ZSBub3QgYmVpbmcgb3BlbiBzbyB0aGUgbmV4dCB0aW1lXG4gICAgICAvLyB0aGUgdXNlciBBcnJvd0Rvd25zLCB0aGUgZmlyc3QgaXRlbSB3b24ndCBiZSBmb2N1c2VkLlxuICAgICAgaWYgKCFsYXRlc3RPcGVuUmVmLmN1cnJlbnQgJiYgZXZlbnQuY3VycmVudFRhcmdldCA9PT0gcmVmcy5mbG9hdGluZy5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChuZXN0ZWQgJiYgaXNDcm9zc09yaWVudGF0aW9uQ2xvc2VLZXkoZXZlbnQua2V5LCBvcmllbnRhdGlvbiwgcnRsKSkge1xuICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnbGlzdC1uYXZpZ2F0aW9uJyk7XG4gICAgICAgIGlmIChpc0hUTUxFbGVtZW50KGRvbVJlZmVyZW5jZSkgJiYgIXZpcnR1YWwpIHtcbiAgICAgICAgICBkb21SZWZlcmVuY2UuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBpbmRleFJlZi5jdXJyZW50O1xuICAgICAgY29uc3QgbWluSW5kZXggPSBnZXRNaW5JbmRleChsaXN0UmVmLCBkaXNhYmxlZEluZGljZXMpO1xuICAgICAgY29uc3QgbWF4SW5kZXggPSBnZXRNYXhJbmRleChsaXN0UmVmLCBkaXNhYmxlZEluZGljZXMpO1xuICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0hvbWUnKSB7XG4gICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBtaW5JbmRleDtcbiAgICAgICAgb25OYXZpZ2F0ZShpbmRleFJlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5rZXkgPT09ICdFbmQnKSB7XG4gICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBtYXhJbmRleDtcbiAgICAgICAgb25OYXZpZ2F0ZShpbmRleFJlZi5jdXJyZW50KTtcbiAgICAgIH1cblxuICAgICAgLy8gR3JpZCBuYXZpZ2F0aW9uLlxuICAgICAgaWYgKGNvbHMgPiAxKSB7XG4gICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBnZXRHcmlkTmF2aWdhdGVkSW5kZXgobGlzdFJlZiwge1xuICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICAgIGxvb3AsXG4gICAgICAgICAgY29scyxcbiAgICAgICAgICBkaXNhYmxlZEluZGljZXMsXG4gICAgICAgICAgbWluSW5kZXgsXG4gICAgICAgICAgbWF4SW5kZXgsXG4gICAgICAgICAgcHJldkluZGV4OiBpbmRleFJlZi5jdXJyZW50LFxuICAgICAgICAgIHN0b3BFdmVudDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgb25OYXZpZ2F0ZShpbmRleFJlZi5jdXJyZW50KTtcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSAnYm90aCcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc01haW5PcmllbnRhdGlvbktleShldmVudC5rZXksIG9yaWVudGF0aW9uKSkge1xuICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuXG4gICAgICAgIC8vIFJlc2V0IHRoZSBpbmRleCBpZiBubyBpdGVtIGlzIGZvY3VzZWQuXG4gICAgICAgIGlmIChvcGVuICYmICF2aXJ0dWFsICYmIGFjdGl2ZUVsZW1lbnQoZXZlbnQuY3VycmVudFRhcmdldC5vd25lckRvY3VtZW50KSA9PT0gZXZlbnQuY3VycmVudFRhcmdldCkge1xuICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBpc01haW5PcmllbnRhdGlvblRvRW5kS2V5KGV2ZW50LmtleSwgb3JpZW50YXRpb24sIHJ0bCkgPyBtaW5JbmRleCA6IG1heEluZGV4O1xuICAgICAgICAgIG9uTmF2aWdhdGUoaW5kZXhSZWYuY3VycmVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc01haW5PcmllbnRhdGlvblRvRW5kS2V5KGV2ZW50LmtleSwgb3JpZW50YXRpb24sIHJ0bCkpIHtcbiAgICAgICAgICBpZiAobG9vcCkge1xuICAgICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGN1cnJlbnRJbmRleCA+PSBtYXhJbmRleCA/IGFsbG93RXNjYXBlICYmIGN1cnJlbnRJbmRleCAhPT0gbGlzdFJlZi5jdXJyZW50Lmxlbmd0aCA/IC0xIDogbWluSW5kZXggOiBmaW5kTm9uRGlzYWJsZWRJbmRleChsaXN0UmVmLCB7XG4gICAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IGN1cnJlbnRJbmRleCxcbiAgICAgICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IE1hdGgubWluKG1heEluZGV4LCBmaW5kTm9uRGlzYWJsZWRJbmRleChsaXN0UmVmLCB7XG4gICAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IGN1cnJlbnRJbmRleCxcbiAgICAgICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChsb29wKSB7XG4gICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gY3VycmVudEluZGV4IDw9IG1pbkluZGV4ID8gYWxsb3dFc2NhcGUgJiYgY3VycmVudEluZGV4ICE9PSAtMSA/IGxpc3RSZWYuY3VycmVudC5sZW5ndGggOiBtYXhJbmRleCA6IGZpbmROb25EaXNhYmxlZEluZGV4KGxpc3RSZWYsIHtcbiAgICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogY3VycmVudEluZGV4LFxuICAgICAgICAgICAgICBkZWNyZW1lbnQ6IHRydWUsXG4gICAgICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBNYXRoLm1heChtaW5JbmRleCwgZmluZE5vbkRpc2FibGVkSW5kZXgobGlzdFJlZiwge1xuICAgICAgICAgICAgICBzdGFydGluZ0luZGV4OiBjdXJyZW50SW5kZXgsXG4gICAgICAgICAgICAgIGRlY3JlbWVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0luZGV4T3V0T2ZCb3VuZHMobGlzdFJlZiwgaW5kZXhSZWYuY3VycmVudCkpIHtcbiAgICAgICAgICBvbk5hdmlnYXRlKG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9uTmF2aWdhdGUoaW5kZXhSZWYuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tWaXJ0dWFsTW91c2UoZXZlbnQpIHtcbiAgICAgIGlmIChmb2N1c0l0ZW1Pbk9wZW4gPT09ICdhdXRvJyAmJiBpc1ZpcnR1YWxDbGljayhldmVudC5uYXRpdmVFdmVudCkpIHtcbiAgICAgICAgZm9jdXNJdGVtT25PcGVuUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1ZpcnR1YWxQb2ludGVyKGV2ZW50KSB7XG4gICAgICAvLyBgcG9pbnRlcmRvd25gIGZpcmVzIGZpcnN0LCByZXNldCB0aGUgc3RhdGUgdGhlbiBwZXJmb3JtIHRoZSBjaGVja3MuXG4gICAgICBmb2N1c0l0ZW1Pbk9wZW5SZWYuY3VycmVudCA9IGZvY3VzSXRlbU9uT3BlbjtcbiAgICAgIGlmIChmb2N1c0l0ZW1Pbk9wZW4gPT09ICdhdXRvJyAmJiBpc1ZpcnR1YWxQb2ludGVyRXZlbnQoZXZlbnQubmF0aXZlRXZlbnQpKSB7XG4gICAgICAgIGZvY3VzSXRlbU9uT3BlblJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYXJpYUFjdGl2ZURlc2NlbmRhbnRQcm9wID0gdmlydHVhbCAmJiBvcGVuICYmIGhhc0FjdGl2ZUluZGV4ICYmIHtcbiAgICAgICdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnOiB2aXJ0dWFsSWQgfHwgYWN0aXZlSWRcbiAgICB9O1xuICAgIGNvbnN0IGFjdGl2ZUl0ZW0gPSBsaXN0UmVmLmN1cnJlbnQuZmluZChpdGVtID0+IChpdGVtID09IG51bGwgPyB2b2lkIDAgOiBpdGVtLmlkKSA9PT0gYWN0aXZlSWQpO1xuICAgIHJldHVybiB7XG4gICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgLi4uYXJpYUFjdGl2ZURlc2NlbmRhbnRQcm9wLFxuICAgICAgICBvbktleURvd24oZXZlbnQpIHtcbiAgICAgICAgICBpc1BvaW50ZXJNb2RhbGl0eVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgY29uc3QgaXNBcnJvd0tleSA9IGV2ZW50LmtleS5pbmRleE9mKCdBcnJvdycpID09PSAwO1xuICAgICAgICAgIGNvbnN0IGlzQ3Jvc3NPcGVuS2V5ID0gaXNDcm9zc09yaWVudGF0aW9uT3BlbktleShldmVudC5rZXksIG9yaWVudGF0aW9uLCBydGwpO1xuICAgICAgICAgIGNvbnN0IGlzQ3Jvc3NDbG9zZUtleSA9IGlzQ3Jvc3NPcmllbnRhdGlvbkNsb3NlS2V5KGV2ZW50LmtleSwgb3JpZW50YXRpb24sIHJ0bCk7XG4gICAgICAgICAgY29uc3QgaXNNYWluS2V5ID0gaXNNYWluT3JpZW50YXRpb25LZXkoZXZlbnQua2V5LCBvcmllbnRhdGlvbik7XG4gICAgICAgICAgY29uc3QgaXNOYXZpZ2F0aW9uS2V5ID0gKG5lc3RlZCA/IGlzQ3Jvc3NPcGVuS2V5IDogaXNNYWluS2V5KSB8fCBldmVudC5rZXkgPT09ICdFbnRlcicgfHwgZXZlbnQua2V5LnRyaW0oKSA9PT0gJyc7XG4gICAgICAgICAgaWYgKHZpcnR1YWwgJiYgb3Blbikge1xuICAgICAgICAgICAgY29uc3Qgcm9vdE5vZGUgPSB0cmVlID09IG51bGwgPyB2b2lkIDAgOiB0cmVlLm5vZGVzUmVmLmN1cnJlbnQuZmluZChub2RlID0+IG5vZGUucGFyZW50SWQgPT0gbnVsbCk7XG4gICAgICAgICAgICBjb25zdCBkZWVwZXN0Tm9kZSA9IHRyZWUgJiYgcm9vdE5vZGUgPyBnZXREZWVwZXN0Tm9kZSh0cmVlLm5vZGVzUmVmLmN1cnJlbnQsIHJvb3ROb2RlLmlkKSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoaXNBcnJvd0tleSAmJiBkZWVwZXN0Tm9kZSAmJiB2aXJ0dWFsSXRlbVJlZikge1xuICAgICAgICAgICAgICBjb25zdCBldmVudE9iamVjdCA9IG5ldyBLZXlib2FyZEV2ZW50KCdrZXlkb3duJywge1xuICAgICAgICAgICAgICAgIGtleTogZXZlbnQua2V5LFxuICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChpc0Nyb3NzT3BlbktleSB8fCBpc0Nyb3NzQ2xvc2VLZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2RlZXBlc3ROb2RlJGNvbnRleHQsIF9kZWVwZXN0Tm9kZSRjb250ZXh0MjtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0N1cnJlbnRUYXJnZXQgPSAoKF9kZWVwZXN0Tm9kZSRjb250ZXh0ID0gZGVlcGVzdE5vZGUuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kZWVwZXN0Tm9kZSRjb250ZXh0LmVsZW1lbnRzLmRvbVJlZmVyZW5jZSkgPT09IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzcGF0Y2hJdGVtID0gaXNDcm9zc0Nsb3NlS2V5ICYmICFpc0N1cnJlbnRUYXJnZXQgPyAoX2RlZXBlc3ROb2RlJGNvbnRleHQyID0gZGVlcGVzdE5vZGUuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kZWVwZXN0Tm9kZSRjb250ZXh0Mi5lbGVtZW50cy5kb21SZWZlcmVuY2UgOiBpc0Nyb3NzT3BlbktleSA/IGFjdGl2ZUl0ZW0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChkaXNwYXRjaEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgICBkaXNwYXRjaEl0ZW0uZGlzcGF0Y2hFdmVudChldmVudE9iamVjdCk7XG4gICAgICAgICAgICAgICAgICBzZXRWaXJ0dWFsSWQodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzTWFpbktleSAmJiBkZWVwZXN0Tm9kZS5jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlZXBlc3ROb2RlLmNvbnRleHQub3BlbiAmJiBkZWVwZXN0Tm9kZS5wYXJlbnRJZCAmJiBldmVudC5jdXJyZW50VGFyZ2V0ICE9PSBkZWVwZXN0Tm9kZS5jb250ZXh0LmVsZW1lbnRzLmRvbVJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIF9kZWVwZXN0Tm9kZSRjb250ZXh0JDtcbiAgICAgICAgICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgICAoX2RlZXBlc3ROb2RlJGNvbnRleHQkID0gZGVlcGVzdE5vZGUuY29udGV4dC5lbGVtZW50cy5kb21SZWZlcmVuY2UpID09IG51bGwgfHwgX2RlZXBlc3ROb2RlJGNvbnRleHQkLmRpc3BhdGNoRXZlbnQoZXZlbnRPYmplY3QpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9uS2V5RG93bihldmVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgYSBmbG9hdGluZyBlbGVtZW50IHNob3VsZCBub3Qgb3BlbiBvbiBhcnJvdyBrZXkgZG93biwgYXZvaWRcbiAgICAgICAgICAvLyBzZXR0aW5nIGBhY3RpdmVJbmRleGAgd2hpbGUgaXQncyBjbG9zZWQuXG4gICAgICAgICAgaWYgKCFvcGVuICYmICFvcGVuT25BcnJvd0tleURvd24gJiYgaXNBcnJvd0tleSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNOYXZpZ2F0aW9uS2V5KSB7XG4gICAgICAgICAgICBrZXlSZWYuY3VycmVudCA9IG5lc3RlZCAmJiBpc01haW5LZXkgPyBudWxsIDogZXZlbnQua2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmVzdGVkKSB7XG4gICAgICAgICAgICBpZiAoaXNDcm9zc09wZW5LZXkpIHtcbiAgICAgICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gZ2V0TWluSW5kZXgobGlzdFJlZiwgZGlzYWJsZWRJbmRpY2VzKTtcbiAgICAgICAgICAgICAgICBvbk5hdmlnYXRlKGluZGV4UmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudC5uYXRpdmVFdmVudCwgJ2xpc3QtbmF2aWdhdGlvbicpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc01haW5LZXkpIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IHNlbGVjdGVkSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFvcGVuICYmIG9wZW5PbkFycm93S2V5RG93bikge1xuICAgICAgICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSwgZXZlbnQubmF0aXZlRXZlbnQsICdsaXN0LW5hdmlnYXRpb24nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9uS2V5RG93bihldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgICBvbk5hdmlnYXRlKGluZGV4UmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25Gb2N1cygpIHtcbiAgICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgb25OYXZpZ2F0ZShudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uUG9pbnRlckRvd246IGNoZWNrVmlydHVhbFBvaW50ZXIsXG4gICAgICAgIG9uTW91c2VEb3duOiBjaGVja1ZpcnR1YWxNb3VzZSxcbiAgICAgICAgb25DbGljazogY2hlY2tWaXJ0dWFsTW91c2VcbiAgICAgIH0sXG4gICAgICBmbG9hdGluZzoge1xuICAgICAgICAnYXJpYS1vcmllbnRhdGlvbic6IG9yaWVudGF0aW9uID09PSAnYm90aCcgPyB1bmRlZmluZWQgOiBvcmllbnRhdGlvbixcbiAgICAgICAgLi4uKCFpc1R5cGVhYmxlQ29tYm9ib3goZG9tUmVmZXJlbmNlKSAmJiBhcmlhQWN0aXZlRGVzY2VuZGFudFByb3ApLFxuICAgICAgICBvbktleURvd24sXG4gICAgICAgIG9uUG9pbnRlck1vdmUoKSB7XG4gICAgICAgICAgaXNQb2ludGVyTW9kYWxpdHlSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpdGVtXG4gICAgfTtcbiAgfSwgW2RvbVJlZmVyZW5jZSwgcmVmcywgYWN0aXZlSWQsIHZpcnR1YWxJZCwgZGlzYWJsZWRJbmRpY2VzUmVmLCBsYXRlc3RPcGVuUmVmLCBsaXN0UmVmLCBlbmFibGVkLCBvcmllbnRhdGlvbiwgcnRsLCB2aXJ0dWFsLCBvcGVuLCBoYXNBY3RpdmVJbmRleCwgbmVzdGVkLCBzZWxlY3RlZEluZGV4LCBvcGVuT25BcnJvd0tleURvd24sIGFsbG93RXNjYXBlLCBjb2xzLCBsb29wLCBmb2N1c0l0ZW1Pbk9wZW4sIG9uTmF2aWdhdGUsIG9uT3BlbkNoYW5nZSwgaXRlbSwgdHJlZSwgdmlydHVhbEl0ZW1SZWZdKTtcbn1cblxuY29uc3QgY29tcG9uZW50Um9sZVRvQXJpYVJvbGVNYXAgPSAvKiNfX1BVUkVfXyovbmV3IE1hcChbWydzZWxlY3QnLCAnbGlzdGJveCddLCBbJ2NvbWJvYm94JywgJ2xpc3Rib3gnXSwgWydsYWJlbCcsIGZhbHNlXV0pO1xuXG4vKipcbiAqIEFkZHMgYmFzZSBzY3JlZW4gcmVhZGVyIHByb3BzIHRvIHRoZSByZWZlcmVuY2UgYW5kIGZsb2F0aW5nIGVsZW1lbnRzIGZvciBhXG4gKiBnaXZlbiBmbG9hdGluZyBlbGVtZW50IGByb2xlYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VSb2xlXG4gKi9cbmZ1bmN0aW9uIHVzZVJvbGUoY29udGV4dCwgcHJvcHMpIHtcbiAgdmFyIF9jb21wb25lbnRSb2xlVG9BcmlhUjtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIGZsb2F0aW5nSWRcbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBlbmFibGVkID0gdHJ1ZSxcbiAgICByb2xlID0gJ2RpYWxvZydcbiAgfSA9IHByb3BzO1xuICBjb25zdCBhcmlhUm9sZSA9IChfY29tcG9uZW50Um9sZVRvQXJpYVIgPSBjb21wb25lbnRSb2xlVG9BcmlhUm9sZU1hcC5nZXQocm9sZSkpICE9IG51bGwgPyBfY29tcG9uZW50Um9sZVRvQXJpYVIgOiByb2xlO1xuICBjb25zdCByZWZlcmVuY2VJZCA9IHVzZUlkKCk7XG4gIGNvbnN0IHBhcmVudElkID0gdXNlRmxvYXRpbmdQYXJlbnROb2RlSWQoKTtcbiAgY29uc3QgaXNOZXN0ZWQgPSBwYXJlbnRJZCAhPSBudWxsO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm4ge307XG4gICAgY29uc3QgZmxvYXRpbmdQcm9wcyA9IHtcbiAgICAgIGlkOiBmbG9hdGluZ0lkLFxuICAgICAgLi4uKGFyaWFSb2xlICYmIHtcbiAgICAgICAgcm9sZTogYXJpYVJvbGVcbiAgICAgIH0pXG4gICAgfTtcbiAgICBpZiAoYXJpYVJvbGUgPT09ICd0b29sdGlwJyB8fCByb2xlID09PSAnbGFiZWwnKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgICBbXCJhcmlhLVwiICsgKHJvbGUgPT09ICdsYWJlbCcgPyAnbGFiZWxsZWRieScgOiAnZGVzY3JpYmVkYnknKV06IG9wZW4gPyBmbG9hdGluZ0lkIDogdW5kZWZpbmVkXG4gICAgICAgIH0sXG4gICAgICAgIGZsb2F0aW5nOiBmbG9hdGluZ1Byb3BzXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVmZXJlbmNlOiB7XG4gICAgICAgICdhcmlhLWV4cGFuZGVkJzogb3BlbiA/ICd0cnVlJyA6ICdmYWxzZScsXG4gICAgICAgICdhcmlhLWhhc3BvcHVwJzogYXJpYVJvbGUgPT09ICdhbGVydGRpYWxvZycgPyAnZGlhbG9nJyA6IGFyaWFSb2xlLFxuICAgICAgICAnYXJpYS1jb250cm9scyc6IG9wZW4gPyBmbG9hdGluZ0lkIDogdW5kZWZpbmVkLFxuICAgICAgICAuLi4oYXJpYVJvbGUgPT09ICdsaXN0Ym94JyAmJiB7XG4gICAgICAgICAgcm9sZTogJ2NvbWJvYm94J1xuICAgICAgICB9KSxcbiAgICAgICAgLi4uKGFyaWFSb2xlID09PSAnbWVudScgJiYge1xuICAgICAgICAgIGlkOiByZWZlcmVuY2VJZFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKGFyaWFSb2xlID09PSAnbWVudScgJiYgaXNOZXN0ZWQgJiYge1xuICAgICAgICAgIHJvbGU6ICdtZW51aXRlbSdcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihyb2xlID09PSAnc2VsZWN0JyAmJiB7XG4gICAgICAgICAgJ2FyaWEtYXV0b2NvbXBsZXRlJzogJ25vbmUnXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4ocm9sZSA9PT0gJ2NvbWJvYm94JyAmJiB7XG4gICAgICAgICAgJ2FyaWEtYXV0b2NvbXBsZXRlJzogJ2xpc3QnXG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgZmxvYXRpbmc6IHtcbiAgICAgICAgLi4uZmxvYXRpbmdQcm9wcyxcbiAgICAgICAgLi4uKGFyaWFSb2xlID09PSAnbWVudScgJiYge1xuICAgICAgICAgICdhcmlhLWxhYmVsbGVkYnknOiByZWZlcmVuY2VJZFxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIGl0ZW0oX3JlZikge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGFjdGl2ZSxcbiAgICAgICAgICBzZWxlY3RlZFxuICAgICAgICB9ID0gX3JlZjtcbiAgICAgICAgY29uc3QgY29tbW9uUHJvcHMgPSB7XG4gICAgICAgICAgcm9sZTogJ29wdGlvbicsXG4gICAgICAgICAgLi4uKGFjdGl2ZSAmJiB7XG4gICAgICAgICAgICBpZDogZmxvYXRpbmdJZCArIFwiLW9wdGlvblwiXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBGb3IgYG1lbnVgLCB3ZSBhcmUgdW5hYmxlIHRvIHRlbGwgaWYgdGhlIGl0ZW0gaXMgYSBgbWVudWl0ZW1yYWRpb2BcbiAgICAgICAgLy8gb3IgYG1lbnVpdGVtY2hlY2tib3hgLiBGb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgcmVhc29ucywgYWxzb1xuICAgICAgICAvLyBhdm9pZCBkZWZhdWx0aW5nIHRvIGBtZW51aXRlbWAgYXMgaXQgbWF5IG92ZXJ3cml0ZSBjdXN0b20gcm9sZSBwcm9wcy5cbiAgICAgICAgc3dpdGNoIChyb2xlKSB7XG4gICAgICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLmNvbW1vblByb3BzLFxuICAgICAgICAgICAgICAnYXJpYS1zZWxlY3RlZCc6IGFjdGl2ZSAmJiBzZWxlY3RlZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICBjYXNlICdjb21ib2JveCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uY29tbW9uUHJvcHMsXG4gICAgICAgICAgICAgICAgLi4uKGFjdGl2ZSAmJiB7XG4gICAgICAgICAgICAgICAgICAnYXJpYS1zZWxlY3RlZCc6IHRydWVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZW5hYmxlZCwgcm9sZSwgYXJpYVJvbGUsIG9wZW4sIGZsb2F0aW5nSWQsIHJlZmVyZW5jZUlkLCBpc05lc3RlZF0pO1xufVxuXG4vLyBDb252ZXJ0cyBhIEpTIHN0eWxlIGtleSBsaWtlIGBiYWNrZ3JvdW5kQ29sb3JgIHRvIGEgQ1NTIHRyYW5zaXRpb24tcHJvcGVydHlcbi8vIGxpa2UgYGJhY2tncm91bmQtY29sb3JgLlxuY29uc3QgY2FtZWxDYXNlVG9LZWJhYkNhc2UgPSBzdHIgPT4gc3RyLnJlcGxhY2UoL1tBLVpdKyg/IVthLXpdKXxbQS1aXS9nLCAoJCwgb2ZzKSA9PiAob2ZzID8gJy0nIDogJycpICsgJC50b0xvd2VyQ2FzZSgpKTtcbmZ1bmN0aW9uIGV4ZWNXaXRoQXJnc09yUmV0dXJuKHZhbHVlT3JGbiwgYXJncykge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlT3JGbiA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlT3JGbihhcmdzKSA6IHZhbHVlT3JGbjtcbn1cbmZ1bmN0aW9uIHVzZURlbGF5VW5tb3VudChvcGVuLCBkdXJhdGlvbk1zKSB7XG4gIGNvbnN0IFtpc01vdW50ZWQsIHNldElzTW91bnRlZF0gPSBSZWFjdC51c2VTdGF0ZShvcGVuKTtcbiAgaWYgKG9wZW4gJiYgIWlzTW91bnRlZCkge1xuICAgIHNldElzTW91bnRlZCh0cnVlKTtcbiAgfVxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghb3Blbikge1xuICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gc2V0SXNNb3VudGVkKGZhbHNlKSwgZHVyYXRpb25Ncyk7XG4gICAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIH1cbiAgfSwgW29wZW4sIGR1cmF0aW9uTXNdKTtcbiAgcmV0dXJuIGlzTW91bnRlZDtcbn1cbi8qKlxuICogUHJvdmlkZXMgYSBzdGF0dXMgc3RyaW5nIHRvIGFwcGx5IENTUyB0cmFuc2l0aW9ucyB0byBhIGZsb2F0aW5nIGVsZW1lbnQsXG4gKiBjb3JyZWN0bHkgaGFuZGxpbmcgcGxhY2VtZW50LWF3YXJlIHRyYW5zaXRpb25zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZVRyYW5zaXRpb24jdXNldHJhbnNpdGlvbnN0YXR1c1xuICovXG5mdW5jdGlvbiB1c2VUcmFuc2l0aW9uU3RhdHVzKGNvbnRleHQsIHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBlbGVtZW50czoge1xuICAgICAgZmxvYXRpbmdcbiAgICB9XG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgZHVyYXRpb24gPSAyNTBcbiAgfSA9IHByb3BzO1xuICBjb25zdCBpc051bWJlckR1cmF0aW9uID0gdHlwZW9mIGR1cmF0aW9uID09PSAnbnVtYmVyJztcbiAgY29uc3QgY2xvc2VEdXJhdGlvbiA9IChpc051bWJlckR1cmF0aW9uID8gZHVyYXRpb24gOiBkdXJhdGlvbi5jbG9zZSkgfHwgMDtcbiAgY29uc3QgW2luaXRpYXRlZCwgc2V0SW5pdGlhdGVkXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3N0YXR1cywgc2V0U3RhdHVzXSA9IFJlYWN0LnVzZVN0YXRlKCd1bm1vdW50ZWQnKTtcbiAgY29uc3QgaXNNb3VudGVkID0gdXNlRGVsYXlVbm1vdW50KG9wZW4sIGNsb3NlRHVyYXRpb24pO1xuXG4gIC8vIGBpbml0aWF0ZWRgIGNoZWNrIHByZXZlbnRzIHRoaXMgYHNldFN0YXRlYCBjYWxsIGZyb20gYnJlYWtpbmdcbiAgLy8gPEZsb2F0aW5nUG9ydGFsIC8+LiBUaGlzIGNhbGwgaXMgbmVjZXNzYXJ5IHRvIGVuc3VyZSBzdWJzZXF1ZW50IG9wZW5zXG4gIC8vIGFmdGVyIHRoZSBpbml0aWFsIG9uZSBhbGxvd3MgdGhlIGNvcnJlY3Qgc2lkZSBhbmltYXRpb24gdG8gcGxheSB3aGVuIHRoZVxuICAvLyBwbGFjZW1lbnQgaGFzIGNoYW5nZWQuXG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAoaW5pdGlhdGVkICYmICFpc01vdW50ZWQpIHtcbiAgICAgIHNldFN0YXR1cygndW5tb3VudGVkJyk7XG4gICAgfVxuICB9LCBbaW5pdGlhdGVkLCBpc01vdW50ZWRdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmICghZmxvYXRpbmcpIHJldHVybjtcbiAgICBpZiAob3Blbikge1xuICAgICAgc2V0U3RhdHVzKCdpbml0aWFsJyk7XG4gICAgICBjb25zdCBmcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHNldFN0YXR1cygnb3BlbicpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRJbml0aWF0ZWQodHJ1ZSk7XG4gICAgICBzZXRTdGF0dXMoJ2Nsb3NlJyk7XG4gICAgfVxuICB9LCBbb3BlbiwgZmxvYXRpbmddKTtcbiAgcmV0dXJuIHtcbiAgICBpc01vdW50ZWQsXG4gICAgc3RhdHVzXG4gIH07XG59XG4vKipcbiAqIFByb3ZpZGVzIHN0eWxlcyB0byBhcHBseSBDU1MgdHJhbnNpdGlvbnMgdG8gYSBmbG9hdGluZyBlbGVtZW50LCBjb3JyZWN0bHlcbiAqIGhhbmRsaW5nIHBsYWNlbWVudC1hd2FyZSB0cmFuc2l0aW9ucy4gV3JhcHBlciBhcm91bmQgYHVzZVRyYW5zaXRpb25TdGF0dXNgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZVRyYW5zaXRpb24jdXNldHJhbnNpdGlvbnN0eWxlc1xuICovXG5mdW5jdGlvbiB1c2VUcmFuc2l0aW9uU3R5bGVzKGNvbnRleHQsIHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgaW5pdGlhbDogdW5zdGFibGVfaW5pdGlhbCA9IHtcbiAgICAgIG9wYWNpdHk6IDBcbiAgICB9LFxuICAgIG9wZW46IHVuc3RhYmxlX29wZW4sXG4gICAgY2xvc2U6IHVuc3RhYmxlX2Nsb3NlLFxuICAgIGNvbW1vbjogdW5zdGFibGVfY29tbW9uLFxuICAgIGR1cmF0aW9uID0gMjUwXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgcGxhY2VtZW50ID0gY29udGV4dC5wbGFjZW1lbnQ7XG4gIGNvbnN0IHNpZGUgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgY29uc3QgZm5BcmdzID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHNpZGUsXG4gICAgcGxhY2VtZW50XG4gIH0pLCBbc2lkZSwgcGxhY2VtZW50XSk7XG4gIGNvbnN0IGlzTnVtYmVyRHVyYXRpb24gPSB0eXBlb2YgZHVyYXRpb24gPT09ICdudW1iZXInO1xuICBjb25zdCBvcGVuRHVyYXRpb24gPSAoaXNOdW1iZXJEdXJhdGlvbiA/IGR1cmF0aW9uIDogZHVyYXRpb24ub3BlbikgfHwgMDtcbiAgY29uc3QgY2xvc2VEdXJhdGlvbiA9IChpc051bWJlckR1cmF0aW9uID8gZHVyYXRpb24gOiBkdXJhdGlvbi5jbG9zZSkgfHwgMDtcbiAgY29uc3QgW3N0eWxlcywgc2V0U3R5bGVzXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+ICh7XG4gICAgLi4uZXhlY1dpdGhBcmdzT3JSZXR1cm4odW5zdGFibGVfY29tbW9uLCBmbkFyZ3MpLFxuICAgIC4uLmV4ZWNXaXRoQXJnc09yUmV0dXJuKHVuc3RhYmxlX2luaXRpYWwsIGZuQXJncylcbiAgfSkpO1xuICBjb25zdCB7XG4gICAgaXNNb3VudGVkLFxuICAgIHN0YXR1c1xuICB9ID0gdXNlVHJhbnNpdGlvblN0YXR1cyhjb250ZXh0LCB7XG4gICAgZHVyYXRpb25cbiAgfSk7XG4gIGNvbnN0IGluaXRpYWxSZWYgPSB1c2VMYXRlc3RSZWYodW5zdGFibGVfaW5pdGlhbCk7XG4gIGNvbnN0IG9wZW5SZWYgPSB1c2VMYXRlc3RSZWYodW5zdGFibGVfb3Blbik7XG4gIGNvbnN0IGNsb3NlUmVmID0gdXNlTGF0ZXN0UmVmKHVuc3RhYmxlX2Nsb3NlKTtcbiAgY29uc3QgY29tbW9uUmVmID0gdXNlTGF0ZXN0UmVmKHVuc3RhYmxlX2NvbW1vbik7XG4gIGluZGV4KCgpID0+IHtcbiAgICBjb25zdCBpbml0aWFsU3R5bGVzID0gZXhlY1dpdGhBcmdzT3JSZXR1cm4oaW5pdGlhbFJlZi5jdXJyZW50LCBmbkFyZ3MpO1xuICAgIGNvbnN0IGNsb3NlU3R5bGVzID0gZXhlY1dpdGhBcmdzT3JSZXR1cm4oY2xvc2VSZWYuY3VycmVudCwgZm5BcmdzKTtcbiAgICBjb25zdCBjb21tb25TdHlsZXMgPSBleGVjV2l0aEFyZ3NPclJldHVybihjb21tb25SZWYuY3VycmVudCwgZm5BcmdzKTtcbiAgICBjb25zdCBvcGVuU3R5bGVzID0gZXhlY1dpdGhBcmdzT3JSZXR1cm4ob3BlblJlZi5jdXJyZW50LCBmbkFyZ3MpIHx8IE9iamVjdC5rZXlzKGluaXRpYWxTdHlsZXMpLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgIGFjY1trZXldID0gJyc7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgICBpZiAoc3RhdHVzID09PSAnaW5pdGlhbCcpIHtcbiAgICAgIHNldFN0eWxlcyhzdHlsZXMgPT4gKHtcbiAgICAgICAgdHJhbnNpdGlvblByb3BlcnR5OiBzdHlsZXMudHJhbnNpdGlvblByb3BlcnR5LFxuICAgICAgICAuLi5jb21tb25TdHlsZXMsXG4gICAgICAgIC4uLmluaXRpYWxTdHlsZXNcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKHN0YXR1cyA9PT0gJ29wZW4nKSB7XG4gICAgICBzZXRTdHlsZXMoe1xuICAgICAgICB0cmFuc2l0aW9uUHJvcGVydHk6IE9iamVjdC5rZXlzKG9wZW5TdHlsZXMpLm1hcChjYW1lbENhc2VUb0tlYmFiQ2FzZSkuam9pbignLCcpLFxuICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IG9wZW5EdXJhdGlvbiArIFwibXNcIixcbiAgICAgICAgLi4uY29tbW9uU3R5bGVzLFxuICAgICAgICAuLi5vcGVuU3R5bGVzXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHN0YXR1cyA9PT0gJ2Nsb3NlJykge1xuICAgICAgY29uc3Qgc3R5bGVzID0gY2xvc2VTdHlsZXMgfHwgaW5pdGlhbFN0eWxlcztcbiAgICAgIHNldFN0eWxlcyh7XG4gICAgICAgIHRyYW5zaXRpb25Qcm9wZXJ0eTogT2JqZWN0LmtleXMoc3R5bGVzKS5tYXAoY2FtZWxDYXNlVG9LZWJhYkNhc2UpLmpvaW4oJywnKSxcbiAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBjbG9zZUR1cmF0aW9uICsgXCJtc1wiLFxuICAgICAgICAuLi5jb21tb25TdHlsZXMsXG4gICAgICAgIC4uLnN0eWxlc1xuICAgICAgfSk7XG4gICAgfVxuICB9LCBbY2xvc2VEdXJhdGlvbiwgY2xvc2VSZWYsIGluaXRpYWxSZWYsIG9wZW5SZWYsIGNvbW1vblJlZiwgb3BlbkR1cmF0aW9uLCBzdGF0dXMsIGZuQXJnc10pO1xuICByZXR1cm4ge1xuICAgIGlzTW91bnRlZCxcbiAgICBzdHlsZXNcbiAgfTtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBhIG1hdGNoaW5nIGNhbGxiYWNrIHRoYXQgY2FuIGJlIHVzZWQgdG8gZm9jdXMgYW4gaXRlbSBhcyB0aGUgdXNlclxuICogdHlwZXMsIG9mdGVuIHVzZWQgaW4gdGFuZGVtIHdpdGggYHVzZUxpc3ROYXZpZ2F0aW9uKClgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZVR5cGVhaGVhZFxuICovXG5mdW5jdGlvbiB1c2VUeXBlYWhlYWQoY29udGV4dCwgcHJvcHMpIHtcbiAgdmFyIF9yZWY7XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIGRhdGFSZWZcbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBsaXN0UmVmLFxuICAgIGFjdGl2ZUluZGV4LFxuICAgIG9uTWF0Y2g6IHVuc3RhYmxlX29uTWF0Y2gsXG4gICAgb25UeXBpbmdDaGFuZ2U6IHVuc3RhYmxlX29uVHlwaW5nQ2hhbmdlLFxuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIGZpbmRNYXRjaCA9IG51bGwsXG4gICAgcmVzZXRNcyA9IDc1MCxcbiAgICBpZ25vcmVLZXlzID0gW10sXG4gICAgc2VsZWN0ZWRJbmRleCA9IG51bGxcbiAgfSA9IHByb3BzO1xuICBjb25zdCB0aW1lb3V0SWRSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgY29uc3Qgc3RyaW5nUmVmID0gUmVhY3QudXNlUmVmKCcnKTtcbiAgY29uc3QgcHJldkluZGV4UmVmID0gUmVhY3QudXNlUmVmKChfcmVmID0gc2VsZWN0ZWRJbmRleCAhPSBudWxsID8gc2VsZWN0ZWRJbmRleCA6IGFjdGl2ZUluZGV4KSAhPSBudWxsID8gX3JlZiA6IC0xKTtcbiAgY29uc3QgbWF0Y2hJbmRleFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3Qgb25NYXRjaCA9IHVzZUVmZmVjdEV2ZW50KHVuc3RhYmxlX29uTWF0Y2gpO1xuICBjb25zdCBvblR5cGluZ0NoYW5nZSA9IHVzZUVmZmVjdEV2ZW50KHVuc3RhYmxlX29uVHlwaW5nQ2hhbmdlKTtcbiAgY29uc3QgZmluZE1hdGNoUmVmID0gdXNlTGF0ZXN0UmVmKGZpbmRNYXRjaCk7XG4gIGNvbnN0IGlnbm9yZUtleXNSZWYgPSB1c2VMYXRlc3RSZWYoaWdub3JlS2V5cyk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAob3Blbikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZFJlZi5jdXJyZW50KTtcbiAgICAgIG1hdGNoSW5kZXhSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICBzdHJpbmdSZWYuY3VycmVudCA9ICcnO1xuICAgIH1cbiAgfSwgW29wZW5dKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIC8vIFN5bmMgYXJyb3cga2V5IG5hdmlnYXRpb24gYnV0IG5vdCB0eXBlYWhlYWQgbmF2aWdhdGlvbi5cbiAgICBpZiAob3BlbiAmJiBzdHJpbmdSZWYuY3VycmVudCA9PT0gJycpIHtcbiAgICAgIHZhciBfcmVmMjtcbiAgICAgIHByZXZJbmRleFJlZi5jdXJyZW50ID0gKF9yZWYyID0gc2VsZWN0ZWRJbmRleCAhPSBudWxsID8gc2VsZWN0ZWRJbmRleCA6IGFjdGl2ZUluZGV4KSAhPSBudWxsID8gX3JlZjIgOiAtMTtcbiAgICB9XG4gIH0sIFtvcGVuLCBzZWxlY3RlZEluZGV4LCBhY3RpdmVJbmRleF0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFR5cGluZ0NoYW5nZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGlmICghZGF0YVJlZi5jdXJyZW50LnR5cGluZykge1xuICAgICAgICAgIGRhdGFSZWYuY3VycmVudC50eXBpbmcgPSB2YWx1ZTtcbiAgICAgICAgICBvblR5cGluZ0NoYW5nZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChkYXRhUmVmLmN1cnJlbnQudHlwaW5nKSB7XG4gICAgICAgICAgZGF0YVJlZi5jdXJyZW50LnR5cGluZyA9IHZhbHVlO1xuICAgICAgICAgIG9uVHlwaW5nQ2hhbmdlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRNYXRjaGluZ0luZGV4KGxpc3QsIG9yZGVyZWRMaXN0LCBzdHJpbmcpIHtcbiAgICAgIGNvbnN0IHN0ciA9IGZpbmRNYXRjaFJlZi5jdXJyZW50ID8gZmluZE1hdGNoUmVmLmN1cnJlbnQob3JkZXJlZExpc3QsIHN0cmluZykgOiBvcmRlcmVkTGlzdC5maW5kKHRleHQgPT4gKHRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IHRleHQudG9Mb2NhbGVMb3dlckNhc2UoKS5pbmRleE9mKHN0cmluZy50b0xvY2FsZUxvd2VyQ2FzZSgpKSkgPT09IDApO1xuICAgICAgcmV0dXJuIHN0ciA/IGxpc3QuaW5kZXhPZihzdHIpIDogLTE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uS2V5RG93bihldmVudCkge1xuICAgICAgY29uc3QgbGlzdENvbnRlbnQgPSBsaXN0UmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoc3RyaW5nUmVmLmN1cnJlbnQubGVuZ3RoID4gMCAmJiBzdHJpbmdSZWYuY3VycmVudFswXSAhPT0gJyAnKSB7XG4gICAgICAgIGlmIChnZXRNYXRjaGluZ0luZGV4KGxpc3RDb250ZW50LCBsaXN0Q29udGVudCwgc3RyaW5nUmVmLmN1cnJlbnQpID09PSAtMSkge1xuICAgICAgICAgIHNldFR5cGluZ0NoYW5nZShmYWxzZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ID09PSAnICcpIHtcbiAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGlzdENvbnRlbnQgPT0gbnVsbCB8fCBpZ25vcmVLZXlzUmVmLmN1cnJlbnQuaW5jbHVkZXMoZXZlbnQua2V5KSB8fFxuICAgICAgLy8gQ2hhcmFjdGVyIGtleS5cbiAgICAgIGV2ZW50LmtleS5sZW5ndGggIT09IDEgfHxcbiAgICAgIC8vIE1vZGlmaWVyIGtleS5cbiAgICAgIGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG9wZW4gJiYgZXZlbnQua2V5ICE9PSAnICcpIHtcbiAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgc2V0VHlwaW5nQ2hhbmdlKHRydWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBCYWlsIG91dCBpZiB0aGUgbGlzdCBjb250YWlucyBhIHdvcmQgbGlrZSBcImxsYW1hXCIgb3IgXCJhYXJvblwiLiBUT0RPOlxuICAgICAgLy8gYWxsb3cgaXQgaW4gdGhpcyBjYXNlLCB0b28uXG4gICAgICBjb25zdCBhbGxvd1JhcGlkU3VjY2Vzc2lvbk9mRmlyc3RMZXR0ZXIgPSBsaXN0Q29udGVudC5ldmVyeSh0ZXh0ID0+IHtcbiAgICAgICAgdmFyIF90ZXh0JCwgX3RleHQkMjtcbiAgICAgICAgcmV0dXJuIHRleHQgPyAoKF90ZXh0JCA9IHRleHRbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfdGV4dCQudG9Mb2NhbGVMb3dlckNhc2UoKSkgIT09ICgoX3RleHQkMiA9IHRleHRbMV0pID09IG51bGwgPyB2b2lkIDAgOiBfdGV4dCQyLnRvTG9jYWxlTG93ZXJDYXNlKCkpIDogdHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBbGxvd3MgdGhlIHVzZXIgdG8gY3ljbGUgdGhyb3VnaCBpdGVtcyB0aGF0IHN0YXJ0IHdpdGggdGhlIHNhbWUgbGV0dGVyXG4gICAgICAvLyBpbiByYXBpZCBzdWNjZXNzaW9uLlxuICAgICAgaWYgKGFsbG93UmFwaWRTdWNjZXNzaW9uT2ZGaXJzdExldHRlciAmJiBzdHJpbmdSZWYuY3VycmVudCA9PT0gZXZlbnQua2V5KSB7XG4gICAgICAgIHN0cmluZ1JlZi5jdXJyZW50ID0gJyc7XG4gICAgICAgIHByZXZJbmRleFJlZi5jdXJyZW50ID0gbWF0Y2hJbmRleFJlZi5jdXJyZW50O1xuICAgICAgfVxuICAgICAgc3RyaW5nUmVmLmN1cnJlbnQgKz0gZXZlbnQua2V5O1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZFJlZi5jdXJyZW50KTtcbiAgICAgIHRpbWVvdXRJZFJlZi5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHN0cmluZ1JlZi5jdXJyZW50ID0gJyc7XG4gICAgICAgIHByZXZJbmRleFJlZi5jdXJyZW50ID0gbWF0Y2hJbmRleFJlZi5jdXJyZW50O1xuICAgICAgICBzZXRUeXBpbmdDaGFuZ2UoZmFsc2UpO1xuICAgICAgfSwgcmVzZXRNcyk7XG4gICAgICBjb25zdCBwcmV2SW5kZXggPSBwcmV2SW5kZXhSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IGluZGV4ID0gZ2V0TWF0Y2hpbmdJbmRleChsaXN0Q29udGVudCwgWy4uLmxpc3RDb250ZW50LnNsaWNlKChwcmV2SW5kZXggfHwgMCkgKyAxKSwgLi4ubGlzdENvbnRlbnQuc2xpY2UoMCwgKHByZXZJbmRleCB8fCAwKSArIDEpXSwgc3RyaW5nUmVmLmN1cnJlbnQpO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICBvbk1hdGNoKGluZGV4KTtcbiAgICAgICAgbWF0Y2hJbmRleFJlZi5jdXJyZW50ID0gaW5kZXg7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleSAhPT0gJyAnKSB7XG4gICAgICAgIHN0cmluZ1JlZi5jdXJyZW50ID0gJyc7XG4gICAgICAgIHNldFR5cGluZ0NoYW5nZShmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZWZlcmVuY2U6IHtcbiAgICAgICAgb25LZXlEb3duXG4gICAgICB9LFxuICAgICAgZmxvYXRpbmc6IHtcbiAgICAgICAgb25LZXlEb3duLFxuICAgICAgICBvbktleVVwKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJyAnKSB7XG4gICAgICAgICAgICBzZXRUeXBpbmdDaGFuZ2UoZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0sIFtlbmFibGVkLCBvcGVuLCBkYXRhUmVmLCBsaXN0UmVmLCByZXNldE1zLCBpZ25vcmVLZXlzUmVmLCBmaW5kTWF0Y2hSZWYsIG9uTWF0Y2gsIG9uVHlwaW5nQ2hhbmdlXSk7XG59XG5cbmZ1bmN0aW9uIGdldEFyZ3NXaXRoQ3VzdG9tRmxvYXRpbmdIZWlnaHQoc3RhdGUsIGhlaWdodCkge1xuICByZXR1cm4ge1xuICAgIC4uLnN0YXRlLFxuICAgIHJlY3RzOiB7XG4gICAgICAuLi5zdGF0ZS5yZWN0cyxcbiAgICAgIGZsb2F0aW5nOiB7XG4gICAgICAgIC4uLnN0YXRlLnJlY3RzLmZsb2F0aW5nLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG4vKipcbiAqIFBvc2l0aW9ucyB0aGUgZmxvYXRpbmcgZWxlbWVudCBzdWNoIHRoYXQgYW4gaW5uZXIgZWxlbWVudCBpbnNpZGVcbiAqIG9mIGl0IGlzIGFuY2hvcmVkIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9pbm5lclxuICovXG5jb25zdCBpbm5lciA9IHByb3BzID0+ICh7XG4gIG5hbWU6ICdpbm5lcicsXG4gIG9wdGlvbnM6IHByb3BzLFxuICBhc3luYyBmbihzdGF0ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxpc3RSZWYsXG4gICAgICBvdmVyZmxvd1JlZixcbiAgICAgIG9uRmFsbGJhY2tDaGFuZ2UsXG4gICAgICBvZmZzZXQ6IGlubmVyT2Zmc2V0ID0gMCxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIG1pbkl0ZW1zVmlzaWJsZSA9IDQsXG4gICAgICByZWZlcmVuY2VPdmVyZmxvd1RocmVzaG9sZCA9IDAsXG4gICAgICBzY3JvbGxSZWYsXG4gICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICB9ID0gcHJvcHM7XG4gICAgY29uc3Qge1xuICAgICAgcmVjdHMsXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICBmbG9hdGluZ1xuICAgICAgfVxuICAgIH0gPSBzdGF0ZTtcbiAgICBjb25zdCBpdGVtID0gbGlzdFJlZi5jdXJyZW50W2luZGV4XTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAoIXN0YXRlLnBsYWNlbWVudC5zdGFydHNXaXRoKCdib3R0b20nKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oWydGbG9hdGluZyBVSTogYHBsYWNlbWVudGAgc2lkZSBtdXN0IGJlIFwiYm90dG9tXCIgd2hlbiB1c2luZyB0aGUnLCAnYGlubmVyYCBtaWRkbGV3YXJlLiddLmpvaW4oJyAnKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghaXRlbSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjb25zdCBuZXh0QXJncyA9IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgLi4uKGF3YWl0IG9mZnNldCgtaXRlbS5vZmZzZXRUb3AgLSBmbG9hdGluZy5jbGllbnRUb3AgLSByZWN0cy5yZWZlcmVuY2UuaGVpZ2h0IC8gMiAtIGl0ZW0ub2Zmc2V0SGVpZ2h0IC8gMiAtIGlubmVyT2Zmc2V0KS5mbihzdGF0ZSkpXG4gICAgfTtcbiAgICBjb25zdCBlbCA9IChzY3JvbGxSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IHNjcm9sbFJlZi5jdXJyZW50KSB8fCBmbG9hdGluZztcbiAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KGdldEFyZ3NXaXRoQ3VzdG9tRmxvYXRpbmdIZWlnaHQobmV4dEFyZ3MsIGVsLnNjcm9sbEhlaWdodCksIGRldGVjdE92ZXJmbG93T3B0aW9ucyk7XG4gICAgY29uc3QgcmVmT3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhuZXh0QXJncywge1xuICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zLFxuICAgICAgZWxlbWVudENvbnRleHQ6ICdyZWZlcmVuY2UnXG4gICAgfSk7XG4gICAgY29uc3QgZGlmZlkgPSBNYXRoLm1heCgwLCBvdmVyZmxvdy50b3ApO1xuICAgIGNvbnN0IG5leHRZID0gbmV4dEFyZ3MueSArIGRpZmZZO1xuICAgIGNvbnN0IG1heEhlaWdodCA9IE1hdGgubWF4KDAsIGVsLnNjcm9sbEhlaWdodCAtIGRpZmZZIC0gTWF0aC5tYXgoMCwgb3ZlcmZsb3cuYm90dG9tKSk7XG4gICAgZWwuc3R5bGUubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0ICsgXCJweFwiO1xuICAgIGVsLnNjcm9sbFRvcCA9IGRpZmZZO1xuXG4gICAgLy8gVGhlcmUgaXMgbm90IGVub3VnaCBzcGFjZSwgZmFsbGJhY2sgdG8gc3RhbmRhcmQgYW5jaG9yZWQgcG9zaXRpb25pbmdcbiAgICBpZiAob25GYWxsYmFja0NoYW5nZSkge1xuICAgICAgaWYgKGVsLm9mZnNldEhlaWdodCA8IGl0ZW0ub2Zmc2V0SGVpZ2h0ICogTWF0aC5taW4obWluSXRlbXNWaXNpYmxlLCBsaXN0UmVmLmN1cnJlbnQubGVuZ3RoIC0gMSkgLSAxIHx8IHJlZk92ZXJmbG93LnRvcCA+PSAtcmVmZXJlbmNlT3ZlcmZsb3dUaHJlc2hvbGQgfHwgcmVmT3ZlcmZsb3cuYm90dG9tID49IC1yZWZlcmVuY2VPdmVyZmxvd1RocmVzaG9sZCkge1xuICAgICAgICBmbHVzaFN5bmMoKCkgPT4gb25GYWxsYmFja0NoYW5nZSh0cnVlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbHVzaFN5bmMoKCkgPT4gb25GYWxsYmFja0NoYW5nZShmYWxzZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3ZlcmZsb3dSZWYpIHtcbiAgICAgIG92ZXJmbG93UmVmLmN1cnJlbnQgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhnZXRBcmdzV2l0aEN1c3RvbUZsb2F0aW5nSGVpZ2h0KHtcbiAgICAgICAgLi4ubmV4dEFyZ3MsXG4gICAgICAgIHk6IG5leHRZXG4gICAgICB9LCBlbC5vZmZzZXRIZWlnaHQpLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgeTogbmV4dFlcbiAgICB9O1xuICB9XG59KTtcbi8qKlxuICogQ2hhbmdlcyB0aGUgYGlubmVyYCBtaWRkbGV3YXJlJ3MgYG9mZnNldGAgdXBvbiBhIGB3aGVlbGAgZXZlbnQgdG9cbiAqIGV4cGFuZCB0aGUgZmxvYXRpbmcgZWxlbWVudCdzIGhlaWdodCwgcmV2ZWFsaW5nIG1vcmUgbGlzdCBpdGVtcy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9pbm5lclxuICovXG5mdW5jdGlvbiB1c2VJbm5lck9mZnNldChjb250ZXh0LCBwcm9wcykge1xuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBlbGVtZW50c1xuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIG92ZXJmbG93UmVmLFxuICAgIHNjcm9sbFJlZixcbiAgICBvbkNoYW5nZTogdW5zdGFibGVfb25DaGFuZ2VcbiAgfSA9IHByb3BzO1xuICBjb25zdCBvbkNoYW5nZSA9IHVzZUVmZmVjdEV2ZW50KHVuc3RhYmxlX29uQ2hhbmdlKTtcbiAgY29uc3QgY29udHJvbGxlZFNjcm9sbGluZ1JlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHByZXZTY3JvbGxUb3BSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGluaXRpYWxPdmVyZmxvd1JlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25XaGVlbChlKSB7XG4gICAgICBpZiAoZS5jdHJsS2V5IHx8ICFlbCB8fCBvdmVyZmxvd1JlZi5jdXJyZW50ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZFkgPSBlLmRlbHRhWTtcbiAgICAgIGNvbnN0IGlzQXRUb3AgPSBvdmVyZmxvd1JlZi5jdXJyZW50LnRvcCA+PSAtMC41O1xuICAgICAgY29uc3QgaXNBdEJvdHRvbSA9IG92ZXJmbG93UmVmLmN1cnJlbnQuYm90dG9tID49IC0wLjU7XG4gICAgICBjb25zdCByZW1haW5pbmdTY3JvbGwgPSBlbC5zY3JvbGxIZWlnaHQgLSBlbC5jbGllbnRIZWlnaHQ7XG4gICAgICBjb25zdCBzaWduID0gZFkgPCAwID8gLTEgOiAxO1xuICAgICAgY29uc3QgbWV0aG9kID0gZFkgPCAwID8gJ21heCcgOiAnbWluJztcbiAgICAgIGlmIChlbC5zY3JvbGxIZWlnaHQgPD0gZWwuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghaXNBdFRvcCAmJiBkWSA+IDAgfHwgIWlzQXRCb3R0b20gJiYgZFkgPCAwKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgICBvbkNoYW5nZShkID0+IGQgKyBNYXRoW21ldGhvZF0oZFksIHJlbWFpbmluZ1Njcm9sbCAqIHNpZ24pKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKC9maXJlZm94L2kudGVzdChnZXRVc2VyQWdlbnQoKSkpIHtcbiAgICAgICAgLy8gTmVlZGVkIHRvIHByb3BhZ2F0ZSBzY3JvbGxpbmcgZHVyaW5nIG1vbWVudHVtIHNjcm9sbGluZyBwaGFzZSBvbmNlXG4gICAgICAgIC8vIGl0IGdldHMgbGltaXRlZCBieSB0aGUgYm91bmRhcnkuIFVYIGltcHJvdmVtZW50LCBub3QgY3JpdGljYWwuXG4gICAgICAgIGVsLnNjcm9sbFRvcCArPSBkWTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZWwgPSAoc2Nyb2xsUmVmID09IG51bGwgPyB2b2lkIDAgOiBzY3JvbGxSZWYuY3VycmVudCkgfHwgZWxlbWVudHMuZmxvYXRpbmc7XG4gICAgaWYgKG9wZW4gJiYgZWwpIHtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgb25XaGVlbCk7XG5cbiAgICAgIC8vIFdhaXQgZm9yIHRoZSBwb3NpdGlvbiB0byBiZSByZWFkeS5cbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHByZXZTY3JvbGxUb3BSZWYuY3VycmVudCA9IGVsLnNjcm9sbFRvcDtcbiAgICAgICAgaWYgKG92ZXJmbG93UmVmLmN1cnJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgIGluaXRpYWxPdmVyZmxvd1JlZi5jdXJyZW50ID0ge1xuICAgICAgICAgICAgLi4ub3ZlcmZsb3dSZWYuY3VycmVudFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgcHJldlNjcm9sbFRvcFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgaW5pdGlhbE92ZXJmbG93UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIG9uV2hlZWwpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtlbmFibGVkLCBvcGVuLCBlbGVtZW50cy5mbG9hdGluZywgb3ZlcmZsb3dSZWYsIHNjcm9sbFJlZiwgb25DaGFuZ2VdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZmxvYXRpbmc6IHtcbiAgICAgICAgb25LZXlEb3duKCkge1xuICAgICAgICAgIGNvbnRyb2xsZWRTY3JvbGxpbmdSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIG9uV2hlZWwoKSB7XG4gICAgICAgICAgY29udHJvbGxlZFNjcm9sbGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUG9pbnRlck1vdmUoKSB7XG4gICAgICAgICAgY29udHJvbGxlZFNjcm9sbGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIG9uU2Nyb2xsKCkge1xuICAgICAgICAgIGNvbnN0IGVsID0gKHNjcm9sbFJlZiA9PSBudWxsID8gdm9pZCAwIDogc2Nyb2xsUmVmLmN1cnJlbnQpIHx8IGVsZW1lbnRzLmZsb2F0aW5nO1xuICAgICAgICAgIGlmICghb3ZlcmZsb3dSZWYuY3VycmVudCB8fCAhZWwgfHwgIWNvbnRyb2xsZWRTY3JvbGxpbmdSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJldlNjcm9sbFRvcFJlZi5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBzY3JvbGxEaWZmID0gZWwuc2Nyb2xsVG9wIC0gcHJldlNjcm9sbFRvcFJlZi5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKG92ZXJmbG93UmVmLmN1cnJlbnQuYm90dG9tIDwgLTAuNSAmJiBzY3JvbGxEaWZmIDwgLTEgfHwgb3ZlcmZsb3dSZWYuY3VycmVudC50b3AgPCAtMC41ICYmIHNjcm9sbERpZmYgPiAxKSB7XG4gICAgICAgICAgICAgIGZsdXNoU3luYygoKSA9PiBvbkNoYW5nZShkID0+IGQgKyBzY3JvbGxEaWZmKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gW0ZpcmVmb3hdIFdhaXQgZm9yIHRoZSBoZWlnaHQgY2hhbmdlIHRvIGhhdmUgYmVlbiBhcHBsaWVkLlxuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICBwcmV2U2Nyb2xsVG9wUmVmLmN1cnJlbnQgPSBlbC5zY3JvbGxUb3A7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZW5hYmxlZCwgb3ZlcmZsb3dSZWYsIGVsZW1lbnRzLmZsb2F0aW5nLCBzY3JvbGxSZWYsIG9uQ2hhbmdlXSk7XG59XG5cbmZ1bmN0aW9uIGlzUG9pbnRJblBvbHlnb24ocG9pbnQsIHBvbHlnb24pIHtcbiAgY29uc3QgW3gsIHldID0gcG9pbnQ7XG4gIGxldCBpc0luc2lkZSA9IGZhbHNlO1xuICBjb25zdCBsZW5ndGggPSBwb2x5Z29uLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDAsIGogPSBsZW5ndGggLSAxOyBpIDwgbGVuZ3RoOyBqID0gaSsrKSB7XG4gICAgY29uc3QgW3hpLCB5aV0gPSBwb2x5Z29uW2ldIHx8IFswLCAwXTtcbiAgICBjb25zdCBbeGosIHlqXSA9IHBvbHlnb25bal0gfHwgWzAsIDBdO1xuICAgIGNvbnN0IGludGVyc2VjdCA9IHlpID49IHkgIT09IHlqID49IHkgJiYgeCA8PSAoeGogLSB4aSkgKiAoeSAtIHlpKSAvICh5aiAtIHlpKSArIHhpO1xuICAgIGlmIChpbnRlcnNlY3QpIHtcbiAgICAgIGlzSW5zaWRlID0gIWlzSW5zaWRlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXNJbnNpZGU7XG59XG5mdW5jdGlvbiBpc0luc2lkZShwb2ludCwgcmVjdCkge1xuICByZXR1cm4gcG9pbnRbMF0gPj0gcmVjdC54ICYmIHBvaW50WzBdIDw9IHJlY3QueCArIHJlY3Qud2lkdGggJiYgcG9pbnRbMV0gPj0gcmVjdC55ICYmIHBvaW50WzFdIDw9IHJlY3QueSArIHJlY3QuaGVpZ2h0O1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBzYWZlIHBvbHlnb24gYXJlYSB0aGF0IHRoZSB1c2VyIGNhbiB0cmF2ZXJzZSB3aXRob3V0IGNsb3NpbmcgdGhlXG4gKiBmbG9hdGluZyBlbGVtZW50IG9uY2UgbGVhdmluZyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlSG92ZXIjc2FmZVBvbHlnb25cbiAqL1xuZnVuY3Rpb24gc2FmZVBvbHlnb24ob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBidWZmZXIgPSAwLjUsXG4gICAgYmxvY2tQb2ludGVyRXZlbnRzID0gZmFsc2UsXG4gICAgcmVxdWlyZUludGVudCA9IHRydWVcbiAgfSA9IG9wdGlvbnM7XG4gIGxldCB0aW1lb3V0SWQ7XG4gIGxldCBoYXNMYW5kZWQgPSBmYWxzZTtcbiAgbGV0IGxhc3RYID0gbnVsbDtcbiAgbGV0IGxhc3RZID0gbnVsbDtcbiAgbGV0IGxhc3RDdXJzb3JUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gIGZ1bmN0aW9uIGdldEN1cnNvclNwZWVkKHgsIHkpIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IGVsYXBzZWRUaW1lID0gY3VycmVudFRpbWUgLSBsYXN0Q3Vyc29yVGltZTtcbiAgICBpZiAobGFzdFggPT09IG51bGwgfHwgbGFzdFkgPT09IG51bGwgfHwgZWxhcHNlZFRpbWUgPT09IDApIHtcbiAgICAgIGxhc3RYID0geDtcbiAgICAgIGxhc3RZID0geTtcbiAgICAgIGxhc3RDdXJzb3JUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZGVsdGFYID0geCAtIGxhc3RYO1xuICAgIGNvbnN0IGRlbHRhWSA9IHkgLSBsYXN0WTtcbiAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkZWx0YVggKiBkZWx0YVggKyBkZWx0YVkgKiBkZWx0YVkpO1xuICAgIGNvbnN0IHNwZWVkID0gZGlzdGFuY2UgLyBlbGFwc2VkVGltZTsgLy8gcHggLyBtc1xuXG4gICAgbGFzdFggPSB4O1xuICAgIGxhc3RZID0geTtcbiAgICBsYXN0Q3Vyc29yVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIHJldHVybiBzcGVlZDtcbiAgfVxuICBjb25zdCBmbiA9IF9yZWYgPT4ge1xuICAgIGxldCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHBsYWNlbWVudCxcbiAgICAgIGVsZW1lbnRzLFxuICAgICAgb25DbG9zZSxcbiAgICAgIG5vZGVJZCxcbiAgICAgIHRyZWVcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4gZnVuY3Rpb24gb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgb25DbG9zZSgpO1xuICAgICAgfVxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICBpZiAoIWVsZW1lbnRzLmRvbVJlZmVyZW5jZSB8fCAhZWxlbWVudHMuZmxvYXRpbmcgfHwgcGxhY2VtZW50ID09IG51bGwgfHwgeCA9PSBudWxsIHx8IHkgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNsaWVudFgsXG4gICAgICAgIGNsaWVudFlcbiAgICAgIH0gPSBldmVudDtcbiAgICAgIGNvbnN0IGNsaWVudFBvaW50ID0gW2NsaWVudFgsIGNsaWVudFldO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGV2ZW50KTtcbiAgICAgIGNvbnN0IGlzTGVhdmUgPSBldmVudC50eXBlID09PSAnbW91c2VsZWF2ZSc7XG4gICAgICBjb25zdCBpc092ZXJGbG9hdGluZ0VsID0gY29udGFpbnMoZWxlbWVudHMuZmxvYXRpbmcsIHRhcmdldCk7XG4gICAgICBjb25zdCBpc092ZXJSZWZlcmVuY2VFbCA9IGNvbnRhaW5zKGVsZW1lbnRzLmRvbVJlZmVyZW5jZSwgdGFyZ2V0KTtcbiAgICAgIGNvbnN0IHJlZlJlY3QgPSBlbGVtZW50cy5kb21SZWZlcmVuY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCByZWN0ID0gZWxlbWVudHMuZmxvYXRpbmcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBzaWRlID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gICAgICBjb25zdCBjdXJzb3JMZWF2ZUZyb21SaWdodCA9IHggPiByZWN0LnJpZ2h0IC0gcmVjdC53aWR0aCAvIDI7XG4gICAgICBjb25zdCBjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPSB5ID4gcmVjdC5ib3R0b20gLSByZWN0LmhlaWdodCAvIDI7XG4gICAgICBjb25zdCBpc092ZXJSZWZlcmVuY2VSZWN0ID0gaXNJbnNpZGUoY2xpZW50UG9pbnQsIHJlZlJlY3QpO1xuICAgICAgY29uc3QgaXNGbG9hdGluZ1dpZGVyID0gcmVjdC53aWR0aCA+IHJlZlJlY3Qud2lkdGg7XG4gICAgICBjb25zdCBpc0Zsb2F0aW5nVGFsbGVyID0gcmVjdC5oZWlnaHQgPiByZWZSZWN0LmhlaWdodDtcbiAgICAgIGNvbnN0IGxlZnQgPSAoaXNGbG9hdGluZ1dpZGVyID8gcmVmUmVjdCA6IHJlY3QpLmxlZnQ7XG4gICAgICBjb25zdCByaWdodCA9IChpc0Zsb2F0aW5nV2lkZXIgPyByZWZSZWN0IDogcmVjdCkucmlnaHQ7XG4gICAgICBjb25zdCB0b3AgPSAoaXNGbG9hdGluZ1RhbGxlciA/IHJlZlJlY3QgOiByZWN0KS50b3A7XG4gICAgICBjb25zdCBib3R0b20gPSAoaXNGbG9hdGluZ1RhbGxlciA/IHJlZlJlY3QgOiByZWN0KS5ib3R0b207XG4gICAgICBpZiAoaXNPdmVyRmxvYXRpbmdFbCkge1xuICAgICAgICBoYXNMYW5kZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIWlzTGVhdmUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc092ZXJSZWZlcmVuY2VFbCkge1xuICAgICAgICBoYXNMYW5kZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc092ZXJSZWZlcmVuY2VFbCAmJiAhaXNMZWF2ZSkge1xuICAgICAgICBoYXNMYW5kZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXZlbnQgb3ZlcmxhcHBpbmcgZmxvYXRpbmcgZWxlbWVudCBmcm9tIGJlaW5nIHN0dWNrIGluIGFuIG9wZW4tY2xvc2VcbiAgICAgIC8vIGxvb3A6IGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMTkxMFxuICAgICAgaWYgKGlzTGVhdmUgJiYgaXNFbGVtZW50KGV2ZW50LnJlbGF0ZWRUYXJnZXQpICYmIGNvbnRhaW5zKGVsZW1lbnRzLmZsb2F0aW5nLCBldmVudC5yZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGFueSBuZXN0ZWQgY2hpbGQgaXMgb3BlbiwgYWJvcnQuXG4gICAgICBpZiAodHJlZSAmJiBnZXRDaGlsZHJlbih0cmVlLm5vZGVzUmVmLmN1cnJlbnQsIG5vZGVJZCkuc29tZShfcmVmMiA9PiB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgY29udGV4dFxuICAgICAgICB9ID0gX3JlZjI7XG4gICAgICAgIHJldHVybiBjb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBjb250ZXh0Lm9wZW47XG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBwb2ludGVyIGlzIGxlYXZpbmcgZnJvbSB0aGUgb3Bwb3NpdGUgc2lkZSwgdGhlIFwiYnVmZmVyXCIgbG9naWNcbiAgICAgIC8vIGNyZWF0ZXMgYSBwb2ludCB3aGVyZSB0aGUgZmxvYXRpbmcgZWxlbWVudCByZW1haW5zIG9wZW4sIGJ1dCBzaG91bGQgYmVcbiAgICAgIC8vIGlnbm9yZWQuXG4gICAgICAvLyBBIGNvbnN0YW50IG9mIDEgaGFuZGxlcyBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMuXG4gICAgICBpZiAoc2lkZSA9PT0gJ3RvcCcgJiYgeSA+PSByZWZSZWN0LmJvdHRvbSAtIDEgfHwgc2lkZSA9PT0gJ2JvdHRvbScgJiYgeSA8PSByZWZSZWN0LnRvcCArIDEgfHwgc2lkZSA9PT0gJ2xlZnQnICYmIHggPj0gcmVmUmVjdC5yaWdodCAtIDEgfHwgc2lkZSA9PT0gJ3JpZ2h0JyAmJiB4IDw9IHJlZlJlY3QubGVmdCArIDEpIHtcbiAgICAgICAgcmV0dXJuIGNsb3NlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIElnbm9yZSB3aGVuIHRoZSBjdXJzb3IgaXMgd2l0aGluIHRoZSByZWN0YW5ndWxhciB0cm91Z2ggYmV0d2VlbiB0aGVcbiAgICAgIC8vIHR3byBlbGVtZW50cy4gU2luY2UgdGhlIHRyaWFuZ2xlIGlzIGNyZWF0ZWQgZnJvbSB0aGUgY3Vyc29yIHBvaW50LFxuICAgICAgLy8gd2hpY2ggY2FuIHN0YXJ0IGJleW9uZCB0aGUgcmVmIGVsZW1lbnQncyBlZGdlLCB0cmF2ZXJzaW5nIGJhY2sgYW5kXG4gICAgICAvLyBmb3J0aCBmcm9tIHRoZSByZWYgdG8gdGhlIGZsb2F0aW5nIGVsZW1lbnQgY2FuIGNhdXNlIGl0IHRvIGNsb3NlLiBUaGlzXG4gICAgICAvLyBlbnN1cmVzIGl0IGFsd2F5cyByZW1haW5zIG9wZW4gaW4gdGhhdCBjYXNlLlxuICAgICAgbGV0IHJlY3RQb2x5ID0gW107XG4gICAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICByZWN0UG9seSA9IFtbbGVmdCwgcmVmUmVjdC50b3AgKyAxXSwgW2xlZnQsIHJlY3QuYm90dG9tIC0gMV0sIFtyaWdodCwgcmVjdC5ib3R0b20gLSAxXSwgW3JpZ2h0LCByZWZSZWN0LnRvcCArIDFdXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICByZWN0UG9seSA9IFtbbGVmdCwgcmVjdC50b3AgKyAxXSwgW2xlZnQsIHJlZlJlY3QuYm90dG9tIC0gMV0sIFtyaWdodCwgcmVmUmVjdC5ib3R0b20gLSAxXSwgW3JpZ2h0LCByZWN0LnRvcCArIDFdXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgcmVjdFBvbHkgPSBbW3JlY3QucmlnaHQgLSAxLCBib3R0b21dLCBbcmVjdC5yaWdodCAtIDEsIHRvcF0sIFtyZWZSZWN0LmxlZnQgKyAxLCB0b3BdLCBbcmVmUmVjdC5sZWZ0ICsgMSwgYm90dG9tXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICByZWN0UG9seSA9IFtbcmVmUmVjdC5yaWdodCAtIDEsIGJvdHRvbV0sIFtyZWZSZWN0LnJpZ2h0IC0gMSwgdG9wXSwgW3JlY3QubGVmdCArIDEsIHRvcF0sIFtyZWN0LmxlZnQgKyAxLCBib3R0b21dXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGdldFBvbHlnb24oX3JlZjMpIHtcbiAgICAgICAgbGV0IFt4LCB5XSA9IF9yZWYzO1xuICAgICAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludE9uZSA9IFtpc0Zsb2F0aW5nV2lkZXIgPyB4ICsgYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8geCArIGJ1ZmZlciAqIDQgOiB4IC0gYnVmZmVyICogNCwgeSArIGJ1ZmZlciArIDFdO1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludFR3byA9IFtpc0Zsb2F0aW5nV2lkZXIgPyB4IC0gYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8geCArIGJ1ZmZlciAqIDQgOiB4IC0gYnVmZmVyICogNCwgeSArIGJ1ZmZlciArIDFdO1xuICAgICAgICAgICAgICBjb25zdCBjb21tb25Qb2ludHMgPSBbW3JlY3QubGVmdCwgY3Vyc29yTGVhdmVGcm9tUmlnaHQgPyByZWN0LmJvdHRvbSAtIGJ1ZmZlciA6IGlzRmxvYXRpbmdXaWRlciA/IHJlY3QuYm90dG9tIC0gYnVmZmVyIDogcmVjdC50b3BdLCBbcmVjdC5yaWdodCwgY3Vyc29yTGVhdmVGcm9tUmlnaHQgPyBpc0Zsb2F0aW5nV2lkZXIgPyByZWN0LmJvdHRvbSAtIGJ1ZmZlciA6IHJlY3QudG9wIDogcmVjdC5ib3R0b20gLSBidWZmZXJdXTtcbiAgICAgICAgICAgICAgcmV0dXJuIFtjdXJzb3JQb2ludE9uZSwgY3Vyc29yUG9pbnRUd28sIC4uLmNvbW1vblBvaW50c107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9pbnRPbmUgPSBbaXNGbG9hdGluZ1dpZGVyID8geCArIGJ1ZmZlciAvIDIgOiBjdXJzb3JMZWF2ZUZyb21SaWdodCA/IHggKyBidWZmZXIgKiA0IDogeCAtIGJ1ZmZlciAqIDQsIHkgLSBidWZmZXJdO1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludFR3byA9IFtpc0Zsb2F0aW5nV2lkZXIgPyB4IC0gYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8geCArIGJ1ZmZlciAqIDQgOiB4IC0gYnVmZmVyICogNCwgeSAtIGJ1ZmZlcl07XG4gICAgICAgICAgICAgIGNvbnN0IGNvbW1vblBvaW50cyA9IFtbcmVjdC5sZWZ0LCBjdXJzb3JMZWF2ZUZyb21SaWdodCA/IHJlY3QudG9wICsgYnVmZmVyIDogaXNGbG9hdGluZ1dpZGVyID8gcmVjdC50b3AgKyBidWZmZXIgOiByZWN0LmJvdHRvbV0sIFtyZWN0LnJpZ2h0LCBjdXJzb3JMZWF2ZUZyb21SaWdodCA/IGlzRmxvYXRpbmdXaWRlciA/IHJlY3QudG9wICsgYnVmZmVyIDogcmVjdC5ib3R0b20gOiByZWN0LnRvcCArIGJ1ZmZlcl1dO1xuICAgICAgICAgICAgICByZXR1cm4gW2N1cnNvclBvaW50T25lLCBjdXJzb3JQb2ludFR3bywgLi4uY29tbW9uUG9pbnRzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9pbnRPbmUgPSBbeCArIGJ1ZmZlciArIDEsIGlzRmxvYXRpbmdUYWxsZXIgPyB5ICsgYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbUJvdHRvbSA/IHkgKyBidWZmZXIgKiA0IDogeSAtIGJ1ZmZlciAqIDRdO1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludFR3byA9IFt4ICsgYnVmZmVyICsgMSwgaXNGbG9hdGluZ1RhbGxlciA/IHkgLSBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tQm90dG9tID8geSArIGJ1ZmZlciAqIDQgOiB5IC0gYnVmZmVyICogNF07XG4gICAgICAgICAgICAgIGNvbnN0IGNvbW1vblBvaW50cyA9IFtbY3Vyc29yTGVhdmVGcm9tQm90dG9tID8gcmVjdC5yaWdodCAtIGJ1ZmZlciA6IGlzRmxvYXRpbmdUYWxsZXIgPyByZWN0LnJpZ2h0IC0gYnVmZmVyIDogcmVjdC5sZWZ0LCByZWN0LnRvcF0sIFtjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPyBpc0Zsb2F0aW5nVGFsbGVyID8gcmVjdC5yaWdodCAtIGJ1ZmZlciA6IHJlY3QubGVmdCA6IHJlY3QucmlnaHQgLSBidWZmZXIsIHJlY3QuYm90dG9tXV07XG4gICAgICAgICAgICAgIHJldHVybiBbLi4uY29tbW9uUG9pbnRzLCBjdXJzb3JQb2ludE9uZSwgY3Vyc29yUG9pbnRUd29dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9pbnRPbmUgPSBbeCAtIGJ1ZmZlciwgaXNGbG9hdGluZ1RhbGxlciA/IHkgKyBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tQm90dG9tID8geSArIGJ1ZmZlciAqIDQgOiB5IC0gYnVmZmVyICogNF07XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvaW50VHdvID0gW3ggLSBidWZmZXIsIGlzRmxvYXRpbmdUYWxsZXIgPyB5IC0gYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbUJvdHRvbSA/IHkgKyBidWZmZXIgKiA0IDogeSAtIGJ1ZmZlciAqIDRdO1xuICAgICAgICAgICAgICBjb25zdCBjb21tb25Qb2ludHMgPSBbW2N1cnNvckxlYXZlRnJvbUJvdHRvbSA/IHJlY3QubGVmdCArIGJ1ZmZlciA6IGlzRmxvYXRpbmdUYWxsZXIgPyByZWN0LmxlZnQgKyBidWZmZXIgOiByZWN0LnJpZ2h0LCByZWN0LnRvcF0sIFtjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPyBpc0Zsb2F0aW5nVGFsbGVyID8gcmVjdC5sZWZ0ICsgYnVmZmVyIDogcmVjdC5yaWdodCA6IHJlY3QubGVmdCArIGJ1ZmZlciwgcmVjdC5ib3R0b21dXTtcbiAgICAgICAgICAgICAgcmV0dXJuIFtjdXJzb3JQb2ludE9uZSwgY3Vyc29yUG9pbnRUd28sIC4uLmNvbW1vblBvaW50c107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc1BvaW50SW5Qb2x5Z29uKFtjbGllbnRYLCBjbGllbnRZXSwgcmVjdFBvbHkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoaGFzTGFuZGVkICYmICFpc092ZXJSZWZlcmVuY2VSZWN0KSB7XG4gICAgICAgIHJldHVybiBjbG9zZSgpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0xlYXZlICYmIHJlcXVpcmVJbnRlbnQpIHtcbiAgICAgICAgY29uc3QgY3Vyc29yU3BlZWQgPSBnZXRDdXJzb3JTcGVlZChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICAgICAgY29uc3QgY3Vyc29yU3BlZWRUaHJlc2hvbGQgPSAwLjE7XG4gICAgICAgIGlmIChjdXJzb3JTcGVlZCAhPT0gbnVsbCAmJiBjdXJzb3JTcGVlZCA8IGN1cnNvclNwZWVkVGhyZXNob2xkKSB7XG4gICAgICAgICAgcmV0dXJuIGNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaXNQb2ludEluUG9seWdvbihbY2xpZW50WCwgY2xpZW50WV0sIGdldFBvbHlnb24oW3gsIHldKSkpIHtcbiAgICAgICAgY2xvc2UoKTtcbiAgICAgIH0gZWxzZSBpZiAoIWhhc0xhbmRlZCAmJiByZXF1aXJlSW50ZW50KSB7XG4gICAgICAgIHRpbWVvdXRJZCA9IHdpbmRvdy5zZXRUaW1lb3V0KGNsb3NlLCA0MCk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgZm4uX19vcHRpb25zID0ge1xuICAgIGJsb2NrUG9pbnRlckV2ZW50c1xuICB9O1xuICByZXR1cm4gZm47XG59XG5cbmV4cG9ydCB7IENvbXBvc2l0ZSwgQ29tcG9zaXRlSXRlbSwgRmxvYXRpbmdBcnJvdywgRmxvYXRpbmdEZWxheUdyb3VwLCBGbG9hdGluZ0ZvY3VzTWFuYWdlciwgRmxvYXRpbmdMaXN0LCBGbG9hdGluZ05vZGUsIEZsb2F0aW5nT3ZlcmxheSwgRmxvYXRpbmdQb3J0YWwsIEZsb2F0aW5nVHJlZSwgaW5uZXIsIHNhZmVQb2x5Z29uLCB1c2VDbGljaywgdXNlQ2xpZW50UG9pbnQsIHVzZURlbGF5R3JvdXAsIHVzZURlbGF5R3JvdXBDb250ZXh0LCB1c2VEaXNtaXNzLCB1c2VGbG9hdGluZywgdXNlRmxvYXRpbmdOb2RlSWQsIHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkLCB1c2VGbG9hdGluZ1BvcnRhbE5vZGUsIHVzZUZsb2F0aW5nVHJlZSwgdXNlRm9jdXMsIHVzZUhvdmVyLCB1c2VJZCwgdXNlSW5uZXJPZmZzZXQsIHVzZUludGVyYWN0aW9ucywgdXNlTGlzdEl0ZW0sIHVzZUxpc3ROYXZpZ2F0aW9uLCB1c2VNZXJnZVJlZnMsIHVzZVJvbGUsIHVzZVRyYW5zaXRpb25TdGF0dXMsIHVzZVRyYW5zaXRpb25TdHlsZXMsIHVzZVR5cGVhaGVhZCB9O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwic3RvcEV2ZW50IiwiZ2V0RG9jdW1lbnQiLCJpc01vdXNlTGlrZVBvaW50ZXJUeXBlIiwiY29udGFpbnMiLCJhY3RpdmVFbGVtZW50IiwiaXNTYWZhcmkiLCJpc1R5cGVhYmxlQ29tYm9ib3giLCJpc1ZpcnR1YWxDbGljayIsImlzVmlydHVhbFBvaW50ZXJFdmVudCIsImdldFRhcmdldCIsImdldFBsYXRmb3JtIiwiaXNUeXBlYWJsZUVsZW1lbnQiLCJpc1JlYWN0RXZlbnQiLCJpc1Jvb3RFbGVtZW50IiwiaXNFdmVudFRhcmdldFdpdGhpbiIsImlzTWFjIiwiZ2V0VXNlckFnZW50IiwiZmxvb3IiLCJwbGF0Zm9ybSIsImdldE92ZXJmbG93QW5jZXN0b3JzIiwidXNlRmxvYXRpbmciLCJ1c2VGbG9hdGluZyQxIiwib2Zmc2V0IiwiZGV0ZWN0T3ZlcmZsb3ciLCJhcnJvdyIsImF1dG9QbGFjZW1lbnQiLCJhdXRvVXBkYXRlIiwiY29tcHV0ZVBvc2l0aW9uIiwiZmxpcCIsImhpZGUiLCJpbmxpbmUiLCJsaW1pdFNoaWZ0Iiwic2hpZnQiLCJzaXplIiwiaXNFbGVtZW50IiwiaXNIVE1MRWxlbWVudCIsImdldE5vZGVOYW1lIiwiZ2V0V2luZG93IiwiaXNMYXN0VHJhdmVyc2FibGVOb2RlIiwiZ2V0UGFyZW50Tm9kZSIsImdldENvbXB1dGVkU3R5bGUiLCJ0YWJiYWJsZSIsImNyZWF0ZVBvcnRhbCIsImZsdXNoU3luYyIsInVzZU1lcmdlUmVmcyIsInJlZnMiLCJ1c2VNZW1vIiwiZXZlcnkiLCJyZWYiLCJ2YWx1ZSIsImZvckVhY2giLCJjdXJyZW50IiwidXNlSW5zZXJ0aW9uRWZmZWN0IiwidG9TdHJpbmciLCJ1c2VTYWZlSW5zZXJ0aW9uRWZmZWN0IiwiZm4iLCJ1c2VFZmZlY3RFdmVudCIsImNhbGxiYWNrIiwicHJvY2VzcyIsIkVycm9yIiwidXNlQ2FsbGJhY2siLCJfbGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXJncyIsIkFycmF5IiwiX2tleSIsIkFSUk9XX1VQIiwiQVJST1dfRE9XTiIsIkFSUk9XX0xFRlQiLCJBUlJPV19SSUdIVCIsImlzRGlmZmVyZW50Um93IiwiaW5kZXgiLCJjb2xzIiwicHJldlJvdyIsIk1hdGgiLCJpc0luZGV4T3V0T2ZCb3VuZHMiLCJsaXN0UmVmIiwiZ2V0TWluSW5kZXgiLCJkaXNhYmxlZEluZGljZXMiLCJmaW5kTm9uRGlzYWJsZWRJbmRleCIsImdldE1heEluZGV4IiwiZGVjcmVtZW50Iiwic3RhcnRpbmdJbmRleCIsIl90ZW1wIiwiYW1vdW50IiwibGlzdCIsImlzRGlzYWJsZWRJbmRleCIsImluY2x1ZGVzIiwiZWxlbWVudCIsImhhc0F0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZSIsImdldEdyaWROYXZpZ2F0ZWRJbmRleCIsImVsZW1lbnRzUmVmIiwiX3JlZiIsImV2ZW50Iiwib3JpZW50YXRpb24iLCJsb29wIiwibWluSW5kZXgiLCJtYXhJbmRleCIsInByZXZJbmRleCIsInN0b3AiLCJuZXh0SW5kZXgiLCJrZXkiLCJjb2wiLCJtYXhDb2wiLCJsYXN0Um93IiwicmFmSWQiLCJlbnF1ZXVlRm9jdXMiLCJlbCIsIm9wdGlvbnMiLCJwcmV2ZW50U2Nyb2xsIiwiY2FuY2VsUHJldmlvdXMiLCJzeW5jIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJleGVjIiwiZm9jdXMiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJkb2N1bWVudCIsInNvcnRCeURvY3VtZW50UG9zaXRpb24iLCJhIiwiYiIsInBvc2l0aW9uIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJOb2RlIiwiRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HIiwiRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZIiwiRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HIiwiRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTlMiLCJhcmVNYXBzRXF1YWwiLCJtYXAxIiwibWFwMiIsImVudHJpZXMiLCJnZXQiLCJGbG9hdGluZ0xpc3RDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsInJlZ2lzdGVyIiwidW5yZWdpc3RlciIsIm1hcCIsIk1hcCIsIkZsb2F0aW5nTGlzdCIsImNoaWxkcmVuIiwibGFiZWxzUmVmIiwic2V0TWFwIiwidXNlU3RhdGUiLCJub2RlIiwicHJldk1hcCIsInNldCIsImRlbGV0ZSIsIm5ld01hcCIsIm5vZGVzIiwiZnJvbSIsImtleXMiLCJzb3J0IiwiY3JlYXRlRWxlbWVudCIsIlByb3ZpZGVyIiwidXNlTGlzdEl0ZW0iLCJsYWJlbCIsImluZGV4JDEiLCJzZXRJbmRleCIsImNvbXBvbmVudFJlZiIsInVzZUNvbnRleHQiLCJfbm9kZSR0ZXh0Q29udGVudCIsImlzTGFiZWxEZWZpbmVkIiwidW5kZWZpbmVkIiwidGV4dENvbnRlbnQiLCJyZW5kZXJKc3giLCJyZW5kZXIiLCJjb21wdXRlZFByb3BzIiwiY2xvbmVFbGVtZW50IiwiQ29tcG9zaXRlQ29udGV4dCIsImFjdGl2ZUluZGV4Iiwib25OYXZpZ2F0ZSIsImhvcml6b250YWxLZXlzIiwidmVydGljYWxLZXlzIiwiYWxsS2V5cyIsIkNvbXBvc2l0ZSIsImZvcndhcmRSZWYiLCJmb3J3YXJkZWRSZWYiLCJleHRlcm5hbEFjdGl2ZUluZGV4IiwiZXh0ZXJuYWxTZXRBY3RpdmVJbmRleCIsInByb3BzIiwiaW50ZXJuYWxBY3RpdmVJbmRleCIsImludGVybmFsU2V0QWN0aXZlSW5kZXgiLCJyZW5kZXJFbGVtZW50UHJvcHMiLCJjb250ZXh0VmFsdWUiLCJpc0dyaWQiLCJoYW5kbGVLZXlEb3duIiwidG9FbmRLZXlzIiwiaG9yaXpvbnRhbCIsInZlcnRpY2FsIiwiYm90aCIsInRvU3RhcnRLZXlzIiwicHJldmVudGVkS2V5cyIsInN0b3BQcm9wYWdhdGlvbiIsInByZXZlbnREZWZhdWx0IiwicXVldWVNaWNyb3Rhc2siLCJvbktleURvd24iLCJlIiwiQ29tcG9zaXRlSXRlbSIsIl9yZWYyIiwibWVyZ2VkUmVmIiwiaXNBY3RpdmUiLCJ0YWJJbmRleCIsIm9uRm9jdXMiLCJfZXh0ZW5kcyIsIk9iamVjdCIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJpIiwic291cmNlIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJzZXJ2ZXJIYW5kb2ZmQ29tcGxldGUiLCJjb3VudCIsImdlbklkIiwidXNlRmxvYXRpbmdJZCIsImlkIiwic2V0SWQiLCJ1c2VSZWFjdElkIiwidXNlSWQiLCJGbG9hdGluZ0Fycm93IiwiY29udGV4dCIsInBsYWNlbWVudCIsImVsZW1lbnRzIiwiZmxvYXRpbmciLCJtaWRkbGV3YXJlRGF0YSIsIndpZHRoIiwiaGVpZ2h0IiwidGlwUmFkaXVzIiwic3Ryb2tlV2lkdGgiLCJzdGF0aWNPZmZzZXQiLCJzdHJva2UiLCJkIiwic3R5bGUiLCJ0cmFuc2Zvcm0iLCJyZXN0U3R5bGUiLCJyZXN0IiwiY29uc29sZSIsIndhcm4iLCJjbGlwUGF0aElkIiwiaGFsZlN0cm9rZVdpZHRoIiwic3ZnWCIsInN2Z1kiLCJzaWRlIiwiYWxpZ25tZW50Iiwic3BsaXQiLCJpc1JUTCIsImlzQ3VzdG9tU2hhcGUiLCJpc1ZlcnRpY2FsU2lkZSIsInlPZmZzZXRQcm9wIiwieE9mZnNldFByb3AiLCJhcnJvd1giLCJ4IiwiYXJyb3dZIiwieSIsImRWYWx1ZSIsInJvdGF0aW9uIiwidG9wIiwibGVmdCIsImJvdHRvbSIsInJpZ2h0Iiwidmlld0JveCIsInBvaW50ZXJFdmVudHMiLCJjbGlwUGF0aCIsImZpbGwiLCJjcmVhdGVQdWJTdWIiLCJlbWl0IiwiZGF0YSIsIl9tYXAkZ2V0IiwiaGFuZGxlciIsIm9uIiwibGlzdGVuZXIiLCJvZmYiLCJfbWFwJGdldDIiLCJmaWx0ZXIiLCJsIiwiRmxvYXRpbmdOb2RlQ29udGV4dCIsIkZsb2F0aW5nVHJlZUNvbnRleHQiLCJ1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCIsIl9SZWFjdCR1c2VDb250ZXh0IiwidXNlRmxvYXRpbmdUcmVlIiwidXNlRmxvYXRpbmdOb2RlSWQiLCJjdXN0b21QYXJlbnRJZCIsInRyZWUiLCJyZWFjdFBhcmVudElkIiwicGFyZW50SWQiLCJhZGROb2RlIiwicmVtb3ZlTm9kZSIsIkZsb2F0aW5nTm9kZSIsIkZsb2F0aW5nVHJlZSIsIm5vZGVzUmVmIiwibiIsImV2ZW50cyIsImNyZWF0ZUF0dHJpYnV0ZSIsIm5hbWUiLCJ1c2VMYXRlc3RSZWYiLCJzYWZlUG9seWdvbklkZW50aWZpZXIiLCJnZXREZWxheSIsInByb3AiLCJwb2ludGVyVHlwZSIsInVzZUhvdmVyIiwib3BlbiIsIm9uT3BlbkNoYW5nZSIsImRhdGFSZWYiLCJkb21SZWZlcmVuY2UiLCJlbmFibGVkIiwiZGVsYXkiLCJoYW5kbGVDbG9zZSIsIm1vdXNlT25seSIsInJlc3RNcyIsIm1vdmUiLCJoYW5kbGVDbG9zZVJlZiIsImRlbGF5UmVmIiwicG9pbnRlclR5cGVSZWYiLCJ0aW1lb3V0UmVmIiwiaGFuZGxlclJlZiIsInJlc3RUaW1lb3V0UmVmIiwiYmxvY2tNb3VzZU1vdmVSZWYiLCJwZXJmb3JtZWRQb2ludGVyRXZlbnRzTXV0YXRpb25SZWYiLCJ1bmJpbmRNb3VzZU1vdmVSZWYiLCJpc0hvdmVyT3BlbiIsIl9kYXRhUmVmJGN1cnJlbnQkb3BlbiIsInR5cGUiLCJvcGVuRXZlbnQiLCJjbGVhclRpbWVvdXQiLCJvbkxlYXZlIiwiaHRtbCIsImRvY3VtZW50RWxlbWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2xvc2VXaXRoRGVsYXkiLCJydW5FbHNlQnJhbmNoIiwicmVhc29uIiwiY2xvc2VEZWxheSIsInNldFRpbWVvdXQiLCJjbGVhbnVwTW91c2VNb3ZlSGFuZGxlciIsImNsZWFyUG9pbnRlckV2ZW50cyIsImJvZHkiLCJyZW1vdmVBdHRyaWJ1dGUiLCJpc0NsaWNrTGlrZU9wZW5FdmVudCIsIm9uTW91c2VFbnRlciIsIm9wZW5EZWxheSIsIm9uTW91c2VMZWF2ZSIsImRvYyIsImNsaWVudFgiLCJjbGllbnRZIiwib25DbG9zZSIsInNob3VsZENsb3NlIiwicmVsYXRlZFRhcmdldCIsIm9uU2Nyb2xsTW91c2VMZWF2ZSIsIm9uY2UiLCJfaGFuZGxlQ2xvc2VSZWYkY3VycmUiLCJfX29wdGlvbnMiLCJibG9ja1BvaW50ZXJFdmVudHMiLCJzZXRBdHRyaWJ1dGUiLCJfdHJlZSRub2Rlc1JlZiRjdXJyZW4iLCJwYXJlbnRGbG9hdGluZyIsImZpbmQiLCJzZXRQb2ludGVyUmVmIiwicmVmZXJlbmNlIiwib25Qb2ludGVyRG93biIsIm9uUG9pbnRlckVudGVyIiwib25Nb3VzZU1vdmUiLCJuYXRpdmVFdmVudCIsIkZsb2F0aW5nRGVsYXlHcm91cENvbnRleHQiLCJpbml0aWFsRGVsYXkiLCJ0aW1lb3V0TXMiLCJjdXJyZW50SWQiLCJzZXRDdXJyZW50SWQiLCJzZXRTdGF0ZSIsImlzSW5zdGFudFBoYXNlIiwidXNlRGVsYXlHcm91cENvbnRleHQiLCJGbG9hdGluZ0RlbGF5R3JvdXAiLCJzdGF0ZSIsInVzZVJlZHVjZXIiLCJwcmV2IiwibmV4dCIsImluaXRpYWxDdXJyZW50SWRSZWYiLCJ1c2VEZWxheUdyb3VwIiwiX3JlZjMiLCJjbG9zZSIsInVuc2V0IiwidGltZW91dCIsIndpbmRvdyIsImdldEFuY2VzdG9ycyIsIl9ub2RlcyRmaW5kIiwiYWxsQW5jZXN0b3JzIiwiY3VycmVudFBhcmVudElkIiwiY3VycmVudE5vZGUiLCJjb25jYXQiLCJnZXRDaGlsZHJlbiIsImFsbENoaWxkcmVuIiwiX25vZGUkY29udGV4dCIsImN1cnJlbnRDaGlsZHJlbiIsIl9jdXJyZW50Q2hpbGRyZW4iLCJzb21lIiwiX25vZGUkY29udGV4dDIiLCJnZXREZWVwZXN0Tm9kZSIsImRlZXBlc3ROb2RlSWQiLCJtYXhEZXB0aCIsImZpbmREZWVwZXN0Iiwibm9kZUlkIiwiZGVwdGgiLCJjaGlsZCIsImNvdW50ZXJNYXAiLCJXZWFrTWFwIiwidW5jb250cm9sbGVkRWxlbWVudHNTZXQiLCJXZWFrU2V0IiwibWFya2VyTWFwIiwibG9ja0NvdW50Iiwic3VwcG9ydHNJbmVydCIsIkhUTUxFbGVtZW50IiwidW53cmFwSG9zdCIsImhvc3QiLCJwYXJlbnROb2RlIiwiY29ycmVjdEVsZW1lbnRzIiwicGFyZW50IiwidGFyZ2V0cyIsImNvcnJlY3RlZFRhcmdldCIsImFwcGx5QXR0cmlidXRlVG9PdGhlcnMiLCJ1bmNvcnJlY3RlZEF2b2lkRWxlbWVudHMiLCJhcmlhSGlkZGVuIiwiaW5lcnQiLCJtYXJrZXJOYW1lIiwiY29udHJvbEF0dHJpYnV0ZSIsImF2b2lkRWxlbWVudHMiLCJlbGVtZW50c1RvS2VlcCIsIlNldCIsImVsZW1lbnRzVG9TdG9wIiwiaGlkZGVuRWxlbWVudHMiLCJtYXJrZXJDb3VudGVyIiwia2VlcCIsImRlZXAiLCJjbGVhciIsImhhcyIsImFkZCIsImF0dHIiLCJhbHJlYWR5SGlkZGVuIiwiY291bnRlclZhbHVlIiwibWFya2VyVmFsdWUiLCJwdXNoIiwibWFya090aGVycyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJnZXRUYWJiYWJsZU9wdGlvbnMiLCJnZXRTaGFkb3dSb290IiwiZGlzcGxheUNoZWNrIiwiUmVzaXplT2JzZXJ2ZXIiLCJnZXRUYWJiYWJsZUluIiwiY29udGFpbmVyIiwiZGlyZWN0aW9uIiwiYWxsVGFiYmFibGUiLCJyZXZlcnNlIiwiaW5kZXhPZiIsIm5leHRUYWJiYWJsZUVsZW1lbnRzIiwic2xpY2UiLCJnZXROZXh0VGFiYmFibGUiLCJnZXRQcmV2aW91c1RhYmJhYmxlIiwiaXNPdXRzaWRlRXZlbnQiLCJjb250YWluZXJFbGVtZW50IiwiY3VycmVudFRhcmdldCIsImRpc2FibGVGb2N1c0luc2lkZSIsInRhYmJhYmxlRWxlbWVudHMiLCJkYXRhc2V0IiwidGFiaW5kZXgiLCJlbmFibGVGb2N1c0luc2lkZSIsIkhJRERFTl9TVFlMRVMiLCJib3JkZXIiLCJjbGlwIiwibWFyZ2luIiwib3ZlcmZsb3ciLCJwYWRkaW5nIiwid2hpdGVTcGFjZSIsInRpbWVvdXRJZCIsInNldEFjdGl2ZUVsZW1lbnRPblRhYiIsIkZvY3VzR3VhcmQiLCJyb2xlIiwic2V0Um9sZSIsInJlc3RQcm9wcyIsIlBvcnRhbENvbnRleHQiLCJ1c2VGbG9hdGluZ1BvcnRhbE5vZGUiLCJyb290IiwicG9ydGFsTm9kZSIsInNldFBvcnRhbE5vZGUiLCJ1bmlxdWVJZCIsInBvcnRhbENvbnRleHQiLCJ1c2VQb3J0YWxDb250ZXh0IiwicmVtb3ZlIiwiZXhpc3RpbmdJZFJvb3QiLCJnZXRFbGVtZW50QnlJZCIsInN1YlJvb3QiLCJhcHBlbmRDaGlsZCIsImlkV3JhcHBlciIsIkZsb2F0aW5nUG9ydGFsIiwicHJlc2VydmVUYWJPcmRlciIsImZvY3VzTWFuYWdlclN0YXRlIiwic2V0Rm9jdXNNYW5hZ2VyU3RhdGUiLCJiZWZvcmVPdXRzaWRlUmVmIiwiYWZ0ZXJPdXRzaWRlUmVmIiwiYmVmb3JlSW5zaWRlUmVmIiwiYWZ0ZXJJbnNpZGVSZWYiLCJzaG91bGRSZW5kZXJHdWFyZHMiLCJtb2RhbCIsImZvY3VzaW5nIiwibWFuYWdlRm9jdXMiLCJfYmVmb3JlSW5zaWRlUmVmJGN1cnIiLCJwcmV2VGFiYmFibGUiLCJfYWZ0ZXJJbnNpZGVSZWYkY3VycmUiLCJuZXh0VGFiYmFibGUiLCJjbG9zZU9uRm9jdXNPdXQiLCJMSVNUX0xJTUlUIiwicHJldmlvdXNseUZvY3VzZWRFbGVtZW50cyIsImFkZFByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCIsImlzQ29ubmVjdGVkIiwiZ2V0UHJldmlvdXNseUZvY3VzZWRFbGVtZW50IiwiVmlzdWFsbHlIaWRkZW5EaXNtaXNzIiwiRmxvYXRpbmdGb2N1c01hbmFnZXIiLCJkaXNhYmxlZCIsIm9yZGVyIiwiZ3VhcmRzIiwiX2d1YXJkcyIsImluaXRpYWxGb2N1cyIsInJldHVybkZvY3VzIiwidmlzdWFsbHlIaWRkZW5EaXNtaXNzIiwiaWdub3JlSW5pdGlhbEZvY3VzIiwiaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94Iiwib3JkZXJSZWYiLCJpbml0aWFsRm9jdXNSZWYiLCJyZXR1cm5Gb2N1c1JlZiIsInN0YXJ0RGlzbWlzc0J1dHRvblJlZiIsImVuZERpc21pc3NCdXR0b25SZWYiLCJwcmV2ZW50UmV0dXJuRm9jdXNSZWYiLCJpc1BvaW50ZXJEb3duUmVmIiwiaXNJbnNpZGVQb3J0YWwiLCJnZXRUYWJiYWJsZUNvbnRlbnQiLCJnZXRUYWJiYWJsZUVsZW1lbnRzIiwiY29udGVudCIsIkJvb2xlYW4iLCJmbGF0IiwiZWxzIiwic2hpZnRLZXkiLCJoYW5kbGVQb2ludGVyRG93biIsImhhbmRsZUZvY3VzT3V0c2lkZSIsIm1vdmVkVG9VbnJlbGF0ZWROb2RlIiwiX25vZGUkY29udGV4dDMiLCJfbm9kZSRjb250ZXh0NCIsIl9wb3J0YWxDb250ZXh0JHBvcnRhbCIsInBvcnRhbE5vZGVzIiwiaW5zaWRlRWxlbWVudHMiLCJjbGVhbnVwIiwicHJldmlvdXNseUZvY3VzZWRFbGVtZW50IiwiZm9jdXNhYmxlRWxlbWVudHMiLCJpbml0aWFsRm9jdXNWYWx1ZSIsImVsVG9Gb2N1cyIsImZvY3VzQWxyZWFkeUluc2lkZUZsb2F0aW5nRWwiLCJwcmV2ZW50UmV0dXJuRm9jdXNTY3JvbGwiLCJjb250ZXh0RGF0YSIsIm5lc3RlZCIsImFjdGl2ZUVsIiwiaXNGb2N1c0luc2lkZUZsb2F0aW5nVHJlZSIsIl9ub2RlJGNvbnRleHQ1Iiwic2hvdWxkRm9jdXNSZWZlcmVuY2UiLCJyZXR1cm5FbGVtZW50IiwiTXV0YXRpb25PYnNlcnZlciIsImhhbmRsZU11dGF0aW9uIiwib2JzZXJ2ZXIiLCJvYnNlcnZlIiwiY2hpbGRMaXN0Iiwic3VidHJlZSIsImF0dHJpYnV0ZXMiLCJkaXNjb25uZWN0IiwicmVuZGVyRGlzbWlzc0J1dHRvbiIsImxvY2F0aW9uIiwib25DbGljayIsIkZyYWdtZW50IiwiX3BvcnRhbENvbnRleHQkYmVmb3JlIiwiX3BvcnRhbENvbnRleHQkYWZ0ZXJPIiwiYWN0aXZlTG9ja3MiLCJGbG9hdGluZ092ZXJsYXkiLCJsb2NrU2Nyb2xsIiwibG9ja0lkIiwiaXNJT1MiLCJ0ZXN0IiwiYm9keVN0eWxlIiwic2Nyb2xsYmFyWCIsInJvdW5kIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwic2Nyb2xsTGVmdCIsInBhZGRpbmdQcm9wIiwic2Nyb2xsYmFyV2lkdGgiLCJpbm5lcldpZHRoIiwiY2xpZW50V2lkdGgiLCJzY3JvbGxYIiwicGFyc2VGbG9hdCIsInBhZ2VYT2Zmc2V0Iiwic2Nyb2xsWSIsInBhZ2VZT2Zmc2V0IiwiX3dpbmRvdyR2aXN1YWxWaWV3cG9yIiwiX3dpbmRvdyR2aXN1YWxWaWV3cG9yMiIsIm9mZnNldExlZnQiLCJ2aXN1YWxWaWV3cG9ydCIsIm9mZnNldFRvcCIsInNjcm9sbFRvIiwiaXNCdXR0b25UYXJnZXQiLCJ0YWdOYW1lIiwiaXNTcGFjZUlnbm9yZWQiLCJ1c2VDbGljayIsImV2ZW50T3B0aW9uIiwidG9nZ2xlIiwiaWdub3JlTW91c2UiLCJrZXlib2FyZEhhbmRsZXJzIiwiZGlkS2V5RG93blJlZiIsIm9uTW91c2VEb3duIiwiYnV0dG9uIiwiZGVmYXVsdFByZXZlbnRlZCIsIm9uS2V5VXAiLCJjcmVhdGVWaXJ0dWFsRWxlbWVudCIsImRvbVJlZiIsIm9mZnNldFgiLCJvZmZzZXRZIiwiaXNBdXRvVXBkYXRlRXZlbnQiLCJjb250ZXh0RWxlbWVudCIsIl9kb21SZWYkY3VycmVudCIsIl9kYXRhJGRhdGFSZWYkY3VycmVudCIsImRvbVJlY3QiLCJpc1hBeGlzIiwiYXhpcyIsImlzWUF4aXMiLCJjYW5UcmFja0N1cnNvck9uQXV0b1VwZGF0ZSIsImlzTW91c2VCYXNlZEV2ZW50IiwidXNlQ2xpZW50UG9pbnQiLCJpbml0aWFsUmVmIiwiY2xlYW51cExpc3RlbmVyUmVmIiwic2V0UG9pbnRlclR5cGUiLCJyZWFjdGl2ZSIsInNldFJlYWN0aXZlIiwic2V0UmVmZXJlbmNlIiwic2V0UG9zaXRpb25SZWZlcmVuY2UiLCJoYW5kbGVSZWZlcmVuY2VFbnRlck9yTW92ZSIsIm9wZW5DaGVjayIsImFkZExpc3RlbmVyIiwid2luIiwiaGFuZGxlTW91c2VNb3ZlIiwic2V0UG9pbnRlclR5cGVSZWYiLCJidWJibGVIYW5kbGVyS2V5cyIsInBvaW50ZXJkb3duIiwibW91c2Vkb3duIiwiY2xpY2siLCJjYXB0dXJlSGFuZGxlcktleXMiLCJub3JtYWxpemVQcm9wIiwibm9ybWFsaXphYmxlIiwiX25vcm1hbGl6YWJsZSRlc2NhcGVLIiwiX25vcm1hbGl6YWJsZSRvdXRzaWRlIiwiZXNjYXBlS2V5Iiwib3V0c2lkZVByZXNzIiwidXNlRGlzbWlzcyIsInVuc3RhYmxlX291dHNpZGVQcmVzcyIsIm91dHNpZGVQcmVzc0V2ZW50IiwicmVmZXJlbmNlUHJlc3MiLCJyZWZlcmVuY2VQcmVzc0V2ZW50IiwiYW5jZXN0b3JTY3JvbGwiLCJidWJibGVzIiwiY2FwdHVyZSIsIm91dHNpZGVQcmVzc0ZuIiwiaW5zaWRlUmVhY3RUcmVlUmVmIiwiZW5kZWRPclN0YXJ0ZWRJbnNpZGVSZWYiLCJlc2NhcGVLZXlCdWJibGVzIiwib3V0c2lkZVByZXNzQnViYmxlcyIsImVzY2FwZUtleUNhcHR1cmUiLCJvdXRzaWRlUHJlc3NDYXB0dXJlIiwiY2xvc2VPbkVzY2FwZUtleURvd24iLCJzaG91bGREaXNtaXNzIiwiX2NoaWxkJGNvbnRleHQiLCJfX2VzY2FwZUtleUJ1YmJsZXMiLCJjbG9zZU9uRXNjYXBlS2V5RG93bkNhcHR1cmUiLCJfZ2V0VGFyZ2V0MiIsIl9nZXRUYXJnZXQiLCJjbG9zZU9uUHJlc3NPdXRzaWRlIiwiaW5zaWRlUmVhY3RUcmVlIiwiZW5kZWRPclN0YXJ0ZWRJbnNpZGUiLCJpbmVydFNlbGVjdG9yIiwibWFya2VycyIsInRhcmdldFJvb3RBbmNlc3RvciIsIm5leHRQYXJlbnQiLCJtYXJrZXIiLCJjYW5TY3JvbGxYIiwic2Nyb2xsV2lkdGgiLCJjYW5TY3JvbGxZIiwiY2xpZW50SGVpZ2h0Iiwic2Nyb2xsSGVpZ2h0IiwieENvbmQiLCJvZmZzZXRXaWR0aCIsInRhcmdldElzSW5zaWRlQ2hpbGRyZW4iLCJfY2hpbGQkY29udGV4dDIiLCJfX291dHNpZGVQcmVzc0J1YmJsZXMiLCJjbG9zZU9uUHJlc3NPdXRzaWRlQ2FwdHVyZSIsIl9nZXRUYXJnZXQ0IiwiX2dldFRhcmdldDMiLCJvblNjcm9sbCIsImFuY2VzdG9ycyIsImFuY2VzdG9yIiwiX2RvYyRkZWZhdWx0VmlldyIsImRlZmF1bHRWaWV3IiwicGFzc2l2ZSIsIm9uTW91c2VVcCIsImRldk1lc3NhZ2VTZXQiLCJfb3B0aW9ucyRlbGVtZW50czIiLCJ1bnN0YWJsZV9vbk9wZW5DaGFuZ2UiLCJfb3B0aW9ucyRlbGVtZW50cyIsImVyciIsIl9kZXZNZXNzYWdlU2V0IiwiX2Rldk1lc3NhZ2VTZXQyIiwiZXJyb3IiLCJfZG9tUmVmZXJlbmNlIiwic2V0RG9tUmVmZXJlbmNlIiwiZG9tUmVmZXJlbmNlUmVmIiwiZmxvYXRpbmdJZCIsInBvc2l0aW9uUmVmZXJlbmNlIiwidXNlRm9jdXMiLCJ2aXNpYmxlT25seSIsImJsb2NrRm9jdXNSZWYiLCJrZXlib2FyZE1vZGFsaXR5UmVmIiwib25CbHVyIiwibWF0Y2hlcyIsIm1vdmVkVG9Gb2N1c0d1YXJkIiwib3duZXJEb2N1bWVudCIsIkFDVElWRV9LRVkiLCJTRUxFQ1RFRF9LRVkiLCJtZXJnZVByb3BzIiwidXNlclByb3BzIiwicHJvcHNMaXN0IiwiZWxlbWVudEtleSIsImlzSXRlbSIsImRvbVVzZXJQcm9wcyIsIl8iLCJfXyIsInZhbGlkUHJvcHMiLCJwcm9wc09yR2V0UHJvcHMiLCJyZWR1Y2UiLCJhY2MiLCJ2YWwiLCJ1c2VJbnRlcmFjdGlvbnMiLCJkZXBzIiwiZ2V0UmVmZXJlbmNlUHJvcHMiLCJnZXRGbG9hdGluZ1Byb3BzIiwiZ2V0SXRlbVByb3BzIiwiaXRlbSIsImlzUHJldmVudFNjcm9sbFN1cHBvcnRlZCIsImRvU3dpdGNoIiwiaXNNYWluT3JpZW50YXRpb25LZXkiLCJpc01haW5PcmllbnRhdGlvblRvRW5kS2V5IiwicnRsIiwiaXNDcm9zc09yaWVudGF0aW9uT3BlbktleSIsImlzQ3Jvc3NPcmllbnRhdGlvbkNsb3NlS2V5IiwidXNlTGlzdE5hdmlnYXRpb24iLCJ1bnN0YWJsZV9vbk5hdmlnYXRlIiwic2VsZWN0ZWRJbmRleCIsImFsbG93RXNjYXBlIiwidmlydHVhbCIsImZvY3VzSXRlbU9uT3BlbiIsImZvY3VzSXRlbU9uSG92ZXIiLCJvcGVuT25BcnJvd0tleURvd24iLCJzY3JvbGxJdGVtSW50b1ZpZXciLCJ2aXJ0dWFsSXRlbVJlZiIsImpvaW4iLCJmb2N1c0l0ZW1Pbk9wZW5SZWYiLCJpbmRleFJlZiIsImtleVJlZiIsImlzUG9pbnRlck1vZGFsaXR5UmVmIiwicHJldmlvdXNPbk5hdmlnYXRlUmVmIiwicHJldmlvdXNNb3VudGVkUmVmIiwiZm9yY2VTeW5jRm9jdXMiLCJmb3JjZVNjcm9sbEludG9WaWV3UmVmIiwiZGlzYWJsZWRJbmRpY2VzUmVmIiwibGF0ZXN0T3BlblJlZiIsInNjcm9sbEl0ZW1JbnRvVmlld1JlZiIsImFjdGl2ZUlkIiwic2V0QWN0aXZlSWQiLCJ2aXJ0dWFsSWQiLCJzZXRWaXJ0dWFsSWQiLCJmb2N1c0l0ZW0iLCJmb3JjZVNjcm9sbEludG9WaWV3Iiwic2Nyb2xsSW50b1ZpZXdPcHRpb25zIiwic2hvdWxkU2Nyb2xsSW50b1ZpZXciLCJzY3JvbGxJbnRvVmlldyIsImJsb2NrIiwicnVucyIsIndhaXRGb3JMaXN0UG9wdWxhdGVkIiwic2NoZWR1bGVyIiwidHJlZUNvbnRhaW5zQWN0aXZlRWwiLCJoYW5kbGVWaXJ0dWFsRm9jdXMiLCJoYXNBY3RpdmVJbmRleCIsInN5bmNDdXJyZW50VGFyZ2V0Iiwib25Qb2ludGVyTGVhdmUiLCJfcmVmNCIsImN1cnJlbnRJbmRleCIsIm1pbiIsIm1heCIsImNoZWNrVmlydHVhbE1vdXNlIiwiY2hlY2tWaXJ0dWFsUG9pbnRlciIsImFyaWFBY3RpdmVEZXNjZW5kYW50UHJvcCIsImFjdGl2ZUl0ZW0iLCJpc0Fycm93S2V5IiwiaXNDcm9zc09wZW5LZXkiLCJpc0Nyb3NzQ2xvc2VLZXkiLCJpc01haW5LZXkiLCJpc05hdmlnYXRpb25LZXkiLCJ0cmltIiwicm9vdE5vZGUiLCJkZWVwZXN0Tm9kZSIsImV2ZW50T2JqZWN0IiwiS2V5Ym9hcmRFdmVudCIsIl9kZWVwZXN0Tm9kZSRjb250ZXh0IiwiX2RlZXBlc3ROb2RlJGNvbnRleHQyIiwiaXNDdXJyZW50VGFyZ2V0IiwiZGlzcGF0Y2hJdGVtIiwiZGlzcGF0Y2hFdmVudCIsIl9kZWVwZXN0Tm9kZSRjb250ZXh0JCIsIm9uUG9pbnRlck1vdmUiLCJjb21wb25lbnRSb2xlVG9BcmlhUm9sZU1hcCIsInVzZVJvbGUiLCJfY29tcG9uZW50Um9sZVRvQXJpYVIiLCJhcmlhUm9sZSIsInJlZmVyZW5jZUlkIiwiaXNOZXN0ZWQiLCJmbG9hdGluZ1Byb3BzIiwiYWN0aXZlIiwic2VsZWN0ZWQiLCJjb21tb25Qcm9wcyIsImNhbWVsQ2FzZVRvS2ViYWJDYXNlIiwic3RyIiwicmVwbGFjZSIsIiQiLCJvZnMiLCJ0b0xvd2VyQ2FzZSIsImV4ZWNXaXRoQXJnc09yUmV0dXJuIiwidmFsdWVPckZuIiwidXNlRGVsYXlVbm1vdW50IiwiZHVyYXRpb25NcyIsImlzTW91bnRlZCIsInNldElzTW91bnRlZCIsInVzZVRyYW5zaXRpb25TdGF0dXMiLCJkdXJhdGlvbiIsImlzTnVtYmVyRHVyYXRpb24iLCJjbG9zZUR1cmF0aW9uIiwiaW5pdGlhdGVkIiwic2V0SW5pdGlhdGVkIiwic3RhdHVzIiwic2V0U3RhdHVzIiwiZnJhbWUiLCJ1c2VUcmFuc2l0aW9uU3R5bGVzIiwiaW5pdGlhbCIsInVuc3RhYmxlX2luaXRpYWwiLCJvcGFjaXR5IiwidW5zdGFibGVfb3BlbiIsInVuc3RhYmxlX2Nsb3NlIiwiY29tbW9uIiwidW5zdGFibGVfY29tbW9uIiwiZm5BcmdzIiwib3BlbkR1cmF0aW9uIiwic3R5bGVzIiwic2V0U3R5bGVzIiwib3BlblJlZiIsImNsb3NlUmVmIiwiY29tbW9uUmVmIiwiaW5pdGlhbFN0eWxlcyIsImNsb3NlU3R5bGVzIiwiY29tbW9uU3R5bGVzIiwib3BlblN0eWxlcyIsInRyYW5zaXRpb25Qcm9wZXJ0eSIsInRyYW5zaXRpb25EdXJhdGlvbiIsInVzZVR5cGVhaGVhZCIsIm9uTWF0Y2giLCJ1bnN0YWJsZV9vbk1hdGNoIiwib25UeXBpbmdDaGFuZ2UiLCJ1bnN0YWJsZV9vblR5cGluZ0NoYW5nZSIsImZpbmRNYXRjaCIsInJlc2V0TXMiLCJpZ25vcmVLZXlzIiwidGltZW91dElkUmVmIiwic3RyaW5nUmVmIiwicHJldkluZGV4UmVmIiwibWF0Y2hJbmRleFJlZiIsImZpbmRNYXRjaFJlZiIsImlnbm9yZUtleXNSZWYiLCJzZXRUeXBpbmdDaGFuZ2UiLCJ0eXBpbmciLCJnZXRNYXRjaGluZ0luZGV4Iiwib3JkZXJlZExpc3QiLCJzdHJpbmciLCJ0ZXh0IiwidG9Mb2NhbGVMb3dlckNhc2UiLCJsaXN0Q29udGVudCIsImN0cmxLZXkiLCJtZXRhS2V5IiwiYWx0S2V5IiwiYWxsb3dSYXBpZFN1Y2Nlc3Npb25PZkZpcnN0TGV0dGVyIiwiX3RleHQkIiwiX3RleHQkMiIsImdldEFyZ3NXaXRoQ3VzdG9tRmxvYXRpbmdIZWlnaHQiLCJyZWN0cyIsImlubmVyIiwib3ZlcmZsb3dSZWYiLCJvbkZhbGxiYWNrQ2hhbmdlIiwiaW5uZXJPZmZzZXQiLCJtaW5JdGVtc1Zpc2libGUiLCJyZWZlcmVuY2VPdmVyZmxvd1RocmVzaG9sZCIsInNjcm9sbFJlZiIsImRldGVjdE92ZXJmbG93T3B0aW9ucyIsInN0YXJ0c1dpdGgiLCJuZXh0QXJncyIsImNsaWVudFRvcCIsIm9mZnNldEhlaWdodCIsInJlZk92ZXJmbG93IiwiZWxlbWVudENvbnRleHQiLCJkaWZmWSIsIm5leHRZIiwibWF4SGVpZ2h0Iiwic2Nyb2xsVG9wIiwidXNlSW5uZXJPZmZzZXQiLCJvbkNoYW5nZSIsInVuc3RhYmxlX29uQ2hhbmdlIiwiY29udHJvbGxlZFNjcm9sbGluZ1JlZiIsInByZXZTY3JvbGxUb3BSZWYiLCJpbml0aWFsT3ZlcmZsb3dSZWYiLCJvbldoZWVsIiwiZFkiLCJkZWx0YVkiLCJpc0F0VG9wIiwiaXNBdEJvdHRvbSIsInJlbWFpbmluZ1Njcm9sbCIsInNpZ24iLCJtZXRob2QiLCJzY3JvbGxEaWZmIiwiaXNQb2ludEluUG9seWdvbiIsInBvaW50IiwicG9seWdvbiIsImlzSW5zaWRlIiwiaiIsInhpIiwieWkiLCJ4aiIsInlqIiwiaW50ZXJzZWN0IiwicmVjdCIsInNhZmVQb2x5Z29uIiwiYnVmZmVyIiwicmVxdWlyZUludGVudCIsImhhc0xhbmRlZCIsImxhc3RYIiwibGFzdFkiLCJsYXN0Q3Vyc29yVGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiZ2V0Q3Vyc29yU3BlZWQiLCJjdXJyZW50VGltZSIsImVsYXBzZWRUaW1lIiwiZGVsdGFYIiwiZGlzdGFuY2UiLCJzcXJ0Iiwic3BlZWQiLCJjbGllbnRQb2ludCIsImlzTGVhdmUiLCJpc092ZXJGbG9hdGluZ0VsIiwiaXNPdmVyUmVmZXJlbmNlRWwiLCJyZWZSZWN0IiwiY3Vyc29yTGVhdmVGcm9tUmlnaHQiLCJjdXJzb3JMZWF2ZUZyb21Cb3R0b20iLCJpc092ZXJSZWZlcmVuY2VSZWN0IiwiaXNGbG9hdGluZ1dpZGVyIiwiaXNGbG9hdGluZ1RhbGxlciIsInJlY3RQb2x5IiwiZ2V0UG9seWdvbiIsImN1cnNvclBvaW50T25lIiwiY3Vyc29yUG9pbnRUd28iLCJjb21tb25Qb2ludHMiLCJjdXJzb3JTcGVlZCIsImN1cnNvclNwZWVkVGhyZXNob2xkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/react/dist/floating-ui.react.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/react/utils/dist/floating-ui.react.utils.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/@floating-ui/react/utils/dist/floating-ui.react.utils.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TYPEABLE_SELECTOR: () => (/* binding */ TYPEABLE_SELECTOR),\n/* harmony export */   activeElement: () => (/* binding */ activeElement),\n/* harmony export */   contains: () => (/* binding */ contains),\n/* harmony export */   getDocument: () => (/* binding */ getDocument),\n/* harmony export */   getPlatform: () => (/* binding */ getPlatform),\n/* harmony export */   getTarget: () => (/* binding */ getTarget),\n/* harmony export */   getUserAgent: () => (/* binding */ getUserAgent),\n/* harmony export */   isAndroid: () => (/* binding */ isAndroid),\n/* harmony export */   isEventTargetWithin: () => (/* binding */ isEventTargetWithin),\n/* harmony export */   isMac: () => (/* binding */ isMac),\n/* harmony export */   isMouseLikePointerType: () => (/* binding */ isMouseLikePointerType),\n/* harmony export */   isReactEvent: () => (/* binding */ isReactEvent),\n/* harmony export */   isRootElement: () => (/* binding */ isRootElement),\n/* harmony export */   isSafari: () => (/* binding */ isSafari),\n/* harmony export */   isTypeableCombobox: () => (/* binding */ isTypeableCombobox),\n/* harmony export */   isTypeableElement: () => (/* binding */ isTypeableElement),\n/* harmony export */   isVirtualClick: () => (/* binding */ isVirtualClick),\n/* harmony export */   isVirtualPointerEvent: () => (/* binding */ isVirtualPointerEvent),\n/* harmony export */   stopEvent: () => (/* binding */ stopEvent)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/utils/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs\");\n\nfunction activeElement(doc) {\n    let activeElement = doc.activeElement;\n    while(((_activeElement = activeElement) == null || (_activeElement = _activeElement.shadowRoot) == null ? void 0 : _activeElement.activeElement) != null){\n        var _activeElement;\n        activeElement = activeElement.shadowRoot.activeElement;\n    }\n    return activeElement;\n}\nfunction contains(parent, child) {\n    if (!parent || !child) {\n        return false;\n    }\n    const rootNode = child.getRootNode && child.getRootNode();\n    // First, attempt with faster native method\n    if (parent.contains(child)) {\n        return true;\n    }\n    // then fallback to custom implementation with Shadow DOM support\n    if (rootNode && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isShadowRoot)(rootNode)) {\n        let next = child;\n        while(next){\n            if (parent === next) {\n                return true;\n            }\n            // @ts-ignore\n            next = next.parentNode || next.host;\n        }\n    }\n    // Give up, the result is false\n    return false;\n}\n// Avoid Chrome DevTools blue warning.\nfunction getPlatform() {\n    const uaData = navigator.userAgentData;\n    if (uaData != null && uaData.platform) {\n        return uaData.platform;\n    }\n    return navigator.platform;\n}\nfunction getUserAgent() {\n    const uaData = navigator.userAgentData;\n    if (uaData && Array.isArray(uaData.brands)) {\n        return uaData.brands.map((_ref)=>{\n            let { brand, version } = _ref;\n            return brand + \"/\" + version;\n        }).join(\" \");\n    }\n    return navigator.userAgent;\n}\n// License: https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/utils/src/isVirtualEvent.ts\nfunction isVirtualClick(event) {\n    // FIXME: Firefox is now emitting a deprecation warning for `mozInputSource`.\n    // Try to find a workaround for this. `react-aria` source still has the check.\n    if (event.mozInputSource === 0 && event.isTrusted) {\n        return true;\n    }\n    if (isAndroid() && event.pointerType) {\n        return event.type === \"click\" && event.buttons === 1;\n    }\n    return event.detail === 0 && !event.pointerType;\n}\nfunction isVirtualPointerEvent(event) {\n    return !isAndroid() && event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === \"mouse\" || // iOS VoiceOver returns 0.333• for width/height.\n    event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0;\n}\nfunction isSafari() {\n    // Chrome DevTools does not complain about navigator.vendor\n    return /apple/i.test(navigator.vendor);\n}\nfunction isAndroid() {\n    const re = /android/i;\n    return re.test(getPlatform()) || re.test(getUserAgent());\n}\nfunction isMac() {\n    return getPlatform().toLowerCase().startsWith(\"mac\") && !navigator.maxTouchPoints;\n}\nfunction isMouseLikePointerType(pointerType, strict) {\n    // On some Linux machines with Chromium, mouse inputs return a `pointerType`\n    // of \"pen\": https://github.com/floating-ui/floating-ui/issues/2015\n    const values = [\n        \"mouse\",\n        \"pen\"\n    ];\n    if (!strict) {\n        values.push(\"\", undefined);\n    }\n    return values.includes(pointerType);\n}\nfunction isReactEvent(event) {\n    return \"nativeEvent\" in event;\n}\nfunction isRootElement(element) {\n    return element.matches(\"html,body\");\n}\nfunction getDocument(node) {\n    return (node == null ? void 0 : node.ownerDocument) || document;\n}\nfunction isEventTargetWithin(event, node) {\n    if (node == null) {\n        return false;\n    }\n    if (\"composedPath\" in event) {\n        return event.composedPath().includes(node);\n    }\n    // TS thinks `event` is of type never as it assumes all browsers support composedPath, but browsers without shadow dom don't\n    const e = event;\n    return e.target != null && node.contains(e.target);\n}\nfunction getTarget(event) {\n    if (\"composedPath\" in event) {\n        return event.composedPath()[0];\n    }\n    // TS thinks `event` is of type never as it assumes all browsers support\n    // `composedPath()`, but browsers without shadow DOM don't.\n    return event.target;\n}\nconst TYPEABLE_SELECTOR = \"input:not([type='hidden']):not([disabled]),\" + \"[contenteditable]:not([contenteditable='false']),textarea:not([disabled])\";\nfunction isTypeableElement(element) {\n    return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) && element.matches(TYPEABLE_SELECTOR);\n}\nfunction stopEvent(event) {\n    event.preventDefault();\n    event.stopPropagation();\n}\nfunction isTypeableCombobox(element) {\n    if (!element) return false;\n    return element.getAttribute(\"role\") === \"combobox\" && isTypeableElement(element);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0L3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkucmVhY3QudXRpbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFFO0FBRXJFLFNBQVNFLGNBQWNDLEdBQUc7SUFDeEIsSUFBSUQsZ0JBQWdCQyxJQUFJRCxhQUFhO0lBQ3JDLE1BQU8sQ0FBQyxDQUFDRSxpQkFBaUJGLGFBQVksS0FBTSxRQUFRLENBQUNFLGlCQUFpQkEsZUFBZUMsVUFBVSxLQUFLLE9BQU8sS0FBSyxJQUFJRCxlQUFlRixhQUFhLEtBQUssS0FBTTtRQUN6SixJQUFJRTtRQUNKRixnQkFBZ0JBLGNBQWNHLFVBQVUsQ0FBQ0gsYUFBYTtJQUN4RDtJQUNBLE9BQU9BO0FBQ1Q7QUFDQSxTQUFTSSxTQUFTQyxNQUFNLEVBQUVDLEtBQUs7SUFDN0IsSUFBSSxDQUFDRCxVQUFVLENBQUNDLE9BQU87UUFDckIsT0FBTztJQUNUO0lBQ0EsTUFBTUMsV0FBV0QsTUFBTUUsV0FBVyxJQUFJRixNQUFNRSxXQUFXO0lBRXZELDJDQUEyQztJQUMzQyxJQUFJSCxPQUFPRCxRQUFRLENBQUNFLFFBQVE7UUFDMUIsT0FBTztJQUNUO0lBRUEsaUVBQWlFO0lBQ2pFLElBQUlDLFlBQVlULG9FQUFZQSxDQUFDUyxXQUFXO1FBQ3RDLElBQUlFLE9BQU9IO1FBQ1gsTUFBT0csS0FBTTtZQUNYLElBQUlKLFdBQVdJLE1BQU07Z0JBQ25CLE9BQU87WUFDVDtZQUNBLGFBQWE7WUFDYkEsT0FBT0EsS0FBS0MsVUFBVSxJQUFJRCxLQUFLRSxJQUFJO1FBQ3JDO0lBQ0Y7SUFFQSwrQkFBK0I7SUFDL0IsT0FBTztBQUNUO0FBQ0Esc0NBQXNDO0FBQ3RDLFNBQVNDO0lBQ1AsTUFBTUMsU0FBU0MsVUFBVUMsYUFBYTtJQUN0QyxJQUFJRixVQUFVLFFBQVFBLE9BQU9HLFFBQVEsRUFBRTtRQUNyQyxPQUFPSCxPQUFPRyxRQUFRO0lBQ3hCO0lB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LEVBQUU7SUFDaEM7SUFFQSx3RUFBd0U7SUFDeEUsMkRBQTJEO0lBQzNELE9BQU9uQyxNQUFNcUMsTUFBTTtBQUNyQjtBQUNBLE1BQU1FLG9CQUFvQixnREFBZ0Q7QUFDMUUsU0FBU0Msa0JBQWtCWixPQUFPO0lBQ2hDLE9BQU96RCxxRUFBYUEsQ0FBQ3lELFlBQVlBLFFBQVFDLE9BQU8sQ0FBQ1U7QUFDbkQ7QUFDQSxTQUFTRSxVQUFVekMsS0FBSztJQUN0QkEsTUFBTTBDLGNBQWM7SUFDcEIxQyxNQUFNMkMsZUFBZTtBQUN2QjtBQUNBLFNBQVNDLG1CQUFtQmhCLE9BQU87SUFDakMsSUFBSSxDQUFDQSxTQUFTLE9BQU87SUFDckIsT0FBT0EsUUFBUWlCLFlBQVksQ0FBQyxZQUFZLGNBQWNMLGtCQUFrQlo7QUFDMUU7QUFFd1MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWItYXBwLy4vbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS9yZWFjdC91dGlscy9kaXN0L2Zsb2F0aW5nLXVpLnJlYWN0LnV0aWxzLm1qcz81MzVjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzU2hhZG93Um9vdCwgaXNIVE1MRWxlbWVudCB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscy9kb20nO1xuXG5mdW5jdGlvbiBhY3RpdmVFbGVtZW50KGRvYykge1xuICBsZXQgYWN0aXZlRWxlbWVudCA9IGRvYy5hY3RpdmVFbGVtZW50O1xuICB3aGlsZSAoKChfYWN0aXZlRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQpID09IG51bGwgfHwgKF9hY3RpdmVFbGVtZW50ID0gX2FjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hY3RpdmVFbGVtZW50LmFjdGl2ZUVsZW1lbnQpICE9IG51bGwpIHtcbiAgICB2YXIgX2FjdGl2ZUVsZW1lbnQ7XG4gICAgYWN0aXZlRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50O1xuICB9XG4gIHJldHVybiBhY3RpdmVFbGVtZW50O1xufVxuZnVuY3Rpb24gY29udGFpbnMocGFyZW50LCBjaGlsZCkge1xuICBpZiAoIXBhcmVudCB8fCAhY2hpbGQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgcm9vdE5vZGUgPSBjaGlsZC5nZXRSb290Tm9kZSAmJiBjaGlsZC5nZXRSb290Tm9kZSgpO1xuXG4gIC8vIEZpcnN0LCBhdHRlbXB0IHdpdGggZmFzdGVyIG5hdGl2ZSBtZXRob2RcbiAgaWYgKHBhcmVudC5jb250YWlucyhjaGlsZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHRoZW4gZmFsbGJhY2sgdG8gY3VzdG9tIGltcGxlbWVudGF0aW9uIHdpdGggU2hhZG93IERPTSBzdXBwb3J0XG4gIGlmIChyb290Tm9kZSAmJiBpc1NoYWRvd1Jvb3Qocm9vdE5vZGUpKSB7XG4gICAgbGV0IG5leHQgPSBjaGlsZDtcbiAgICB3aGlsZSAobmV4dCkge1xuICAgICAgaWYgKHBhcmVudCA9PT0gbmV4dCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIG5leHQgPSBuZXh0LnBhcmVudE5vZGUgfHwgbmV4dC5ob3N0O1xuICAgIH1cbiAgfVxuXG4gIC8vIEdpdmUgdXAsIHRoZSByZXN1bHQgaXMgZmFsc2VcbiAgcmV0dXJuIGZhbHNlO1xufVxuLy8gQXZvaWQgQ2hyb21lIERldlRvb2xzIGJsdWUgd2FybmluZy5cbmZ1bmN0aW9uIGdldFBsYXRmb3JtKCkge1xuICBjb25zdCB1YURhdGEgPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YTtcbiAgaWYgKHVhRGF0YSAhPSBudWxsICYmIHVhRGF0YS5wbGF0Zm9ybSkge1xuICAgIHJldHVybiB1YURhdGEucGxhdGZvcm07XG4gIH1cbiAgcmV0dXJuIG5hdmlnYXRvci5wbGF0Zm9ybTtcbn1cbmZ1bmN0aW9uIGdldFVzZXJBZ2VudCgpIHtcbiAgY29uc3QgdWFEYXRhID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7XG4gIGlmICh1YURhdGEgJiYgQXJyYXkuaXNBcnJheSh1YURhdGEuYnJhbmRzKSkge1xuICAgIHJldHVybiB1YURhdGEuYnJhbmRzLm1hcChfcmVmID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIGJyYW5kLFxuICAgICAgICB2ZXJzaW9uXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIHJldHVybiBicmFuZCArIFwiL1wiICsgdmVyc2lvbjtcbiAgICB9KS5qb2luKCcgJyk7XG4gIH1cbiAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQ7XG59XG5cbi8vIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZG9iZS9yZWFjdC1zcGVjdHJ1bS9ibG9iL2IzNWQ1YzAyZmU5MDBiYWRjY2QwY2YxYThmMjNiYjU5MzQxOWYyMzgvcGFja2FnZXMvQHJlYWN0LWFyaWEvdXRpbHMvc3JjL2lzVmlydHVhbEV2ZW50LnRzXG5mdW5jdGlvbiBpc1ZpcnR1YWxDbGljayhldmVudCkge1xuICAvLyBGSVhNRTogRmlyZWZveCBpcyBub3cgZW1pdHRpbmcgYSBkZXByZWNhdGlvbiB3YXJuaW5nIGZvciBgbW96SW5wdXRTb3VyY2VgLlxuICAvLyBUcnkgdG8gZmluZCBhIHdvcmthcm91bmQgZm9yIHRoaXMuIGByZWFjdC1hcmlhYCBzb3VyY2Ugc3RpbGwgaGFzIHRoZSBjaGVjay5cbiAgaWYgKGV2ZW50Lm1veklucHV0U291cmNlID09PSAwICYmIGV2ZW50LmlzVHJ1c3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc0FuZHJvaWQoKSAmJiBldmVudC5wb2ludGVyVHlwZSkge1xuICAgIHJldHVybiBldmVudC50eXBlID09PSAnY2xpY2snICYmIGV2ZW50LmJ1dHRvbnMgPT09IDE7XG4gIH1cbiAgcmV0dXJuIGV2ZW50LmRldGFpbCA9PT0gMCAmJiAhZXZlbnQucG9pbnRlclR5cGU7XG59XG5mdW5jdGlvbiBpc1ZpcnR1YWxQb2ludGVyRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuICFpc0FuZHJvaWQoKSAmJiBldmVudC53aWR0aCA9PT0gMCAmJiBldmVudC5oZWlnaHQgPT09IDAgfHwgZXZlbnQud2lkdGggPT09IDEgJiYgZXZlbnQuaGVpZ2h0ID09PSAxICYmIGV2ZW50LnByZXNzdXJlID09PSAwICYmIGV2ZW50LmRldGFpbCA9PT0gMCAmJiBldmVudC5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyB8fFxuICAvLyBpT1MgVm9pY2VPdmVyIHJldHVybnMgMC4zMzPigKIgZm9yIHdpZHRoL2hlaWdodC5cbiAgZXZlbnQud2lkdGggPCAxICYmIGV2ZW50LmhlaWdodCA8IDEgJiYgZXZlbnQucHJlc3N1cmUgPT09IDAgJiYgZXZlbnQuZGV0YWlsID09PSAwO1xufVxuZnVuY3Rpb24gaXNTYWZhcmkoKSB7XG4gIC8vIENocm9tZSBEZXZUb29scyBkb2VzIG5vdCBjb21wbGFpbiBhYm91dCBuYXZpZ2F0b3IudmVuZG9yXG4gIHJldHVybiAvYXBwbGUvaS50ZXN0KG5hdmlnYXRvci52ZW5kb3IpO1xufVxuZnVuY3Rpb24gaXNBbmRyb2lkKCkge1xuICBjb25zdCByZSA9IC9hbmRyb2lkL2k7XG4gIHJldHVybiByZS50ZXN0KGdldFBsYXRmb3JtKCkpIHx8IHJlLnRlc3QoZ2V0VXNlckFnZW50KCkpO1xufVxuZnVuY3Rpb24gaXNNYWMoKSB7XG4gIHJldHVybiBnZXRQbGF0Zm9ybSgpLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnbWFjJykgJiYgIW5hdmlnYXRvci5tYXhUb3VjaFBvaW50cztcbn1cbmZ1bmN0aW9uIGlzTW91c2VMaWtlUG9pbnRlclR5cGUocG9pbnRlclR5cGUsIHN0cmljdCkge1xuICAvLyBPbiBzb21lIExpbnV4IG1hY2hpbmVzIHdpdGggQ2hyb21pdW0sIG1vdXNlIGlucHV0cyByZXR1cm4gYSBgcG9pbnRlclR5cGVgXG4gIC8vIG9mIFwicGVuXCI6IGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMjAxNVxuICBjb25zdCB2YWx1ZXMgPSBbJ21vdXNlJywgJ3BlbiddO1xuICBpZiAoIXN0cmljdCkge1xuICAgIHZhbHVlcy5wdXNoKCcnLCB1bmRlZmluZWQpO1xuICB9XG4gIHJldHVybiB2YWx1ZXMuaW5jbHVkZXMocG9pbnRlclR5cGUpO1xufVxuZnVuY3Rpb24gaXNSZWFjdEV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiAnbmF0aXZlRXZlbnQnIGluIGV2ZW50O1xufVxuZnVuY3Rpb24gaXNSb290RWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50Lm1hdGNoZXMoJ2h0bWwsYm9keScpO1xufVxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQobm9kZSkge1xuICByZXR1cm4gKG5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IG5vZGUub3duZXJEb2N1bWVudCkgfHwgZG9jdW1lbnQ7XG59XG5mdW5jdGlvbiBpc0V2ZW50VGFyZ2V0V2l0aGluKGV2ZW50LCBub2RlKSB7XG4gIGlmIChub2RlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCdjb21wb3NlZFBhdGgnIGluIGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LmNvbXBvc2VkUGF0aCgpLmluY2x1ZGVzKG5vZGUpO1xuICB9XG5cbiAgLy8gVFMgdGhpbmtzIGBldmVudGAgaXMgb2YgdHlwZSBuZXZlciBhcyBpdCBhc3N1bWVzIGFsbCBicm93c2VycyBzdXBwb3J0IGNvbXBvc2VkUGF0aCwgYnV0IGJyb3dzZXJzIHdpdGhvdXQgc2hhZG93IGRvbSBkb24ndFxuICBjb25zdCBlID0gZXZlbnQ7XG4gIHJldHVybiBlLnRhcmdldCAhPSBudWxsICYmIG5vZGUuY29udGFpbnMoZS50YXJnZXQpO1xufVxuZnVuY3Rpb24gZ2V0VGFyZ2V0KGV2ZW50KSB7XG4gIGlmICgnY29tcG9zZWRQYXRoJyBpbiBldmVudCkge1xuICAgIHJldHVybiBldmVudC5jb21wb3NlZFBhdGgoKVswXTtcbiAgfVxuXG4gIC8vIFRTIHRoaW5rcyBgZXZlbnRgIGlzIG9mIHR5cGUgbmV2ZXIgYXMgaXQgYXNzdW1lcyBhbGwgYnJvd3NlcnMgc3VwcG9ydFxuICAvLyBgY29tcG9zZWRQYXRoKClgLCBidXQgYnJvd3NlcnMgd2l0aG91dCBzaGFkb3cgRE9NIGRvbid0LlxuICByZXR1cm4gZXZlbnQudGFyZ2V0O1xufVxuY29uc3QgVFlQRUFCTEVfU0VMRUNUT1IgPSBcImlucHV0Om5vdChbdHlwZT0naGlkZGVuJ10pOm5vdChbZGlzYWJsZWRdKSxcIiArIFwiW2NvbnRlbnRlZGl0YWJsZV06bm90KFtjb250ZW50ZWRpdGFibGU9J2ZhbHNlJ10pLHRleHRhcmVhOm5vdChbZGlzYWJsZWRdKVwiO1xuZnVuY3Rpb24gaXNUeXBlYWJsZUVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gaXNIVE1MRWxlbWVudChlbGVtZW50KSAmJiBlbGVtZW50Lm1hdGNoZXMoVFlQRUFCTEVfU0VMRUNUT1IpO1xufVxuZnVuY3Rpb24gc3RvcEV2ZW50KGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xufVxuZnVuY3Rpb24gaXNUeXBlYWJsZUNvbWJvYm94KGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZSgncm9sZScpID09PSAnY29tYm9ib3gnICYmIGlzVHlwZWFibGVFbGVtZW50KGVsZW1lbnQpO1xufVxuXG5leHBvcnQgeyBUWVBFQUJMRV9TRUxFQ1RPUiwgYWN0aXZlRWxlbWVudCwgY29udGFpbnMsIGdldERvY3VtZW50LCBnZXRQbGF0Zm9ybSwgZ2V0VGFyZ2V0LCBnZXRVc2VyQWdlbnQsIGlzQW5kcm9pZCwgaXNFdmVudFRhcmdldFdpdGhpbiwgaXNNYWMsIGlzTW91c2VMaWtlUG9pbnRlclR5cGUsIGlzUmVhY3RFdmVudCwgaXNSb290RWxlbWVudCwgaXNTYWZhcmksIGlzVHlwZWFibGVDb21ib2JveCwgaXNUeXBlYWJsZUVsZW1lbnQsIGlzVmlydHVhbENsaWNrLCBpc1ZpcnR1YWxQb2ludGVyRXZlbnQsIHN0b3BFdmVudCB9O1xuIl0sIm5hbWVzIjpbImlzU2hhZG93Um9vdCIsImlzSFRNTEVsZW1lbnQiLCJhY3RpdmVFbGVtZW50IiwiZG9jIiwiX2FjdGl2ZUVsZW1lbnQiLCJzaGFkb3dSb290IiwiY29udGFpbnMiLCJwYXJlbnQiLCJjaGlsZCIsInJvb3ROb2RlIiwiZ2V0Um9vdE5vZGUiLCJuZXh0IiwicGFyZW50Tm9kZSIsImhvc3QiLCJnZXRQbGF0Zm9ybSIsInVhRGF0YSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudERhdGEiLCJwbGF0Zm9ybSIsImdldFVzZXJBZ2VudCIsIkFycmF5IiwiaXNBcnJheSIsImJyYW5kcyIsIm1hcCIsIl9yZWYiLCJicmFuZCIsInZlcnNpb24iLCJqb2luIiwidXNlckFnZW50IiwiaXNWaXJ0dWFsQ2xpY2siLCJldmVudCIsIm1veklucHV0U291cmNlIiwiaXNUcnVzdGVkIiwiaXNBbmRyb2lkIiwicG9pbnRlclR5cGUiLCJ0eXBlIiwiYnV0dG9ucyIsImRldGFpbCIsImlzVmlydHVhbFBvaW50ZXJFdmVudCIsIndpZHRoIiwiaGVpZ2h0IiwicHJlc3N1cmUiLCJpc1NhZmFyaSIsInRlc3QiLCJ2ZW5kb3IiLCJyZSIsImlzTWFjIiwidG9Mb3dlckNhc2UiLCJzdGFydHNXaXRoIiwibWF4VG91Y2hQb2ludHMiLCJpc01vdXNlTGlrZVBvaW50ZXJUeXBlIiwic3RyaWN0IiwidmFsdWVzIiwicHVzaCIsInVuZGVmaW5lZCIsImluY2x1ZGVzIiwiaXNSZWFjdEV2ZW50IiwiaXNSb290RWxlbWVudCIsImVsZW1lbnQiLCJtYXRjaGVzIiwiZ2V0RG9jdW1lbnQiLCJub2RlIiwib3duZXJEb2N1bWVudCIsImRvY3VtZW50IiwiaXNFdmVudFRhcmdldFdpdGhpbiIsImNvbXBvc2VkUGF0aCIsImUiLCJ0YXJnZXQiLCJnZXRUYXJnZXQiLCJUWVBFQUJMRV9TRUxFQ1RPUiIsImlzVHlwZWFibGVFbGVtZW50Iiwic3RvcEV2ZW50IiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJpc1R5cGVhYmxlQ29tYm9ib3giLCJnZXRBdHRyaWJ1dGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/react/utils/dist/floating-ui.react.utils.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   alignments: () => (/* binding */ alignments),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   createCoords: () => (/* binding */ createCoords),\n/* harmony export */   evaluate: () => (/* binding */ evaluate),\n/* harmony export */   expandPaddingObject: () => (/* binding */ expandPaddingObject),\n/* harmony export */   floor: () => (/* binding */ floor),\n/* harmony export */   getAlignment: () => (/* binding */ getAlignment),\n/* harmony export */   getAlignmentAxis: () => (/* binding */ getAlignmentAxis),\n/* harmony export */   getAlignmentSides: () => (/* binding */ getAlignmentSides),\n/* harmony export */   getAxisLength: () => (/* binding */ getAxisLength),\n/* harmony export */   getExpandedPlacements: () => (/* binding */ getExpandedPlacements),\n/* harmony export */   getOppositeAlignmentPlacement: () => (/* binding */ getOppositeAlignmentPlacement),\n/* harmony export */   getOppositeAxis: () => (/* binding */ getOppositeAxis),\n/* harmony export */   getOppositeAxisPlacements: () => (/* binding */ getOppositeAxisPlacements),\n/* harmony export */   getOppositePlacement: () => (/* binding */ getOppositePlacement),\n/* harmony export */   getPaddingObject: () => (/* binding */ getPaddingObject),\n/* harmony export */   getSide: () => (/* binding */ getSide),\n/* harmony export */   getSideAxis: () => (/* binding */ getSideAxis),\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   placements: () => (/* binding */ placements),\n/* harmony export */   rectToClientRect: () => (/* binding */ rectToClientRect),\n/* harmony export */   round: () => (/* binding */ round),\n/* harmony export */   sides: () => (/* binding */ sides)\n/* harmony export */ });\nconst sides = [\n    \"top\",\n    \"right\",\n    \"bottom\",\n    \"left\"\n];\nconst alignments = [\n    \"start\",\n    \"end\"\n];\nconst placements = /*#__PURE__*/ sides.reduce((acc, side)=>acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = (v)=>({\n        x: v,\n        y: v\n    });\nconst oppositeSideMap = {\n    left: \"right\",\n    right: \"left\",\n    bottom: \"top\",\n    top: \"bottom\"\n};\nconst oppositeAlignmentMap = {\n    start: \"end\",\n    end: \"start\"\n};\nfunction clamp(start, value, end) {\n    return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n    return typeof value === \"function\" ? value(param) : value;\n}\nfunction getSide(placement) {\n    return placement.split(\"-\")[0];\n}\nfunction getAlignment(placement) {\n    return placement.split(\"-\")[1];\n}\nfunction getOppositeAxis(axis) {\n    return axis === \"x\" ? \"y\" : \"x\";\n}\nfunction getAxisLength(axis) {\n    return axis === \"y\" ? \"height\" : \"width\";\n}\nfunction getSideAxis(placement) {\n    return [\n        \"top\",\n        \"bottom\"\n    ].includes(getSide(placement)) ? \"y\" : \"x\";\n}\nfunction getAlignmentAxis(placement) {\n    return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n    if (rtl === void 0) {\n        rtl = false;\n    }\n    const alignment = getAlignment(placement);\n    const alignmentAxis = getAlignmentAxis(placement);\n    const length = getAxisLength(alignmentAxis);\n    let mainAlignmentSide = alignmentAxis === \"x\" ? alignment === (rtl ? \"end\" : \"start\") ? \"right\" : \"left\" : alignment === \"start\" ? \"bottom\" : \"top\";\n    if (rects.reference[length] > rects.floating[length]) {\n        mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n    }\n    return [\n        mainAlignmentSide,\n        getOppositePlacement(mainAlignmentSide)\n    ];\n}\nfunction getExpandedPlacements(placement) {\n    const oppositePlacement = getOppositePlacement(placement);\n    return [\n        getOppositeAlignmentPlacement(placement),\n        oppositePlacement,\n        getOppositeAlignmentPlacement(oppositePlacement)\n    ];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n    return placement.replace(/start|end/g, (alignment)=>oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n    const lr = [\n        \"left\",\n        \"right\"\n    ];\n    const rl = [\n        \"right\",\n        \"left\"\n    ];\n    const tb = [\n        \"top\",\n        \"bottom\"\n    ];\n    const bt = [\n        \"bottom\",\n        \"top\"\n    ];\n    switch(side){\n        case \"top\":\n        case \"bottom\":\n            if (rtl) return isStart ? rl : lr;\n            return isStart ? lr : rl;\n        case \"left\":\n        case \"right\":\n            return isStart ? tb : bt;\n        default:\n            return [];\n    }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n    const alignment = getAlignment(placement);\n    let list = getSideList(getSide(placement), direction === \"start\", rtl);\n    if (alignment) {\n        list = list.map((side)=>side + \"-\" + alignment);\n        if (flipAlignment) {\n            list = list.concat(list.map(getOppositeAlignmentPlacement));\n        }\n    }\n    return list;\n}\nfunction getOppositePlacement(placement) {\n    return placement.replace(/left|right|bottom|top/g, (side)=>oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n    return {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0,\n        ...padding\n    };\n}\nfunction getPaddingObject(padding) {\n    return typeof padding !== \"number\" ? expandPaddingObject(padding) : {\n        top: padding,\n        right: padding,\n        bottom: padding,\n        left: padding\n    };\n}\nfunction rectToClientRect(rect) {\n    return {\n        ...rect,\n        top: rect.y,\n        left: rect.x,\n        right: rect.x + rect.width,\n        bottom: rect.y + rect.height\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQU1BLFFBQVE7SUFBQztJQUFPO0lBQVM7SUFBVTtDQUFPO0FBQ2hELE1BQU1DLGFBQWE7SUFBQztJQUFTO0NBQU07QUFDbkMsTUFBTUMsYUFBYSxXQUFXLEdBQUVGLE1BQU1HLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxPQUFTRCxJQUFJRSxNQUFNLENBQUNELE1BQU1BLE9BQU8sTUFBTUosVUFBVSxDQUFDLEVBQUUsRUFBRUksT0FBTyxNQUFNSixVQUFVLENBQUMsRUFBRSxHQUFHLEVBQUU7QUFDeEksTUFBTU0sTUFBTUMsS0FBS0QsR0FBRztBQUNwQixNQUFNRSxNQUFNRCxLQUFLQyxHQUFHO0FBQ3BCLE1BQU1DLFFBQVFGLEtBQUtFLEtBQUs7QUFDeEIsTUFBTUMsUUFBUUgsS0FBS0csS0FBSztBQUN4QixNQUFNQyxlQUFlQyxDQUFBQSxJQUFNO1FBQ3pCQyxHQUFHRDtRQUNIRSxHQUFHRjtJQUNMO0FBQ0EsTUFBTUcsa0JBQWtCO0lBQ3RCQyxNQUFNO0lBQ05DLE9BQU87SUFDUEMsUUFBUTtJQUNSQyxLQUFLO0FBQ1A7QUFDQSxNQUFNQyx1QkFBdUI7SUFDM0JDLE9BQU87SUFDUEMsS0FBSztBQUNQO0FBQ0EsU0FBU0MsTUFBTUYsS0FBSyxFQUFFRyxLQUFLLEVBQUVGLEdBQUc7SUFDOUIsT0FBT2QsSUFBSWEsT0FBT2YsSUFBSWtCLE9BQU9GO0FBQy9CO0FBQ0EsU0FBU0csU0FBU0QsS0FBSyxFQUFFRSxLQUFLO0lBQzVCLE9BQU8sT0FBT0YsVUFBVSxhQUFhQSxNQUFNRSxTQUFTRjtBQUN0RDtBQUNBLFNBQVNHLFFBQVFDLFNBQVM7SUFDeEIsT0FBT0EsVUFBVUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQ2hDO0FBQ0EsU0FBU0MsYUFBYUYsU0FB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T0EsWUFBWSxXQUFXRCxvQkFBb0JDLFdBQVc7UUFDbEU1QyxLQUFLNEM7UUFDTDlDLE9BQU84QztRQUNQN0MsUUFBUTZDO1FBQ1IvQyxNQUFNK0M7SUFDUjtBQUNGO0FBQ0EsU0FBU0UsaUJBQWlCQyxJQUFJO0lBQzVCLE9BQU87UUFDTCxHQUFHQSxJQUFJO1FBQ1AvQyxLQUFLK0MsS0FBS3BELENBQUM7UUFDWEUsTUFBTWtELEtBQUtyRCxDQUFDO1FBQ1pJLE9BQU9pRCxLQUFLckQsQ0FBQyxHQUFHcUQsS0FBS0MsS0FBSztRQUMxQmpELFFBQVFnRCxLQUFLcEQsQ0FBQyxHQUFHb0QsS0FBS0UsTUFBTTtJQUM5QjtBQUNGO0FBRXlXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLWFwcC8uL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvdXRpbHMvZGlzdC9mbG9hdGluZy11aS51dGlscy5tanM/NWFlYSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBzaWRlcyA9IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J107XG5jb25zdCBhbGlnbm1lbnRzID0gWydzdGFydCcsICdlbmQnXTtcbmNvbnN0IHBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovc2lkZXMucmVkdWNlKChhY2MsIHNpZGUpID0+IGFjYy5jb25jYXQoc2lkZSwgc2lkZSArIFwiLVwiICsgYWxpZ25tZW50c1swXSwgc2lkZSArIFwiLVwiICsgYWxpZ25tZW50c1sxXSksIFtdKTtcbmNvbnN0IG1pbiA9IE1hdGgubWluO1xuY29uc3QgbWF4ID0gTWF0aC5tYXg7XG5jb25zdCByb3VuZCA9IE1hdGgucm91bmQ7XG5jb25zdCBmbG9vciA9IE1hdGguZmxvb3I7XG5jb25zdCBjcmVhdGVDb29yZHMgPSB2ID0+ICh7XG4gIHg6IHYsXG4gIHk6IHZcbn0pO1xuY29uc3Qgb3Bwb3NpdGVTaWRlTWFwID0ge1xuICBsZWZ0OiAncmlnaHQnLFxuICByaWdodDogJ2xlZnQnLFxuICBib3R0b206ICd0b3AnLFxuICB0b3A6ICdib3R0b20nXG59O1xuY29uc3Qgb3Bwb3NpdGVBbGlnbm1lbnRNYXAgPSB7XG4gIHN0YXJ0OiAnZW5kJyxcbiAgZW5kOiAnc3RhcnQnXG59O1xuZnVuY3Rpb24gY2xhbXAoc3RhcnQsIHZhbHVlLCBlbmQpIHtcbiAgcmV0dXJuIG1heChzdGFydCwgbWluKHZhbHVlLCBlbmQpKTtcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlKHZhbHVlLCBwYXJhbSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUocGFyYW0pIDogdmFsdWU7XG59XG5mdW5jdGlvbiBnZXRTaWRlKHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG59XG5mdW5jdGlvbiBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcbn1cbmZ1bmN0aW9uIGdldE9wcG9zaXRlQXhpcyhheGlzKSB7XG4gIHJldHVybiBheGlzID09PSAneCcgPyAneScgOiAneCc7XG59XG5mdW5jdGlvbiBnZXRBeGlzTGVuZ3RoKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbn1cbmZ1bmN0aW9uIGdldFNpZGVBeGlzKHBsYWNlbWVudCkge1xuICByZXR1cm4gWyd0b3AnLCAnYm90dG9tJ10uaW5jbHVkZXMoZ2V0U2lkZShwbGFjZW1lbnQpKSA/ICd5JyA6ICd4Jztcbn1cbmZ1bmN0aW9uIGdldEFsaWdubWVudEF4aXMocGxhY2VtZW50KSB7XG4gIHJldHVybiBnZXRPcHBvc2l0ZUF4aXMoZ2V0U2lkZUF4aXMocGxhY2VtZW50KSk7XG59XG5mdW5jdGlvbiBnZXRBbGlnbm1lbnRTaWRlcyhwbGFjZW1lbnQsIHJlY3RzLCBydGwpIHtcbiAgaWYgKHJ0bCA9PT0gdm9pZCAwKSB7XG4gICAgcnRsID0gZmFsc2U7XG4gIH1cbiAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gIGNvbnN0IGFsaWdubWVudEF4aXMgPSBnZXRBbGlnbm1lbnRBeGlzKHBsYWNlbWVudCk7XG4gIGNvbnN0IGxlbmd0aCA9IGdldEF4aXNMZW5ndGgoYWxpZ25tZW50QXhpcyk7XG4gIGxldCBtYWluQWxpZ25tZW50U2lkZSA9IGFsaWdubWVudEF4aXMgPT09ICd4JyA/IGFsaWdubWVudCA9PT0gKHJ0bCA/ICdlbmQnIDogJ3N0YXJ0JykgPyAncmlnaHQnIDogJ2xlZnQnIDogYWxpZ25tZW50ID09PSAnc3RhcnQnID8gJ2JvdHRvbScgOiAndG9wJztcbiAgaWYgKHJlY3RzLnJlZmVyZW5jZVtsZW5ndGhdID4gcmVjdHMuZmxvYXRpbmdbbGVuZ3RoXSkge1xuICAgIG1haW5BbGlnbm1lbnRTaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpbkFsaWdubWVudFNpZGUpO1xuICB9XG4gIHJldHVybiBbbWFpbkFsaWdubWVudFNpZGUsIGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5BbGlnbm1lbnRTaWRlKV07XG59XG5mdW5jdGlvbiBnZXRFeHBhbmRlZFBsYWNlbWVudHMocGxhY2VtZW50KSB7XG4gIGNvbnN0IG9wcG9zaXRlUGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgcmV0dXJuIFtnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChwbGFjZW1lbnQpLCBvcHBvc2l0ZVBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQob3Bwb3NpdGVQbGFjZW1lbnQpXTtcbn1cbmZ1bmN0aW9uIGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL3N0YXJ0fGVuZC9nLCBhbGlnbm1lbnQgPT4gb3Bwb3NpdGVBbGlnbm1lbnRNYXBbYWxpZ25tZW50XSk7XG59XG5mdW5jdGlvbiBnZXRTaWRlTGlzdChzaWRlLCBpc1N0YXJ0LCBydGwpIHtcbiAgY29uc3QgbHIgPSBbJ2xlZnQnLCAncmlnaHQnXTtcbiAgY29uc3QgcmwgPSBbJ3JpZ2h0JywgJ2xlZnQnXTtcbiAgY29uc3QgdGIgPSBbJ3RvcCcsICdib3R0b20nXTtcbiAgY29uc3QgYnQgPSBbJ2JvdHRvbScsICd0b3AnXTtcbiAgc3dpdGNoIChzaWRlKSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgaWYgKHJ0bCkgcmV0dXJuIGlzU3RhcnQgPyBybCA6IGxyO1xuICAgICAgcmV0dXJuIGlzU3RhcnQgPyBsciA6IHJsO1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHJldHVybiBpc1N0YXJ0ID8gdGIgOiBidDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFtdO1xuICB9XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzKHBsYWNlbWVudCwgZmxpcEFsaWdubWVudCwgZGlyZWN0aW9uLCBydGwpIHtcbiAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gIGxldCBsaXN0ID0gZ2V0U2lkZUxpc3QoZ2V0U2lkZShwbGFjZW1lbnQpLCBkaXJlY3Rpb24gPT09ICdzdGFydCcsIHJ0bCk7XG4gIGlmIChhbGlnbm1lbnQpIHtcbiAgICBsaXN0ID0gbGlzdC5tYXAoc2lkZSA9PiBzaWRlICsgXCItXCIgKyBhbGlnbm1lbnQpO1xuICAgIGlmIChmbGlwQWxpZ25tZW50KSB7XG4gICAgICBsaXN0ID0gbGlzdC5jb25jYXQobGlzdC5tYXAoZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxpc3Q7XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgc2lkZSA9PiBvcHBvc2l0ZVNpZGVNYXBbc2lkZV0pO1xufVxuZnVuY3Rpb24gZXhwYW5kUGFkZGluZ09iamVjdChwYWRkaW5nKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwLFxuICAgIC4uLnBhZGRpbmdcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFBhZGRpbmdPYmplY3QocGFkZGluZykge1xuICByZXR1cm4gdHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gZXhwYW5kUGFkZGluZ09iamVjdChwYWRkaW5nKSA6IHtcbiAgICB0b3A6IHBhZGRpbmcsXG4gICAgcmlnaHQ6IHBhZGRpbmcsXG4gICAgYm90dG9tOiBwYWRkaW5nLFxuICAgIGxlZnQ6IHBhZGRpbmdcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlY3RUb0NsaWVudFJlY3QocmVjdCkge1xuICByZXR1cm4ge1xuICAgIC4uLnJlY3QsXG4gICAgdG9wOiByZWN0LnksXG4gICAgbGVmdDogcmVjdC54LFxuICAgIHJpZ2h0OiByZWN0LnggKyByZWN0LndpZHRoLFxuICAgIGJvdHRvbTogcmVjdC55ICsgcmVjdC5oZWlnaHRcbiAgfTtcbn1cblxuZXhwb3J0IHsgYWxpZ25tZW50cywgY2xhbXAsIGNyZWF0ZUNvb3JkcywgZXZhbHVhdGUsIGV4cGFuZFBhZGRpbmdPYmplY3QsIGZsb29yLCBnZXRBbGlnbm1lbnQsIGdldEFsaWdubWVudEF4aXMsIGdldEFsaWdubWVudFNpZGVzLCBnZXRBeGlzTGVuZ3RoLCBnZXRFeHBhbmRlZFBsYWNlbWVudHMsIGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50LCBnZXRPcHBvc2l0ZUF4aXMsIGdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMsIGdldE9wcG9zaXRlUGxhY2VtZW50LCBnZXRQYWRkaW5nT2JqZWN0LCBnZXRTaWRlLCBnZXRTaWRlQXhpcywgbWF4LCBtaW4sIHBsYWNlbWVudHMsIHJlY3RUb0NsaWVudFJlY3QsIHJvdW5kLCBzaWRlcyB9O1xuIl0sIm5hbWVzIjpbInNpZGVzIiwiYWxpZ25tZW50cyIsInBsYWNlbWVudHMiLCJyZWR1Y2UiLCJhY2MiLCJzaWRlIiwiY29uY2F0IiwibWluIiwiTWF0aCIsIm1heCIsInJvdW5kIiwiZmxvb3IiLCJjcmVhdGVDb29yZHMiLCJ2IiwieCIsInkiLCJvcHBvc2l0ZVNpZGVNYXAiLCJsZWZ0IiwicmlnaHQiLCJib3R0b20iLCJ0b3AiLCJvcHBvc2l0ZUFsaWdubWVudE1hcCIsInN0YXJ0IiwiZW5kIiwiY2xhbXAiLCJ2YWx1ZSIsImV2YWx1YXRlIiwicGFyYW0iLCJnZXRTaWRlIiwicGxhY2VtZW50Iiwic3BsaXQiLCJnZXRBbGlnbm1lbnQiLCJnZXRPcHBvc2l0ZUF4aXMiLCJheGlzIiwiZ2V0QXhpc0xlbmd0aCIsImdldFNpZGVBeGlzIiwiaW5jbHVkZXMiLCJnZXRBbGlnbm1lbnRBeGlzIiwiZ2V0QWxpZ25tZW50U2lkZXMiLCJyZWN0cyIsInJ0bCIsImFsaWdubWVudCIsImFsaWdubWVudEF4aXMiLCJsZW5ndGgiLCJtYWluQWxpZ25tZW50U2lkZSIsInJlZmVyZW5jZSIsImZsb2F0aW5nIiwiZ2V0T3Bwb3NpdGVQbGFjZW1lbnQiLCJnZXRFeHBhbmRlZFBsYWNlbWVudHMiLCJvcHBvc2l0ZVBsYWNlbWVudCIsImdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50IiwicmVwbGFjZSIsImdldFNpZGVMaXN0IiwiaXNTdGFydCIsImxyIiwicmwiLCJ0YiIsImJ0IiwiZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cyIsImZsaXBBbGlnbm1lbnQiLCJkaXJlY3Rpb24iLCJsaXN0IiwibWFwIiwiZXhwYW5kUGFkZGluZ09iamVjdCIsInBhZGRpbmciLCJnZXRQYWRkaW5nT2JqZWN0IiwicmVjdFRvQ2xpZW50UmVjdCIsInJlY3QiLCJ3aWR0aCIsImhlaWdodCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getComputedStyle: () => (/* binding */ getComputedStyle),\n/* harmony export */   getContainingBlock: () => (/* binding */ getContainingBlock),\n/* harmony export */   getDocumentElement: () => (/* binding */ getDocumentElement),\n/* harmony export */   getNearestOverflowAncestor: () => (/* binding */ getNearestOverflowAncestor),\n/* harmony export */   getNodeName: () => (/* binding */ getNodeName),\n/* harmony export */   getNodeScroll: () => (/* binding */ getNodeScroll),\n/* harmony export */   getOverflowAncestors: () => (/* binding */ getOverflowAncestors),\n/* harmony export */   getParentNode: () => (/* binding */ getParentNode),\n/* harmony export */   getWindow: () => (/* binding */ getWindow),\n/* harmony export */   isContainingBlock: () => (/* binding */ isContainingBlock),\n/* harmony export */   isElement: () => (/* binding */ isElement),\n/* harmony export */   isHTMLElement: () => (/* binding */ isHTMLElement),\n/* harmony export */   isLastTraversableNode: () => (/* binding */ isLastTraversableNode),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isOverflowElement: () => (/* binding */ isOverflowElement),\n/* harmony export */   isShadowRoot: () => (/* binding */ isShadowRoot),\n/* harmony export */   isTableElement: () => (/* binding */ isTableElement),\n/* harmony export */   isWebKit: () => (/* binding */ isWebKit)\n/* harmony export */ });\nfunction getNodeName(node) {\n    if (isNode(node)) {\n        return (node.nodeName || \"\").toLowerCase();\n    }\n    // Mocked nodes in testing environments may not be instances of Node. By\n    // returning `#document` an infinite loop won't occur.\n    // https://github.com/floating-ui/floating-ui/issues/2317\n    return \"#document\";\n}\nfunction getWindow(node) {\n    var _node$ownerDocument;\n    return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n    var _ref;\n    return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n    return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n    return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n    return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n    // Browsers without `ShadowRoot` support.\n    if (typeof ShadowRoot === \"undefined\") {\n        return false;\n    }\n    return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n    const { overflow, overflowX, overflowY, display } = getComputedStyle(element);\n    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && ![\n        \"inline\",\n        \"contents\"\n    ].includes(display);\n}\nfunction isTableElement(element) {\n    return [\n        \"table\",\n        \"td\",\n        \"th\"\n    ].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n    const webkit = isWebKit();\n    const css = getComputedStyle(element);\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n    return css.transform !== \"none\" || css.perspective !== \"none\" || (css.containerType ? css.containerType !== \"normal\" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== \"none\" : false) || !webkit && (css.filter ? css.filter !== \"none\" : false) || [\n        \"transform\",\n        \"perspective\",\n        \"filter\"\n    ].some((value)=>(css.willChange || \"\").includes(value)) || [\n        \"paint\",\n        \"layout\",\n        \"strict\",\n        \"content\"\n    ].some((value)=>(css.contain || \"\").includes(value));\n}\nfunction getContainingBlock(element) {\n    let currentNode = getParentNode(element);\n    while(isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)){\n        if (isContainingBlock(currentNode)) {\n            return currentNode;\n        } else {\n            currentNode = getParentNode(currentNode);\n        }\n    }\n    return null;\n}\nfunction isWebKit() {\n    if (typeof CSS === \"undefined\" || !CSS.supports) return false;\n    return CSS.supports(\"-webkit-backdrop-filter\", \"none\");\n}\nfunction isLastTraversableNode(node) {\n    return [\n        \"html\",\n        \"body\",\n        \"#document\"\n    ].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n    return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n    if (isElement(element)) {\n        return {\n            scrollLeft: element.scrollLeft,\n            scrollTop: element.scrollTop\n        };\n    }\n    return {\n        scrollLeft: element.pageXOffset,\n        scrollTop: element.pageYOffset\n    };\n}\nfunction getParentNode(node) {\n    if (getNodeName(node) === \"html\") {\n        return node;\n    }\n    const result = // Step into the shadow DOM of the parent of a slotted node.\n    node.assignedSlot || // DOM Element detected.\n    node.parentNode || // ShadowRoot detected.\n    isShadowRoot(node) && node.host || // Fallback.\n    getDocumentElement(node);\n    return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n    const parentNode = getParentNode(node);\n    if (isLastTraversableNode(parentNode)) {\n        return node.ownerDocument ? node.ownerDocument.body : node.body;\n    }\n    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n        return parentNode;\n    }\n    return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n    var _node$ownerDocument2;\n    if (list === void 0) {\n        list = [];\n    }\n    if (traverseIframes === void 0) {\n        traverseIframes = true;\n    }\n    const scrollableAncestor = getNearestOverflowAncestor(node);\n    const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n    const win = getWindow(scrollableAncestor);\n    if (isBody) {\n        return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);\n    }\n    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2RvbS9kaXN0L2Zsb2F0aW5nLXVpLnV0aWxzLmRvbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsU0FBU0EsWUFBWUMsSUFBSTtJQUN2QixJQUFJQyxPQUFPRCxPQUFPO1FBQ2hCLE9BQU8sQ0FBQ0EsS0FBS0UsUUFBUSxJQUFJLEVBQUMsRUFBR0MsV0FBVztJQUMxQztJQUNBLHdFQUF3RTtJQUN4RSxzREFBc0Q7SUFDdEQseURBQXlEO0lBQ3pELE9BQU87QUFDVDtBQUNBLFNBQVNDLFVBQVVKLElBQUk7SUFDckIsSUFBSUs7SUFDSixPQUFPLENBQUNMLFFBQVEsT0FBTyxLQUFLLElBQUksQ0FBQ0ssc0JBQXNCTCxLQUFLTSxhQUFhLEtBQUssT0FBTyxLQUFLLElBQUlELG9CQUFvQkUsV0FBVyxLQUFLQztBQUNwSTtBQUNBLFNBQVNDLG1CQUFtQlQsSUFBSTtJQUM5QixJQUFJVTtJQUNKLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDVCxPQUFPRCxRQUFRQSxLQUFLTSxhQUFhLEdBQUdOLEtBQUtXLFFBQVEsS0FBS0gsT0FBT0csUUFBUSxLQUFLLE9BQU8sS0FBSyxJQUFJRCxLQUFLRSxlQUFlO0FBQ2hJO0FBQ0EsU0FBU1gsT0FBT1ksS0FBSztJQUNuQixPQUFPQSxpQkFBaUJDLFFBQVFELGlCQUFpQlQsVUFBVVMsT0FBT0MsSUFBSTtBQUN4RTtBQUNBLFNBQVNDLFVBQVVGLEtBQUs7SUFDdEIsT0FBT0EsaUJBQWlCRyxXQUFXSCxpQkFBaUJULFVBQVVTLE9BQU9HLE9BQU87QUFDOUU7QUFDQSxTQUFTQyxjQUFjSixLQUFLO0lBQzFCLE9BQU9BLGlCQUFpQkssZUFBZUwsaUJBQWlCVCxVQUFVUyxPQUFPSyxXQUFXO0FBQ3RGO0FBQ0EsU0FBU0MsYUFBYU4sS0FBSztJQUN6Qix5Q0FBeUM7SUFDekMsSUFBSSxPQUFPTyxlQUFlLGFBQWE7UUFDckMsT0FBTztJQUNUO0lB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LGFBQWFYLGNBQWM3QztJQUNqQyxJQUFJOEMsc0JBQXNCVSxhQUFhO1FBQ3JDLE9BQU94RCxLQUFLTSxhQUFhLEdBQUdOLEtBQUtNLGFBQWEsQ0FBQ3FELElBQUksR0FBRzNELEtBQUsyRCxJQUFJO0lBQ2pFO0lBQ0EsSUFBSTFDLGNBQWN1QyxlQUFlbkMsa0JBQWtCbUMsYUFBYTtRQUM5RCxPQUFPQTtJQUNUO0lBQ0EsT0FBT0UsMkJBQTJCRjtBQUNwQztBQUNBLFNBQVNJLHFCQUFxQjVELElBQUksRUFBRTZELElBQUksRUFBRUMsZUFBZTtJQUN2RCxJQUFJQztJQUNKLElBQUlGLFNBQVMsS0FBSyxHQUFHO1FBQ25CQSxPQUFPLEVBQUU7SUFDWDtJQUNBLElBQUlDLG9CQUFvQixLQUFLLEdBQUc7UUFDOUJBLGtCQUFrQjtJQUNwQjtJQUNBLE1BQU1FLHFCQUFxQk4sMkJBQTJCMUQ7SUFDdEQsTUFBTWlFLFNBQVNELHVCQUF3QixFQUFDRCx1QkFBdUIvRCxLQUFLTSxhQUFhLEtBQUssT0FBTyxLQUFLLElBQUl5RCxxQkFBcUJKLElBQUk7SUFDL0gsTUFBTU8sTUFBTTlELFVBQVU0RDtJQUN0QixJQUFJQyxRQUFRO1FBQ1YsT0FBT0osS0FBS00sTUFBTSxDQUFDRCxLQUFLQSxJQUFJRSxjQUFjLElBQUksRUFBRSxFQUFFL0Msa0JBQWtCMkMsc0JBQXNCQSxxQkFBcUIsRUFBRSxFQUFFRSxJQUFJRyxZQUFZLElBQUlQLGtCQUFrQkYscUJBQXFCTSxJQUFJRyxZQUFZLElBQUksRUFBRTtJQUN0TTtJQUNBLE9BQU9SLEtBQUtNLE1BQU0sQ0FBQ0gsb0JBQW9CSixxQkFBcUJJLG9CQUFvQixFQUFFLEVBQUVGO0FBQ3RGO0FBRW1UIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLWFwcC8uL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvdXRpbHMvZG9tL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMuZG9tLm1qcz9hNWE1Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGdldE5vZGVOYW1lKG5vZGUpIHtcbiAgaWYgKGlzTm9kZShub2RlKSkge1xuICAgIHJldHVybiAobm9kZS5ub2RlTmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgfVxuICAvLyBNb2NrZWQgbm9kZXMgaW4gdGVzdGluZyBlbnZpcm9ubWVudHMgbWF5IG5vdCBiZSBpbnN0YW5jZXMgb2YgTm9kZS4gQnlcbiAgLy8gcmV0dXJuaW5nIGAjZG9jdW1lbnRgIGFuIGluZmluaXRlIGxvb3Agd29uJ3Qgb2NjdXIuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMjMxN1xuICByZXR1cm4gJyNkb2N1bWVudCc7XG59XG5mdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICB2YXIgX25vZGUkb3duZXJEb2N1bWVudDtcbiAgcmV0dXJuIChub2RlID09IG51bGwgPyB2b2lkIDAgOiAoX25vZGUkb3duZXJEb2N1bWVudCA9IG5vZGUub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpIHx8IHdpbmRvdztcbn1cbmZ1bmN0aW9uIGdldERvY3VtZW50RWxlbWVudChub2RlKSB7XG4gIHZhciBfcmVmO1xuICByZXR1cm4gKF9yZWYgPSAoaXNOb2RlKG5vZGUpID8gbm9kZS5vd25lckRvY3VtZW50IDogbm9kZS5kb2N1bWVudCkgfHwgd2luZG93LmRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3JlZi5kb2N1bWVudEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc05vZGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTm9kZSB8fCB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyh2YWx1ZSkuTm9kZTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFbGVtZW50IHx8IHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5FbGVtZW50O1xufVxuZnVuY3Rpb24gaXNIVE1MRWxlbWVudCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyh2YWx1ZSkuSFRNTEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc1NoYWRvd1Jvb3QodmFsdWUpIHtcbiAgLy8gQnJvd3NlcnMgd2l0aG91dCBgU2hhZG93Um9vdGAgc3VwcG9ydC5cbiAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBTaGFkb3dSb290IHx8IHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5TaGFkb3dSb290O1xufVxuZnVuY3Rpb24gaXNPdmVyZmxvd0VsZW1lbnQoZWxlbWVudCkge1xuICBjb25zdCB7XG4gICAgb3ZlcmZsb3csXG4gICAgb3ZlcmZsb3dYLFxuICAgIG92ZXJmbG93WSxcbiAgICBkaXNwbGF5XG4gIH0gPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICByZXR1cm4gL2F1dG98c2Nyb2xsfG92ZXJsYXl8aGlkZGVufGNsaXAvLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpICYmICFbJ2lubGluZScsICdjb250ZW50cyddLmluY2x1ZGVzKGRpc3BsYXkpO1xufVxuZnVuY3Rpb24gaXNUYWJsZUVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gWyd0YWJsZScsICd0ZCcsICd0aCddLmluY2x1ZGVzKGdldE5vZGVOYW1lKGVsZW1lbnQpKTtcbn1cbmZ1bmN0aW9uIGlzQ29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHtcbiAgY29uc3Qgd2Via2l0ID0gaXNXZWJLaXQoKTtcbiAgY29uc3QgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xuICByZXR1cm4gY3NzLnRyYW5zZm9ybSAhPT0gJ25vbmUnIHx8IGNzcy5wZXJzcGVjdGl2ZSAhPT0gJ25vbmUnIHx8IChjc3MuY29udGFpbmVyVHlwZSA/IGNzcy5jb250YWluZXJUeXBlICE9PSAnbm9ybWFsJyA6IGZhbHNlKSB8fCAhd2Via2l0ICYmIChjc3MuYmFja2Ryb3BGaWx0ZXIgPyBjc3MuYmFja2Ryb3BGaWx0ZXIgIT09ICdub25lJyA6IGZhbHNlKSB8fCAhd2Via2l0ICYmIChjc3MuZmlsdGVyID8gY3NzLmZpbHRlciAhPT0gJ25vbmUnIDogZmFsc2UpIHx8IFsndHJhbnNmb3JtJywgJ3BlcnNwZWN0aXZlJywgJ2ZpbHRlciddLnNvbWUodmFsdWUgPT4gKGNzcy53aWxsQ2hhbmdlIHx8ICcnKS5pbmNsdWRlcyh2YWx1ZSkpIHx8IFsncGFpbnQnLCAnbGF5b3V0JywgJ3N0cmljdCcsICdjb250ZW50J10uc29tZSh2YWx1ZSA9PiAoY3NzLmNvbnRhaW4gfHwgJycpLmluY2x1ZGVzKHZhbHVlKSk7XG59XG5mdW5jdGlvbiBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xuICBsZXQgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICB3aGlsZSAoaXNIVE1MRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgIWlzTGFzdFRyYXZlcnNhYmxlTm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICBpZiAoaXNDb250YWluaW5nQmxvY2soY3VycmVudE5vZGUpKSB7XG4gICAgICByZXR1cm4gY3VycmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShjdXJyZW50Tm9kZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaXNXZWJLaXQoKSB7XG4gIGlmICh0eXBlb2YgQ1NTID09PSAndW5kZWZpbmVkJyB8fCAhQ1NTLnN1cHBvcnRzKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBDU1Muc3VwcG9ydHMoJy13ZWJraXQtYmFja2Ryb3AtZmlsdGVyJywgJ25vbmUnKTtcbn1cbmZ1bmN0aW9uIGlzTGFzdFRyYXZlcnNhYmxlTm9kZShub2RlKSB7XG4gIHJldHVybiBbJ2h0bWwnLCAnYm9keScsICcjZG9jdW1lbnQnXS5pbmNsdWRlcyhnZXROb2RlTmFtZShub2RlKSk7XG59XG5mdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldFdpbmRvdyhlbGVtZW50KS5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xufVxuZnVuY3Rpb24gZ2V0Tm9kZVNjcm9sbChlbGVtZW50KSB7XG4gIGlmIChpc0VsZW1lbnQoZWxlbWVudCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFRvcFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnBhZ2VYT2Zmc2V0LFxuICAgIHNjcm9sbFRvcDogZWxlbWVudC5wYWdlWU9mZnNldFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShub2RlKSB7XG4gIGlmIChnZXROb2RlTmFtZShub2RlKSA9PT0gJ2h0bWwnKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID1cbiAgLy8gU3RlcCBpbnRvIHRoZSBzaGFkb3cgRE9NIG9mIHRoZSBwYXJlbnQgb2YgYSBzbG90dGVkIG5vZGUuXG4gIG5vZGUuYXNzaWduZWRTbG90IHx8XG4gIC8vIERPTSBFbGVtZW50IGRldGVjdGVkLlxuICBub2RlLnBhcmVudE5vZGUgfHxcbiAgLy8gU2hhZG93Um9vdCBkZXRlY3RlZC5cbiAgaXNTaGFkb3dSb290KG5vZGUpICYmIG5vZGUuaG9zdCB8fFxuICAvLyBGYWxsYmFjay5cbiAgZ2V0RG9jdW1lbnRFbGVtZW50KG5vZGUpO1xuICByZXR1cm4gaXNTaGFkb3dSb290KHJlc3VsdCkgPyByZXN1bHQuaG9zdCA6IHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKG5vZGUpIHtcbiAgY29uc3QgcGFyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUobm9kZSk7XG4gIGlmIChpc0xhc3RUcmF2ZXJzYWJsZU5vZGUocGFyZW50Tm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50ID8gbm9kZS5vd25lckRvY3VtZW50LmJvZHkgOiBub2RlLmJvZHk7XG4gIH1cbiAgaWYgKGlzSFRNTEVsZW1lbnQocGFyZW50Tm9kZSkgJiYgaXNPdmVyZmxvd0VsZW1lbnQocGFyZW50Tm9kZSkpIHtcbiAgICByZXR1cm4gcGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3IocGFyZW50Tm9kZSk7XG59XG5mdW5jdGlvbiBnZXRPdmVyZmxvd0FuY2VzdG9ycyhub2RlLCBsaXN0LCB0cmF2ZXJzZUlmcmFtZXMpIHtcbiAgdmFyIF9ub2RlJG93bmVyRG9jdW1lbnQyO1xuICBpZiAobGlzdCA9PT0gdm9pZCAwKSB7XG4gICAgbGlzdCA9IFtdO1xuICB9XG4gIGlmICh0cmF2ZXJzZUlmcmFtZXMgPT09IHZvaWQgMCkge1xuICAgIHRyYXZlcnNlSWZyYW1lcyA9IHRydWU7XG4gIH1cbiAgY29uc3Qgc2Nyb2xsYWJsZUFuY2VzdG9yID0gZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3Iobm9kZSk7XG4gIGNvbnN0IGlzQm9keSA9IHNjcm9sbGFibGVBbmNlc3RvciA9PT0gKChfbm9kZSRvd25lckRvY3VtZW50MiA9IG5vZGUub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJG93bmVyRG9jdW1lbnQyLmJvZHkpO1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coc2Nyb2xsYWJsZUFuY2VzdG9yKTtcbiAgaWYgKGlzQm9keSkge1xuICAgIHJldHVybiBsaXN0LmNvbmNhdCh3aW4sIHdpbi52aXN1YWxWaWV3cG9ydCB8fCBbXSwgaXNPdmVyZmxvd0VsZW1lbnQoc2Nyb2xsYWJsZUFuY2VzdG9yKSA/IHNjcm9sbGFibGVBbmNlc3RvciA6IFtdLCB3aW4uZnJhbWVFbGVtZW50ICYmIHRyYXZlcnNlSWZyYW1lcyA/IGdldE92ZXJmbG93QW5jZXN0b3JzKHdpbi5mcmFtZUVsZW1lbnQpIDogW10pO1xuICB9XG4gIHJldHVybiBsaXN0LmNvbmNhdChzY3JvbGxhYmxlQW5jZXN0b3IsIGdldE92ZXJmbG93QW5jZXN0b3JzKHNjcm9sbGFibGVBbmNlc3RvciwgW10sIHRyYXZlcnNlSWZyYW1lcykpO1xufVxuXG5leHBvcnQgeyBnZXRDb21wdXRlZFN0eWxlLCBnZXRDb250YWluaW5nQmxvY2ssIGdldERvY3VtZW50RWxlbWVudCwgZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3IsIGdldE5vZGVOYW1lLCBnZXROb2RlU2Nyb2xsLCBnZXRPdmVyZmxvd0FuY2VzdG9ycywgZ2V0UGFyZW50Tm9kZSwgZ2V0V2luZG93LCBpc0NvbnRhaW5pbmdCbG9jaywgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50LCBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUsIGlzTm9kZSwgaXNPdmVyZmxvd0VsZW1lbnQsIGlzU2hhZG93Um9vdCwgaXNUYWJsZUVsZW1lbnQsIGlzV2ViS2l0IH07XG4iXSwibmFtZXMiOlsiZ2V0Tm9kZU5hbWUiLCJub2RlIiwiaXNOb2RlIiwibm9kZU5hbWUiLCJ0b0xvd2VyQ2FzZSIsImdldFdpbmRvdyIsIl9ub2RlJG93bmVyRG9jdW1lbnQiLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJ3aW5kb3ciLCJnZXREb2N1bWVudEVsZW1lbnQiLCJfcmVmIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJ2YWx1ZSIsIk5vZGUiLCJpc0VsZW1lbnQiLCJFbGVtZW50IiwiaXNIVE1MRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiaXNTaGFkb3dSb290IiwiU2hhZG93Um9vdCIsImlzT3ZlcmZsb3dFbGVtZW50IiwiZWxlbWVudCIsIm92ZXJmbG93Iiwib3ZlcmZsb3dYIiwib3ZlcmZsb3dZIiwiZGlzcGxheSIsImdldENvbXB1dGVkU3R5bGUiLCJ0ZXN0IiwiaW5jbHVkZXMiLCJpc1RhYmxlRWxlbWVudCIsImlzQ29udGFpbmluZ0Jsb2NrIiwid2Via2l0IiwiaXNXZWJLaXQiLCJjc3MiLCJ0cmFuc2Zvcm0iLCJwZXJzcGVjdGl2ZSIsImNvbnRhaW5lclR5cGUiLCJiYWNrZHJvcEZpbHRlciIsImZpbHRlciIsInNvbWUiLCJ3aWxsQ2hhbmdlIiwiY29udGFpbiIsImdldENvbnRhaW5pbmdCbG9jayIsImN1cnJlbnROb2RlIiwiZ2V0UGFyZW50Tm9kZSIsImlzTGFzdFRyYXZlcnNhYmxlTm9kZSIsIkNTUyIsInN1cHBvcnRzIiwiZ2V0Tm9kZVNjcm9sbCIsInNjcm9sbExlZnQiLCJzY3JvbGxUb3AiLCJwYWdlWE9mZnNldCIsInBhZ2VZT2Zmc2V0IiwicmVzdWx0IiwiYXNzaWduZWRTbG90IiwicGFyZW50Tm9kZSIsImhvc3QiLCJnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3RvciIsImJvZHkiLCJnZXRPdmVyZmxvd0FuY2VzdG9ycyIsImxpc3QiLCJ0cmF2ZXJzZUlmcmFtZXMiLCJfbm9kZSRvd25lckRvY3VtZW50MiIsInNjcm9sbGFibGVBbmNlc3RvciIsImlzQm9keSIsIndpbiIsImNvbmNhdCIsInZpc3VhbFZpZXdwb3J0IiwiZnJhbWVFbGVtZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs\n");

/***/ })

};
;